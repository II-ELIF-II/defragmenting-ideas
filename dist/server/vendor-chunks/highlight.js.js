"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/highlight.js";
exports.ids = ["vendor-chunks/highlight.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/highlight.js/lib/core.js":
/*!***********************************************!*\
  !*** ./node_modules/highlight.js/lib/core.js ***!
  \***********************************************/
/***/ ((module) => {

eval("/* eslint-disable no-multi-assign */ \nfunction deepFreeze(obj) {\n    if (obj instanceof Map) {\n        obj.clear = obj.delete = obj.set = function() {\n            throw new Error(\"map is read-only\");\n        };\n    } else if (obj instanceof Set) {\n        obj.add = obj.clear = obj.delete = function() {\n            throw new Error(\"set is read-only\");\n        };\n    }\n    // Freeze self\n    Object.freeze(obj);\n    Object.getOwnPropertyNames(obj).forEach((name)=>{\n        const prop = obj[name];\n        const type = typeof prop;\n        // Freeze prop if it is an object or function and also not already frozen\n        if ((type === \"object\" || type === \"function\") && !Object.isFrozen(prop)) {\n            deepFreeze(prop);\n        }\n    });\n    return obj;\n}\n/** @typedef {import('highlight.js').CallbackResponse} CallbackResponse */ /** @typedef {import('highlight.js').CompiledMode} CompiledMode */ /** @implements CallbackResponse */ class Response {\n    /**\n   * @param {CompiledMode} mode\n   */ constructor(mode){\n        // eslint-disable-next-line no-undefined\n        if (mode.data === undefined) mode.data = {};\n        this.data = mode.data;\n        this.isMatchIgnored = false;\n    }\n    ignoreMatch() {\n        this.isMatchIgnored = true;\n    }\n}\n/**\n * @param {string} value\n * @returns {string}\n */ function escapeHTML(value) {\n    return value.replace(/&/g, \"&amp;\").replace(/</g, \"&lt;\").replace(/>/g, \"&gt;\").replace(/\"/g, \"&quot;\").replace(/'/g, \"&#x27;\");\n}\n/**\n * performs a shallow merge of multiple objects into one\n *\n * @template T\n * @param {T} original\n * @param {Record<string,any>[]} objects\n * @returns {T} a single new object\n */ function inherit$1(original, ...objects) {\n    /** @type Record<string,any> */ const result = Object.create(null);\n    for(const key in original){\n        result[key] = original[key];\n    }\n    objects.forEach(function(obj) {\n        for(const key in obj){\n            result[key] = obj[key];\n        }\n    });\n    return /** @type {T} */ result;\n}\n/**\n * @typedef {object} Renderer\n * @property {(text: string) => void} addText\n * @property {(node: Node) => void} openNode\n * @property {(node: Node) => void} closeNode\n * @property {() => string} value\n */ /** @typedef {{scope?: string, language?: string, sublanguage?: boolean}} Node */ /** @typedef {{walk: (r: Renderer) => void}} Tree */ /** */ const SPAN_CLOSE = \"</span>\";\n/**\n * Determines if a node needs to be wrapped in <span>\n *\n * @param {Node} node */ const emitsWrappingTags = (node)=>{\n    // rarely we can have a sublanguage where language is undefined\n    // TODO: track down why\n    return !!node.scope;\n};\n/**\n *\n * @param {string} name\n * @param {{prefix:string}} options\n */ const scopeToCSSClass = (name, { prefix })=>{\n    // sub-language\n    if (name.startsWith(\"language:\")) {\n        return name.replace(\"language:\", \"language-\");\n    }\n    // tiered scope: comment.line\n    if (name.includes(\".\")) {\n        const pieces = name.split(\".\");\n        return [\n            `${prefix}${pieces.shift()}`,\n            ...pieces.map((x, i)=>`${x}${\"_\".repeat(i + 1)}`)\n        ].join(\" \");\n    }\n    // simple scope\n    return `${prefix}${name}`;\n};\n/** @type {Renderer} */ class HTMLRenderer {\n    /**\n   * Creates a new HTMLRenderer\n   *\n   * @param {Tree} parseTree - the parse tree (must support `walk` API)\n   * @param {{classPrefix: string}} options\n   */ constructor(parseTree, options){\n        this.buffer = \"\";\n        this.classPrefix = options.classPrefix;\n        parseTree.walk(this);\n    }\n    /**\n   * Adds texts to the output stream\n   *\n   * @param {string} text */ addText(text) {\n        this.buffer += escapeHTML(text);\n    }\n    /**\n   * Adds a node open to the output stream (if needed)\n   *\n   * @param {Node} node */ openNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        const className = scopeToCSSClass(node.scope, {\n            prefix: this.classPrefix\n        });\n        this.span(className);\n    }\n    /**\n   * Adds a node close to the output stream (if needed)\n   *\n   * @param {Node} node */ closeNode(node) {\n        if (!emitsWrappingTags(node)) return;\n        this.buffer += SPAN_CLOSE;\n    }\n    /**\n   * returns the accumulated buffer\n  */ value() {\n        return this.buffer;\n    }\n    // helpers\n    /**\n   * Builds a span element\n   *\n   * @param {string} className */ span(className) {\n        this.buffer += `<span class=\"${className}\">`;\n    }\n}\n/** @typedef {{scope?: string, language?: string, children: Node[]} | string} Node */ /** @typedef {{scope?: string, language?: string, children: Node[]} } DataNode */ /** @typedef {import('highlight.js').Emitter} Emitter */ /**  */ /** @returns {DataNode} */ const newNode = (opts = {})=>{\n    /** @type DataNode */ const result = {\n        children: []\n    };\n    Object.assign(result, opts);\n    return result;\n};\nclass TokenTree {\n    constructor(){\n        /** @type DataNode */ this.rootNode = newNode();\n        this.stack = [\n            this.rootNode\n        ];\n    }\n    get top() {\n        return this.stack[this.stack.length - 1];\n    }\n    get root() {\n        return this.rootNode;\n    }\n    /** @param {Node} node */ add(node) {\n        this.top.children.push(node);\n    }\n    /** @param {string} scope */ openNode(scope) {\n        /** @type Node */ const node = newNode({\n            scope\n        });\n        this.add(node);\n        this.stack.push(node);\n    }\n    closeNode() {\n        if (this.stack.length > 1) {\n            return this.stack.pop();\n        }\n        // eslint-disable-next-line no-undefined\n        return undefined;\n    }\n    closeAllNodes() {\n        while(this.closeNode());\n    }\n    toJSON() {\n        return JSON.stringify(this.rootNode, null, 4);\n    }\n    /**\n   * @typedef { import(\"./html_renderer\").Renderer } Renderer\n   * @param {Renderer} builder\n   */ walk(builder) {\n        // this does not\n        return this.constructor._walk(builder, this.rootNode);\n    // this works\n    // return TokenTree._walk(builder, this.rootNode);\n    }\n    /**\n   * @param {Renderer} builder\n   * @param {Node} node\n   */ static _walk(builder, node) {\n        if (typeof node === \"string\") {\n            builder.addText(node);\n        } else if (node.children) {\n            builder.openNode(node);\n            node.children.forEach((child)=>this._walk(builder, child));\n            builder.closeNode(node);\n        }\n        return builder;\n    }\n    /**\n   * @param {Node} node\n   */ static _collapse(node) {\n        if (typeof node === \"string\") return;\n        if (!node.children) return;\n        if (node.children.every((el)=>typeof el === \"string\")) {\n            // node.text = node.children.join(\"\");\n            // delete node.children;\n            node.children = [\n                node.children.join(\"\")\n            ];\n        } else {\n            node.children.forEach((child)=>{\n                TokenTree._collapse(child);\n            });\n        }\n    }\n}\n/**\n  Currently this is all private API, but this is the minimal API necessary\n  that an Emitter must implement to fully support the parser.\n\n  Minimal interface:\n\n  - addText(text)\n  - __addSublanguage(emitter, subLanguageName)\n  - startScope(scope)\n  - endScope()\n  - finalize()\n  - toHTML()\n\n*/ /**\n * @implements {Emitter}\n */ class TokenTreeEmitter extends TokenTree {\n    /**\n   * @param {*} options\n   */ constructor(options){\n        super();\n        this.options = options;\n    }\n    /**\n   * @param {string} text\n   */ addText(text) {\n        if (text === \"\") {\n            return;\n        }\n        this.add(text);\n    }\n    /** @param {string} scope */ startScope(scope) {\n        this.openNode(scope);\n    }\n    endScope() {\n        this.closeNode();\n    }\n    /**\n   * @param {Emitter & {root: DataNode}} emitter\n   * @param {string} name\n   */ __addSublanguage(emitter, name) {\n        /** @type DataNode */ const node = emitter.root;\n        if (name) node.scope = `language:${name}`;\n        this.add(node);\n    }\n    toHTML() {\n        const renderer = new HTMLRenderer(this, this.options);\n        return renderer.value();\n    }\n    finalize() {\n        this.closeAllNodes();\n        return true;\n    }\n}\n/**\n * @param {string} value\n * @returns {RegExp}\n * */ /**\n * @param {RegExp | string } re\n * @returns {string}\n */ function source(re) {\n    if (!re) return null;\n    if (typeof re === \"string\") return re;\n    return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function lookahead(re) {\n    return concat(\"(?=\", re, \")\");\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function anyNumberOfTimes(re) {\n    return concat(\"(?:\", re, \")*\");\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */ function optional(re) {\n    return concat(\"(?:\", re, \")?\");\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */ function concat(...args) {\n    const joined = args.map((x)=>source(x)).join(\"\");\n    return joined;\n}\n/**\n * @param { Array<string | RegExp | Object> } args\n * @returns {object}\n */ function stripOptionsFromArgs(args) {\n    const opts = args[args.length - 1];\n    if (typeof opts === \"object\" && opts.constructor === Object) {\n        args.splice(args.length - 1, 1);\n        return opts;\n    } else {\n        return {};\n    }\n}\n/** @typedef { {capture?: boolean} } RegexEitherOptions */ /**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] | [...(RegExp | string)[], RegexEitherOptions]} args\n * @returns {string}\n */ function either(...args) {\n    /** @type { object & {capture?: boolean} }  */ const opts = stripOptionsFromArgs(args);\n    const joined = \"(\" + (opts.capture ? \"\" : \"?:\") + args.map((x)=>source(x)).join(\"|\") + \")\";\n    return joined;\n}\n/**\n * @param {RegExp | string} re\n * @returns {number}\n */ function countMatchGroups(re) {\n    return new RegExp(re.toString() + \"|\").exec(\"\").length - 1;\n}\n/**\n * Does lexeme start with a regular expression match at the beginning\n * @param {RegExp} re\n * @param {string} lexeme\n */ function startsWith(re, lexeme) {\n    const match = re && re.exec(lexeme);\n    return match && match.index === 0;\n}\n// BACKREF_RE matches an open parenthesis or backreference. To avoid\n// an incorrect parse, it additionally matches the following:\n// - [...] elements, where the meaning of parentheses and escapes change\n// - other escape sequences, so we do not misparse escape sequences as\n//   interesting elements\n// - non-matching or lookahead parentheses, which do not capture. These\n//   follow the '(' with a '?'.\nconst BACKREF_RE = /\\[(?:[^\\\\\\]]|\\\\.)*\\]|\\(\\??|\\\\([1-9][0-9]*)|\\\\./;\n// **INTERNAL** Not intended for outside usage\n// join logically computes regexps.join(separator), but fixes the\n// backreferences so they continue to match.\n// it also places each individual regular expression into it's own\n// match group, keeping track of the sequencing of those match groups\n// is currently an exercise for the caller. :-)\n/**\n * @param {(string | RegExp)[]} regexps\n * @param {{joinWith: string}} opts\n * @returns {string}\n */ function _rewriteBackreferences(regexps, { joinWith }) {\n    let numCaptures = 0;\n    return regexps.map((regex)=>{\n        numCaptures += 1;\n        const offset = numCaptures;\n        let re = source(regex);\n        let out = \"\";\n        while(re.length > 0){\n            const match = BACKREF_RE.exec(re);\n            if (!match) {\n                out += re;\n                break;\n            }\n            out += re.substring(0, match.index);\n            re = re.substring(match.index + match[0].length);\n            if (match[0][0] === \"\\\\\" && match[1]) {\n                // Adjust the backreference.\n                out += \"\\\\\" + String(Number(match[1]) + offset);\n            } else {\n                out += match[0];\n                if (match[0] === \"(\") {\n                    numCaptures++;\n                }\n            }\n        }\n        return out;\n    }).map((re)=>`(${re})`).join(joinWith);\n}\n/** @typedef {import('highlight.js').Mode} Mode */ /** @typedef {import('highlight.js').ModeCallback} ModeCallback */ // Common regexps\nconst MATCH_NOTHING_RE = /\\b\\B/;\nconst IDENT_RE = \"[a-zA-Z]\\\\w*\";\nconst UNDERSCORE_IDENT_RE = \"[a-zA-Z_]\\\\w*\";\nconst NUMBER_RE = \"\\\\b\\\\d+(\\\\.\\\\d+)?\";\nconst C_NUMBER_RE = \"(-?)(\\\\b0[xX][a-fA-F0-9]+|(\\\\b\\\\d+(\\\\.\\\\d*)?|\\\\.\\\\d+)([eE][-+]?\\\\d+)?)\"; // 0x..., 0..., decimal, float\nconst BINARY_NUMBER_RE = \"\\\\b(0b[01]+)\"; // 0b...\nconst RE_STARTERS_RE = \"!|!=|!==|%|%=|&|&&|&=|\\\\*|\\\\*=|\\\\+|\\\\+=|,|-|-=|/=|/|:|;|<<|<<=|<=|<|===|==|=|>>>=|>>=|>=|>>>|>>|>|\\\\?|\\\\[|\\\\{|\\\\(|\\\\^|\\\\^=|\\\\||\\\\|=|\\\\|\\\\||~\";\n/**\n* @param { Partial<Mode> & {binary?: string | RegExp} } opts\n*/ const SHEBANG = (opts = {})=>{\n    const beginShebang = /^#![ ]*\\//;\n    if (opts.binary) {\n        opts.begin = concat(beginShebang, /.*\\b/, opts.binary, /\\b.*/);\n    }\n    return inherit$1({\n        scope: \"meta\",\n        begin: beginShebang,\n        end: /$/,\n        relevance: 0,\n        /** @type {ModeCallback} */ \"on:begin\": (m, resp)=>{\n            if (m.index !== 0) resp.ignoreMatch();\n        }\n    }, opts);\n};\n// Common modes\nconst BACKSLASH_ESCAPE = {\n    begin: \"\\\\\\\\[\\\\s\\\\S]\",\n    relevance: 0\n};\nconst APOS_STRING_MODE = {\n    scope: \"string\",\n    begin: \"'\",\n    end: \"'\",\n    illegal: \"\\\\n\",\n    contains: [\n        BACKSLASH_ESCAPE\n    ]\n};\nconst QUOTE_STRING_MODE = {\n    scope: \"string\",\n    begin: '\"',\n    end: '\"',\n    illegal: \"\\\\n\",\n    contains: [\n        BACKSLASH_ESCAPE\n    ]\n};\nconst PHRASAL_WORDS_MODE = {\n    begin: /\\b(a|an|the|are|I'm|isn't|don't|doesn't|won't|but|just|should|pretty|simply|enough|gonna|going|wtf|so|such|will|you|your|they|like|more)\\b/\n};\n/**\n * Creates a comment mode\n *\n * @param {string | RegExp} begin\n * @param {string | RegExp} end\n * @param {Mode | {}} [modeOptions]\n * @returns {Partial<Mode>}\n */ const COMMENT = function(begin, end, modeOptions = {}) {\n    const mode = inherit$1({\n        scope: \"comment\",\n        begin,\n        end,\n        contains: []\n    }, modeOptions);\n    mode.contains.push({\n        scope: \"doctag\",\n        // hack to avoid the space from being included. the space is necessary to\n        // match here to prevent the plain text rule below from gobbling up doctags\n        begin: \"[ ]*(?=(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):)\",\n        end: /(TODO|FIXME|NOTE|BUG|OPTIMIZE|HACK|XXX):/,\n        excludeBegin: true,\n        relevance: 0\n    });\n    const ENGLISH_WORD = either(// list of common 1 and 2 letter words in English\n    \"I\", \"a\", \"is\", \"so\", \"us\", \"to\", \"at\", \"if\", \"in\", \"it\", \"on\", // note: this is not an exhaustive list of contractions, just popular ones\n    /[A-Za-z]+['](d|ve|re|ll|t|s|n)/, /[A-Za-z]+[-][a-z]+/, /[A-Za-z][a-z]{2,}/ // allow capitalized words at beginning of sentences\n    );\n    // looking like plain text, more likely to be a comment\n    mode.contains.push({\n        // TODO: how to include \", (, ) without breaking grammars that use these for\n        // comment delimiters?\n        // begin: /[ ]+([()\"]?([A-Za-z'-]{3,}|is|a|I|so|us|[tT][oO]|at|if|in|it|on)[.]?[()\":]?([.][ ]|[ ]|\\))){3}/\n        // ---\n        // this tries to find sequences of 3 english words in a row (without any\n        // \"programming\" type syntax) this gives us a strong signal that we've\n        // TRULY found a comment - vs perhaps scanning with the wrong language.\n        // It's possible to find something that LOOKS like the start of the\n        // comment - but then if there is no readable text - good chance it is a\n        // false match and not a comment.\n        //\n        // for a visual example please see:\n        // https://github.com/highlightjs/highlight.js/issues/2827\n        begin: concat(/[ ]+/, \"(\", ENGLISH_WORD, /[.]?[:]?([.][ ]|[ ])/, \"){3}\") // look for 3 words in a row\n    });\n    return mode;\n};\nconst C_LINE_COMMENT_MODE = COMMENT(\"//\", \"$\");\nconst C_BLOCK_COMMENT_MODE = COMMENT(\"/\\\\*\", \"\\\\*/\");\nconst HASH_COMMENT_MODE = COMMENT(\"#\", \"$\");\nconst NUMBER_MODE = {\n    scope: \"number\",\n    begin: NUMBER_RE,\n    relevance: 0\n};\nconst C_NUMBER_MODE = {\n    scope: \"number\",\n    begin: C_NUMBER_RE,\n    relevance: 0\n};\nconst BINARY_NUMBER_MODE = {\n    scope: \"number\",\n    begin: BINARY_NUMBER_RE,\n    relevance: 0\n};\nconst REGEXP_MODE = {\n    scope: \"regexp\",\n    begin: /\\/(?=[^/\\n]*\\/)/,\n    end: /\\/[gimuy]*/,\n    contains: [\n        BACKSLASH_ESCAPE,\n        {\n            begin: /\\[/,\n            end: /\\]/,\n            relevance: 0,\n            contains: [\n                BACKSLASH_ESCAPE\n            ]\n        }\n    ]\n};\nconst TITLE_MODE = {\n    scope: \"title\",\n    begin: IDENT_RE,\n    relevance: 0\n};\nconst UNDERSCORE_TITLE_MODE = {\n    scope: \"title\",\n    begin: UNDERSCORE_IDENT_RE,\n    relevance: 0\n};\nconst METHOD_GUARD = {\n    // excludes method names from keyword processing\n    begin: \"\\\\.\\\\s*\" + UNDERSCORE_IDENT_RE,\n    relevance: 0\n};\n/**\n * Adds end same as begin mechanics to a mode\n *\n * Your mode must include at least a single () match group as that first match\n * group is what is used for comparison\n * @param {Partial<Mode>} mode\n */ const END_SAME_AS_BEGIN = function(mode) {\n    return Object.assign(mode, {\n        /** @type {ModeCallback} */ \"on:begin\": (m, resp)=>{\n            resp.data._beginMatch = m[1];\n        },\n        /** @type {ModeCallback} */ \"on:end\": (m, resp)=>{\n            if (resp.data._beginMatch !== m[1]) resp.ignoreMatch();\n        }\n    });\n};\nvar MODES = /*#__PURE__*/ Object.freeze({\n    __proto__: null,\n    APOS_STRING_MODE: APOS_STRING_MODE,\n    BACKSLASH_ESCAPE: BACKSLASH_ESCAPE,\n    BINARY_NUMBER_MODE: BINARY_NUMBER_MODE,\n    BINARY_NUMBER_RE: BINARY_NUMBER_RE,\n    COMMENT: COMMENT,\n    C_BLOCK_COMMENT_MODE: C_BLOCK_COMMENT_MODE,\n    C_LINE_COMMENT_MODE: C_LINE_COMMENT_MODE,\n    C_NUMBER_MODE: C_NUMBER_MODE,\n    C_NUMBER_RE: C_NUMBER_RE,\n    END_SAME_AS_BEGIN: END_SAME_AS_BEGIN,\n    HASH_COMMENT_MODE: HASH_COMMENT_MODE,\n    IDENT_RE: IDENT_RE,\n    MATCH_NOTHING_RE: MATCH_NOTHING_RE,\n    METHOD_GUARD: METHOD_GUARD,\n    NUMBER_MODE: NUMBER_MODE,\n    NUMBER_RE: NUMBER_RE,\n    PHRASAL_WORDS_MODE: PHRASAL_WORDS_MODE,\n    QUOTE_STRING_MODE: QUOTE_STRING_MODE,\n    REGEXP_MODE: REGEXP_MODE,\n    RE_STARTERS_RE: RE_STARTERS_RE,\n    SHEBANG: SHEBANG,\n    TITLE_MODE: TITLE_MODE,\n    UNDERSCORE_IDENT_RE: UNDERSCORE_IDENT_RE,\n    UNDERSCORE_TITLE_MODE: UNDERSCORE_TITLE_MODE\n});\n/**\n@typedef {import('highlight.js').CallbackResponse} CallbackResponse\n@typedef {import('highlight.js').CompilerExt} CompilerExt\n*/ // Grammar extensions / plugins\n// See: https://github.com/highlightjs/highlight.js/issues/2833\n// Grammar extensions allow \"syntactic sugar\" to be added to the grammar modes\n// without requiring any underlying changes to the compiler internals.\n// `compileMatch` being the perfect small example of now allowing a grammar\n// author to write `match` when they desire to match a single expression rather\n// than being forced to use `begin`.  The extension then just moves `match` into\n// `begin` when it runs.  Ie, no features have been added, but we've just made\n// the experience of writing (and reading grammars) a little bit nicer.\n// ------\n// TODO: We need negative look-behind support to do this properly\n/**\n * Skip a match if it has a preceding dot\n *\n * This is used for `beginKeywords` to prevent matching expressions such as\n * `bob.keyword.do()`. The mode compiler automatically wires this up as a\n * special _internal_ 'on:begin' callback for modes with `beginKeywords`\n * @param {RegExpMatchArray} match\n * @param {CallbackResponse} response\n */ function skipIfHasPrecedingDot(match, response) {\n    const before = match.input[match.index - 1];\n    if (before === \".\") {\n        response.ignoreMatch();\n    }\n}\n/**\n *\n * @type {CompilerExt}\n */ function scopeClassName(mode, _parent) {\n    // eslint-disable-next-line no-undefined\n    if (mode.className !== undefined) {\n        mode.scope = mode.className;\n        delete mode.className;\n    }\n}\n/**\n * `beginKeywords` syntactic sugar\n * @type {CompilerExt}\n */ function beginKeywords(mode, parent) {\n    if (!parent) return;\n    if (!mode.beginKeywords) return;\n    // for languages with keywords that include non-word characters checking for\n    // a word boundary is not sufficient, so instead we check for a word boundary\n    // or whitespace - this does no harm in any case since our keyword engine\n    // doesn't allow spaces in keywords anyways and we still check for the boundary\n    // first\n    mode.begin = \"\\\\b(\" + mode.beginKeywords.split(\" \").join(\"|\") + \")(?!\\\\.)(?=\\\\b|\\\\s)\";\n    mode.__beforeBegin = skipIfHasPrecedingDot;\n    mode.keywords = mode.keywords || mode.beginKeywords;\n    delete mode.beginKeywords;\n    // prevents double relevance, the keywords themselves provide\n    // relevance, the mode doesn't need to double it\n    // eslint-disable-next-line no-undefined\n    if (mode.relevance === undefined) mode.relevance = 0;\n}\n/**\n * Allow `illegal` to contain an array of illegal values\n * @type {CompilerExt}\n */ function compileIllegal(mode, _parent) {\n    if (!Array.isArray(mode.illegal)) return;\n    mode.illegal = either(...mode.illegal);\n}\n/**\n * `match` to match a single expression for readability\n * @type {CompilerExt}\n */ function compileMatch(mode, _parent) {\n    if (!mode.match) return;\n    if (mode.begin || mode.end) throw new Error(\"begin & end are not supported with match\");\n    mode.begin = mode.match;\n    delete mode.match;\n}\n/**\n * provides the default 1 relevance to all modes\n * @type {CompilerExt}\n */ function compileRelevance(mode, _parent) {\n    // eslint-disable-next-line no-undefined\n    if (mode.relevance === undefined) mode.relevance = 1;\n}\n// allow beforeMatch to act as a \"qualifier\" for the match\n// the full match begin must be [beforeMatch][begin]\nconst beforeMatchExt = (mode, parent)=>{\n    if (!mode.beforeMatch) return;\n    // starts conflicts with endsParent which we need to make sure the child\n    // rule is not matched multiple times\n    if (mode.starts) throw new Error(\"beforeMatch cannot be used with starts\");\n    const originalMode = Object.assign({}, mode);\n    Object.keys(mode).forEach((key)=>{\n        delete mode[key];\n    });\n    mode.keywords = originalMode.keywords;\n    mode.begin = concat(originalMode.beforeMatch, lookahead(originalMode.begin));\n    mode.starts = {\n        relevance: 0,\n        contains: [\n            Object.assign(originalMode, {\n                endsParent: true\n            })\n        ]\n    };\n    mode.relevance = 0;\n    delete originalMode.beforeMatch;\n};\n// keywords that should have no default relevance value\nconst COMMON_KEYWORDS = [\n    \"of\",\n    \"and\",\n    \"for\",\n    \"in\",\n    \"not\",\n    \"or\",\n    \"if\",\n    \"then\",\n    \"parent\",\n    \"list\",\n    \"value\" // common variable name\n];\nconst DEFAULT_KEYWORD_SCOPE = \"keyword\";\n/**\n * Given raw keywords from a language definition, compile them.\n *\n * @param {string | Record<string,string|string[]> | Array<string>} rawKeywords\n * @param {boolean} caseInsensitive\n */ function compileKeywords(rawKeywords, caseInsensitive, scopeName = DEFAULT_KEYWORD_SCOPE) {\n    /** @type {import(\"highlight.js/private\").KeywordDict} */ const compiledKeywords = Object.create(null);\n    // input can be a string of keywords, an array of keywords, or a object with\n    // named keys representing scopeName (which can then point to a string or array)\n    if (typeof rawKeywords === \"string\") {\n        compileList(scopeName, rawKeywords.split(\" \"));\n    } else if (Array.isArray(rawKeywords)) {\n        compileList(scopeName, rawKeywords);\n    } else {\n        Object.keys(rawKeywords).forEach(function(scopeName) {\n            // collapse all our objects back into the parent object\n            Object.assign(compiledKeywords, compileKeywords(rawKeywords[scopeName], caseInsensitive, scopeName));\n        });\n    }\n    return compiledKeywords;\n    // ---\n    /**\n   * Compiles an individual list of keywords\n   *\n   * Ex: \"for if when while|5\"\n   *\n   * @param {string} scopeName\n   * @param {Array<string>} keywordList\n   */ function compileList(scopeName, keywordList) {\n        if (caseInsensitive) {\n            keywordList = keywordList.map((x)=>x.toLowerCase());\n        }\n        keywordList.forEach(function(keyword) {\n            const pair = keyword.split(\"|\");\n            compiledKeywords[pair[0]] = [\n                scopeName,\n                scoreForKeyword(pair[0], pair[1])\n            ];\n        });\n    }\n}\n/**\n * Returns the proper score for a given keyword\n *\n * Also takes into account comment keywords, which will be scored 0 UNLESS\n * another score has been manually assigned.\n * @param {string} keyword\n * @param {string} [providedScore]\n */ function scoreForKeyword(keyword, providedScore) {\n    // manual scores always win over common keywords\n    // so you can force a score of 1 if you really insist\n    if (providedScore) {\n        return Number(providedScore);\n    }\n    return commonKeyword(keyword) ? 0 : 1;\n}\n/**\n * Determines if a given keyword is common or not\n *\n * @param {string} keyword */ function commonKeyword(keyword) {\n    return COMMON_KEYWORDS.includes(keyword.toLowerCase());\n}\n/*\n\nFor the reasoning behind this please see:\nhttps://github.com/highlightjs/highlight.js/issues/2880#issuecomment-747275419\n\n*/ /**\n * @type {Record<string, boolean>}\n */ const seenDeprecations = {};\n/**\n * @param {string} message\n */ const error = (message)=>{\n    console.error(message);\n};\n/**\n * @param {string} message\n * @param {any} args\n */ const warn = (message, ...args)=>{\n    console.log(`WARN: ${message}`, ...args);\n};\n/**\n * @param {string} version\n * @param {string} message\n */ const deprecated = (version, message)=>{\n    if (seenDeprecations[`${version}/${message}`]) return;\n    console.log(`Deprecated as of ${version}. ${message}`);\n    seenDeprecations[`${version}/${message}`] = true;\n};\n/* eslint-disable no-throw-literal */ /**\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n*/ const MultiClassError = new Error();\n/**\n * Renumbers labeled scope names to account for additional inner match\n * groups that otherwise would break everything.\n *\n * Lets say we 3 match scopes:\n *\n *   { 1 => ..., 2 => ..., 3 => ... }\n *\n * So what we need is a clean match like this:\n *\n *   (a)(b)(c) => [ \"a\", \"b\", \"c\" ]\n *\n * But this falls apart with inner match groups:\n *\n * (a)(((b)))(c) => [\"a\", \"b\", \"b\", \"b\", \"c\" ]\n *\n * Our scopes are now \"out of alignment\" and we're repeating `b` 3 times.\n * What needs to happen is the numbers are remapped:\n *\n *   { 1 => ..., 2 => ..., 5 => ... }\n *\n * We also need to know that the ONLY groups that should be output\n * are 1, 2, and 5.  This function handles this behavior.\n *\n * @param {CompiledMode} mode\n * @param {Array<RegExp | string>} regexes\n * @param {{key: \"beginScope\"|\"endScope\"}} opts\n */ function remapScopeNames(mode, regexes, { key }) {\n    let offset = 0;\n    const scopeNames = mode[key];\n    /** @type Record<number,boolean> */ const emit = {};\n    /** @type Record<number,string> */ const positions = {};\n    for(let i = 1; i <= regexes.length; i++){\n        positions[i + offset] = scopeNames[i];\n        emit[i + offset] = true;\n        offset += countMatchGroups(regexes[i - 1]);\n    }\n    // we use _emit to keep track of which match groups are \"top-level\" to avoid double\n    // output from inside match groups\n    mode[key] = positions;\n    mode[key]._emit = emit;\n    mode[key]._multi = true;\n}\n/**\n * @param {CompiledMode} mode\n */ function beginMultiClass(mode) {\n    if (!Array.isArray(mode.begin)) return;\n    if (mode.skip || mode.excludeBegin || mode.returnBegin) {\n        error(\"skip, excludeBegin, returnBegin not compatible with beginScope: {}\");\n        throw MultiClassError;\n    }\n    if (typeof mode.beginScope !== \"object\" || mode.beginScope === null) {\n        error(\"beginScope must be object\");\n        throw MultiClassError;\n    }\n    remapScopeNames(mode, mode.begin, {\n        key: \"beginScope\"\n    });\n    mode.begin = _rewriteBackreferences(mode.begin, {\n        joinWith: \"\"\n    });\n}\n/**\n * @param {CompiledMode} mode\n */ function endMultiClass(mode) {\n    if (!Array.isArray(mode.end)) return;\n    if (mode.skip || mode.excludeEnd || mode.returnEnd) {\n        error(\"skip, excludeEnd, returnEnd not compatible with endScope: {}\");\n        throw MultiClassError;\n    }\n    if (typeof mode.endScope !== \"object\" || mode.endScope === null) {\n        error(\"endScope must be object\");\n        throw MultiClassError;\n    }\n    remapScopeNames(mode, mode.end, {\n        key: \"endScope\"\n    });\n    mode.end = _rewriteBackreferences(mode.end, {\n        joinWith: \"\"\n    });\n}\n/**\n * this exists only to allow `scope: {}` to be used beside `match:`\n * Otherwise `beginScope` would necessary and that would look weird\n\n  {\n    match: [ /def/, /\\w+/ ]\n    scope: { 1: \"keyword\" , 2: \"title\" }\n  }\n\n * @param {CompiledMode} mode\n */ function scopeSugar(mode) {\n    if (mode.scope && typeof mode.scope === \"object\" && mode.scope !== null) {\n        mode.beginScope = mode.scope;\n        delete mode.scope;\n    }\n}\n/**\n * @param {CompiledMode} mode\n */ function MultiClass(mode) {\n    scopeSugar(mode);\n    if (typeof mode.beginScope === \"string\") {\n        mode.beginScope = {\n            _wrap: mode.beginScope\n        };\n    }\n    if (typeof mode.endScope === \"string\") {\n        mode.endScope = {\n            _wrap: mode.endScope\n        };\n    }\n    beginMultiClass(mode);\n    endMultiClass(mode);\n}\n/**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').CompiledLanguage} CompiledLanguage\n*/ // compilation\n/**\n * Compiles a language definition result\n *\n * Given the raw result of a language definition (Language), compiles this so\n * that it is ready for highlighting code.\n * @param {Language} language\n * @returns {CompiledLanguage}\n */ function compileLanguage(language) {\n    /**\n   * Builds a regex with the case sensitivity of the current language\n   *\n   * @param {RegExp | string} value\n   * @param {boolean} [global]\n   */ function langRe(value, global) {\n        return new RegExp(source(value), \"m\" + (language.case_insensitive ? \"i\" : \"\") + (language.unicodeRegex ? \"u\" : \"\") + (global ? \"g\" : \"\"));\n    }\n    /**\n    Stores multiple regular expressions and allows you to quickly search for\n    them all in a string simultaneously - returning the first match.  It does\n    this by creating a huge (a|b|c) regex - each individual item wrapped with ()\n    and joined by `|` - using match groups to track position.  When a match is\n    found checking which position in the array has content allows us to figure\n    out which of the original regexes / match groups triggered the match.\n\n    The match object itself (the result of `Regex.exec`) is returned but also\n    enhanced by merging in any meta-data that was registered with the regex.\n    This is how we keep track of which mode matched, and what type of rule\n    (`illegal`, `begin`, end, etc).\n  */ class MultiRegex {\n        constructor(){\n            this.matchIndexes = {};\n            // @ts-ignore\n            this.regexes = [];\n            this.matchAt = 1;\n            this.position = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n            opts.position = this.position++;\n            // @ts-ignore\n            this.matchIndexes[this.matchAt] = opts;\n            this.regexes.push([\n                opts,\n                re\n            ]);\n            this.matchAt += countMatchGroups(re) + 1;\n        }\n        compile() {\n            if (this.regexes.length === 0) {\n                // avoids the need to check length every time exec is called\n                // @ts-ignore\n                this.exec = ()=>null;\n            }\n            const terminators = this.regexes.map((el)=>el[1]);\n            this.matcherRe = langRe(_rewriteBackreferences(terminators, {\n                joinWith: \"|\"\n            }), true);\n            this.lastIndex = 0;\n        }\n        /** @param {string} s */ exec(s) {\n            this.matcherRe.lastIndex = this.lastIndex;\n            const match = this.matcherRe.exec(s);\n            if (!match) {\n                return null;\n            }\n            // eslint-disable-next-line no-undefined\n            const i = match.findIndex((el, i)=>i > 0 && el !== undefined);\n            // @ts-ignore\n            const matchData = this.matchIndexes[i];\n            // trim off any earlier non-relevant match groups (ie, the other regex\n            // match groups that make up the multi-matcher)\n            match.splice(0, i);\n            return Object.assign(match, matchData);\n        }\n    }\n    /*\n    Created to solve the key deficiently with MultiRegex - there is no way to\n    test for multiple matches at a single location.  Why would we need to do\n    that?  In the future a more dynamic engine will allow certain matches to be\n    ignored.  An example: if we matched say the 3rd regex in a large group but\n    decided to ignore it - we'd need to started testing again at the 4th\n    regex... but MultiRegex itself gives us no real way to do that.\n\n    So what this class creates MultiRegexs on the fly for whatever search\n    position they are needed.\n\n    NOTE: These additional MultiRegex objects are created dynamically.  For most\n    grammars most of the time we will never actually need anything more than the\n    first MultiRegex - so this shouldn't have too much overhead.\n\n    Say this is our search group, and we match regex3, but wish to ignore it.\n\n      regex1 | regex2 | regex3 | regex4 | regex5    ' ie, startAt = 0\n\n    What we need is a new MultiRegex that only includes the remaining\n    possibilities:\n\n      regex4 | regex5                               ' ie, startAt = 3\n\n    This class wraps all that complexity up in a simple API... `startAt` decides\n    where in the array of expressions to start doing the matching. It\n    auto-increments, so if a match is found at position 2, then startAt will be\n    set to 3.  If the end is reached startAt will return to 0.\n\n    MOST of the time the parser will be setting startAt manually to 0.\n  */ class ResumableMultiRegex {\n        constructor(){\n            // @ts-ignore\n            this.rules = [];\n            // @ts-ignore\n            this.multiRegexes = [];\n            this.count = 0;\n            this.lastIndex = 0;\n            this.regexIndex = 0;\n        }\n        // @ts-ignore\n        getMatcher(index) {\n            if (this.multiRegexes[index]) return this.multiRegexes[index];\n            const matcher = new MultiRegex();\n            this.rules.slice(index).forEach(([re, opts])=>matcher.addRule(re, opts));\n            matcher.compile();\n            this.multiRegexes[index] = matcher;\n            return matcher;\n        }\n        resumingScanAtSamePosition() {\n            return this.regexIndex !== 0;\n        }\n        considerAll() {\n            this.regexIndex = 0;\n        }\n        // @ts-ignore\n        addRule(re, opts) {\n            this.rules.push([\n                re,\n                opts\n            ]);\n            if (opts.type === \"begin\") this.count++;\n        }\n        /** @param {string} s */ exec(s) {\n            const m = this.getMatcher(this.regexIndex);\n            m.lastIndex = this.lastIndex;\n            let result = m.exec(s);\n            // The following is because we have no easy way to say \"resume scanning at the\n            // existing position but also skip the current rule ONLY\". What happens is\n            // all prior rules are also skipped which can result in matching the wrong\n            // thing. Example of matching \"booger\":\n            // our matcher is [string, \"booger\", number]\n            //\n            // ....booger....\n            // if \"booger\" is ignored then we'd really need a regex to scan from the\n            // SAME position for only: [string, number] but ignoring \"booger\" (if it\n            // was the first match), a simple resume would scan ahead who knows how\n            // far looking only for \"number\", ignoring potential string matches (or\n            // future \"booger\" matches that might be valid.)\n            // So what we do: We execute two matchers, one resuming at the same\n            // position, but the second full matcher starting at the position after:\n            //     /--- resume first regex match here (for [number])\n            //     |/---- full match here for [string, \"booger\", number]\n            //     vv\n            // ....booger....\n            // Which ever results in a match first is then used. So this 3-4 step\n            // process essentially allows us to say \"match at this position, excluding\n            // a prior rule that was ignored\".\n            //\n            // 1. Match \"booger\" first, ignore. Also proves that [string] does non match.\n            // 2. Resume matching for [number]\n            // 3. Match at index + 1 for [string, \"booger\", number]\n            // 4. If #2 and #3 result in matches, which came first?\n            if (this.resumingScanAtSamePosition()) {\n                if (result && result.index === this.lastIndex) ;\n                else {\n                    const m2 = this.getMatcher(0);\n                    m2.lastIndex = this.lastIndex + 1;\n                    result = m2.exec(s);\n                }\n            }\n            if (result) {\n                this.regexIndex += result.position + 1;\n                if (this.regexIndex === this.count) {\n                    // wrap-around to considering all matches again\n                    this.considerAll();\n                }\n            }\n            return result;\n        }\n    }\n    /**\n   * Given a mode, builds a huge ResumableMultiRegex that can be used to walk\n   * the content and find matches.\n   *\n   * @param {CompiledMode} mode\n   * @returns {ResumableMultiRegex}\n   */ function buildModeRegex(mode) {\n        const mm = new ResumableMultiRegex();\n        mode.contains.forEach((term)=>mm.addRule(term.begin, {\n                rule: term,\n                type: \"begin\"\n            }));\n        if (mode.terminatorEnd) {\n            mm.addRule(mode.terminatorEnd, {\n                type: \"end\"\n            });\n        }\n        if (mode.illegal) {\n            mm.addRule(mode.illegal, {\n                type: \"illegal\"\n            });\n        }\n        return mm;\n    }\n    /** skip vs abort vs ignore\n   *\n   * @skip   - The mode is still entered and exited normally (and contains rules apply),\n   *           but all content is held and added to the parent buffer rather than being\n   *           output when the mode ends.  Mostly used with `sublanguage` to build up\n   *           a single large buffer than can be parsed by sublanguage.\n   *\n   *             - The mode begin ands ends normally.\n   *             - Content matched is added to the parent mode buffer.\n   *             - The parser cursor is moved forward normally.\n   *\n   * @abort  - A hack placeholder until we have ignore.  Aborts the mode (as if it\n   *           never matched) but DOES NOT continue to match subsequent `contains`\n   *           modes.  Abort is bad/suboptimal because it can result in modes\n   *           farther down not getting applied because an earlier rule eats the\n   *           content but then aborts.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is added to the mode buffer.\n   *             - The parser cursor is moved forward accordingly.\n   *\n   * @ignore - Ignores the mode (as if it never matched) and continues to match any\n   *           subsequent `contains` modes.  Ignore isn't technically possible with\n   *           the current parser implementation.\n   *\n   *             - The mode does not begin.\n   *             - Content matched by `begin` is ignored.\n   *             - The parser cursor is not moved forward.\n   */ /**\n   * Compiles an individual mode\n   *\n   * This can raise an error if the mode contains certain detectable known logic\n   * issues.\n   * @param {Mode} mode\n   * @param {CompiledMode | null} [parent]\n   * @returns {CompiledMode | never}\n   */ function compileMode(mode, parent) {\n        const cmode = /** @type CompiledMode */ mode;\n        if (mode.isCompiled) return cmode;\n        [\n            scopeClassName,\n            // do this early so compiler extensions generally don't have to worry about\n            // the distinction between match/begin\n            compileMatch,\n            MultiClass,\n            beforeMatchExt\n        ].forEach((ext)=>ext(mode, parent));\n        language.compilerExtensions.forEach((ext)=>ext(mode, parent));\n        // __beforeBegin is considered private API, internal use only\n        mode.__beforeBegin = null;\n        [\n            beginKeywords,\n            // do this later so compiler extensions that come earlier have access to the\n            // raw array if they wanted to perhaps manipulate it, etc.\n            compileIllegal,\n            // default to 1 relevance if not specified\n            compileRelevance\n        ].forEach((ext)=>ext(mode, parent));\n        mode.isCompiled = true;\n        let keywordPattern = null;\n        if (typeof mode.keywords === \"object\" && mode.keywords.$pattern) {\n            // we need a copy because keywords might be compiled multiple times\n            // so we can't go deleting $pattern from the original on the first\n            // pass\n            mode.keywords = Object.assign({}, mode.keywords);\n            keywordPattern = mode.keywords.$pattern;\n            delete mode.keywords.$pattern;\n        }\n        keywordPattern = keywordPattern || /\\w+/;\n        if (mode.keywords) {\n            mode.keywords = compileKeywords(mode.keywords, language.case_insensitive);\n        }\n        cmode.keywordPatternRe = langRe(keywordPattern, true);\n        if (parent) {\n            if (!mode.begin) mode.begin = /\\B|\\b/;\n            cmode.beginRe = langRe(cmode.begin);\n            if (!mode.end && !mode.endsWithParent) mode.end = /\\B|\\b/;\n            if (mode.end) cmode.endRe = langRe(cmode.end);\n            cmode.terminatorEnd = source(cmode.end) || \"\";\n            if (mode.endsWithParent && parent.terminatorEnd) {\n                cmode.terminatorEnd += (mode.end ? \"|\" : \"\") + parent.terminatorEnd;\n            }\n        }\n        if (mode.illegal) cmode.illegalRe = langRe(/** @type {RegExp | string} */ mode.illegal);\n        if (!mode.contains) mode.contains = [];\n        mode.contains = [].concat(...mode.contains.map(function(c) {\n            return expandOrCloneMode(c === \"self\" ? mode : c);\n        }));\n        mode.contains.forEach(function(c) {\n            compileMode(/** @type Mode */ c, cmode);\n        });\n        if (mode.starts) {\n            compileMode(mode.starts, parent);\n        }\n        cmode.matcher = buildModeRegex(cmode);\n        return cmode;\n    }\n    if (!language.compilerExtensions) language.compilerExtensions = [];\n    // self is not valid at the top-level\n    if (language.contains && language.contains.includes(\"self\")) {\n        throw new Error(\"ERR: contains `self` is not supported at the top-level of a language.  See documentation.\");\n    }\n    // we need a null object, which inherit will guarantee\n    language.classNameAliases = inherit$1(language.classNameAliases || {});\n    return compileMode(/** @type Mode */ language);\n}\n/**\n * Determines if a mode has a dependency on it's parent or not\n *\n * If a mode does have a parent dependency then often we need to clone it if\n * it's used in multiple places so that each copy points to the correct parent,\n * where-as modes without a parent can often safely be re-used at the bottom of\n * a mode chain.\n *\n * @param {Mode | null} mode\n * @returns {boolean} - is there a dependency on the parent?\n * */ function dependencyOnParent(mode) {\n    if (!mode) return false;\n    return mode.endsWithParent || dependencyOnParent(mode.starts);\n}\n/**\n * Expands a mode or clones it if necessary\n *\n * This is necessary for modes with parental dependenceis (see notes on\n * `dependencyOnParent`) and for nodes that have `variants` - which must then be\n * exploded into their own individual modes at compile time.\n *\n * @param {Mode} mode\n * @returns {Mode | Mode[]}\n * */ function expandOrCloneMode(mode) {\n    if (mode.variants && !mode.cachedVariants) {\n        mode.cachedVariants = mode.variants.map(function(variant) {\n            return inherit$1(mode, {\n                variants: null\n            }, variant);\n        });\n    }\n    // EXPAND\n    // if we have variants then essentially \"replace\" the mode with the variants\n    // this happens in compileMode, where this function is called from\n    if (mode.cachedVariants) {\n        return mode.cachedVariants;\n    }\n    // CLONE\n    // if we have dependencies on parents then we need a unique\n    // instance of ourselves, so we can be reused with many\n    // different parents without issue\n    if (dependencyOnParent(mode)) {\n        return inherit$1(mode, {\n            starts: mode.starts ? inherit$1(mode.starts) : null\n        });\n    }\n    if (Object.isFrozen(mode)) {\n        return inherit$1(mode);\n    }\n    // no special dependency issues, just return ourselves\n    return mode;\n}\nvar version = \"11.9.0\";\nclass HTMLInjectionError extends Error {\n    constructor(reason, html){\n        super(reason);\n        this.name = \"HTMLInjectionError\";\n        this.html = html;\n    }\n}\n/*\nSyntax highlighting with language autodetection.\nhttps://highlightjs.org/\n*/ /**\n@typedef {import('highlight.js').Mode} Mode\n@typedef {import('highlight.js').CompiledMode} CompiledMode\n@typedef {import('highlight.js').CompiledScope} CompiledScope\n@typedef {import('highlight.js').Language} Language\n@typedef {import('highlight.js').HLJSApi} HLJSApi\n@typedef {import('highlight.js').HLJSPlugin} HLJSPlugin\n@typedef {import('highlight.js').PluginEvent} PluginEvent\n@typedef {import('highlight.js').HLJSOptions} HLJSOptions\n@typedef {import('highlight.js').LanguageFn} LanguageFn\n@typedef {import('highlight.js').HighlightedHTMLElement} HighlightedHTMLElement\n@typedef {import('highlight.js').BeforeHighlightContext} BeforeHighlightContext\n@typedef {import('highlight.js/private').MatchType} MatchType\n@typedef {import('highlight.js/private').KeywordData} KeywordData\n@typedef {import('highlight.js/private').EnhancedMatch} EnhancedMatch\n@typedef {import('highlight.js/private').AnnotatedError} AnnotatedError\n@typedef {import('highlight.js').AutoHighlightResult} AutoHighlightResult\n@typedef {import('highlight.js').HighlightOptions} HighlightOptions\n@typedef {import('highlight.js').HighlightResult} HighlightResult\n*/ const escape = escapeHTML;\nconst inherit = inherit$1;\nconst NO_MATCH = Symbol(\"nomatch\");\nconst MAX_KEYWORD_HITS = 7;\n/**\n * @param {any} hljs - object that is extended (legacy)\n * @returns {HLJSApi}\n */ const HLJS = function(hljs) {\n    // Global internal variables used within the highlight.js library.\n    /** @type {Record<string, Language>} */ const languages = Object.create(null);\n    /** @type {Record<string, string>} */ const aliases = Object.create(null);\n    /** @type {HLJSPlugin[]} */ const plugins = [];\n    // safe/production mode - swallows more errors, tries to keep running\n    // even if a single syntax or parse hits a fatal error\n    let SAFE_MODE = true;\n    const LANGUAGE_NOT_FOUND = \"Could not find the language '{}', did you forget to load/include a language module?\";\n    /** @type {Language} */ const PLAINTEXT_LANGUAGE = {\n        disableAutodetect: true,\n        name: \"Plain text\",\n        contains: []\n    };\n    // Global options used when within external APIs. This is modified when\n    // calling the `hljs.configure` function.\n    /** @type HLJSOptions */ let options = {\n        ignoreUnescapedHTML: false,\n        throwUnescapedHTML: false,\n        noHighlightRe: /^(no-?highlight)$/i,\n        languageDetectRe: /\\blang(?:uage)?-([\\w-]+)\\b/i,\n        classPrefix: \"hljs-\",\n        cssSelector: \"pre code\",\n        languages: null,\n        // beta configuration options, subject to change, welcome to discuss\n        // https://github.com/highlightjs/highlight.js/issues/1086\n        __emitter: TokenTreeEmitter\n    };\n    /* Utility functions */ /**\n   * Tests a language name to see if highlighting should be skipped\n   * @param {string} languageName\n   */ function shouldNotHighlight(languageName) {\n        return options.noHighlightRe.test(languageName);\n    }\n    /**\n   * @param {HighlightedHTMLElement} block - the HTML element to determine language for\n   */ function blockLanguage(block) {\n        let classes = block.className + \" \";\n        classes += block.parentNode ? block.parentNode.className : \"\";\n        // language-* takes precedence over non-prefixed class names.\n        const match = options.languageDetectRe.exec(classes);\n        if (match) {\n            const language = getLanguage(match[1]);\n            if (!language) {\n                warn(LANGUAGE_NOT_FOUND.replace(\"{}\", match[1]));\n                warn(\"Falling back to no-highlight mode for this block.\", block);\n            }\n            return language ? match[1] : \"no-highlight\";\n        }\n        return classes.split(/\\s+/).find((_class)=>shouldNotHighlight(_class) || getLanguage(_class));\n    }\n    /**\n   * Core highlighting function.\n   *\n   * OLD API\n   * highlight(lang, code, ignoreIllegals, continuation)\n   *\n   * NEW API\n   * highlight(code, {lang, ignoreIllegals})\n   *\n   * @param {string} codeOrLanguageName - the language to use for highlighting\n   * @param {string | HighlightOptions} optionsOrCode - the code to highlight\n   * @param {boolean} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   *\n   * @returns {HighlightResult} Result - an object that represents the result\n   * @property {string} language - the language name\n   * @property {number} relevance - the relevance score\n   * @property {string} value - the highlighted HTML code\n   * @property {string} code - the original raw code\n   * @property {CompiledMode} top - top of the current mode stack\n   * @property {boolean} illegal - indicates whether any illegal matches were found\n  */ function highlight(codeOrLanguageName, optionsOrCode, ignoreIllegals) {\n        let code = \"\";\n        let languageName = \"\";\n        if (typeof optionsOrCode === \"object\") {\n            code = codeOrLanguageName;\n            ignoreIllegals = optionsOrCode.ignoreIllegals;\n            languageName = optionsOrCode.language;\n        } else {\n            // old API\n            deprecated(\"10.7.0\", \"highlight(lang, code, ...args) has been deprecated.\");\n            deprecated(\"10.7.0\", \"Please use highlight(code, options) instead.\\nhttps://github.com/highlightjs/highlight.js/issues/2277\");\n            languageName = codeOrLanguageName;\n            code = optionsOrCode;\n        }\n        // https://github.com/highlightjs/highlight.js/issues/3149\n        // eslint-disable-next-line no-undefined\n        if (ignoreIllegals === undefined) {\n            ignoreIllegals = true;\n        }\n        /** @type {BeforeHighlightContext} */ const context = {\n            code,\n            language: languageName\n        };\n        // the plugin can change the desired language or the code to be highlighted\n        // just be changing the object it was passed\n        fire(\"before:highlight\", context);\n        // a before plugin can usurp the result completely by providing it's own\n        // in which case we don't even need to call highlight\n        const result = context.result ? context.result : _highlight(context.language, context.code, ignoreIllegals);\n        result.code = context.code;\n        // the plugin can change anything in result to suite it\n        fire(\"after:highlight\", result);\n        return result;\n    }\n    /**\n   * private highlight that's used internally and does not fire callbacks\n   *\n   * @param {string} languageName - the language to use for highlighting\n   * @param {string} codeToHighlight - the code to highlight\n   * @param {boolean?} [ignoreIllegals] - whether to ignore illegal matches, default is to bail\n   * @param {CompiledMode?} [continuation] - current continuation mode, if any\n   * @returns {HighlightResult} - result of the highlight operation\n  */ function _highlight(languageName, codeToHighlight, ignoreIllegals, continuation) {\n        const keywordHits = Object.create(null);\n        /**\n     * Return keyword data if a match is a keyword\n     * @param {CompiledMode} mode - current mode\n     * @param {string} matchText - the textual match\n     * @returns {KeywordData | false}\n     */ function keywordData(mode, matchText) {\n            return mode.keywords[matchText];\n        }\n        function processKeywords() {\n            if (!top.keywords) {\n                emitter.addText(modeBuffer);\n                return;\n            }\n            let lastIndex = 0;\n            top.keywordPatternRe.lastIndex = 0;\n            let match = top.keywordPatternRe.exec(modeBuffer);\n            let buf = \"\";\n            while(match){\n                buf += modeBuffer.substring(lastIndex, match.index);\n                const word = language.case_insensitive ? match[0].toLowerCase() : match[0];\n                const data = keywordData(top, word);\n                if (data) {\n                    const [kind, keywordRelevance] = data;\n                    emitter.addText(buf);\n                    buf = \"\";\n                    keywordHits[word] = (keywordHits[word] || 0) + 1;\n                    if (keywordHits[word] <= MAX_KEYWORD_HITS) relevance += keywordRelevance;\n                    if (kind.startsWith(\"_\")) {\n                        // _ implied for relevance only, do not highlight\n                        // by applying a class name\n                        buf += match[0];\n                    } else {\n                        const cssClass = language.classNameAliases[kind] || kind;\n                        emitKeyword(match[0], cssClass);\n                    }\n                } else {\n                    buf += match[0];\n                }\n                lastIndex = top.keywordPatternRe.lastIndex;\n                match = top.keywordPatternRe.exec(modeBuffer);\n            }\n            buf += modeBuffer.substring(lastIndex);\n            emitter.addText(buf);\n        }\n        function processSubLanguage() {\n            if (modeBuffer === \"\") return;\n            /** @type HighlightResult */ let result = null;\n            if (typeof top.subLanguage === \"string\") {\n                if (!languages[top.subLanguage]) {\n                    emitter.addText(modeBuffer);\n                    return;\n                }\n                result = _highlight(top.subLanguage, modeBuffer, true, continuations[top.subLanguage]);\n                continuations[top.subLanguage] = /** @type {CompiledMode} */ result._top;\n            } else {\n                result = highlightAuto(modeBuffer, top.subLanguage.length ? top.subLanguage : null);\n            }\n            // Counting embedded language score towards the host language may be disabled\n            // with zeroing the containing mode relevance. Use case in point is Markdown that\n            // allows XML everywhere and makes every XML snippet to have a much larger Markdown\n            // score.\n            if (top.relevance > 0) {\n                relevance += result.relevance;\n            }\n            emitter.__addSublanguage(result._emitter, result.language);\n        }\n        function processBuffer() {\n            if (top.subLanguage != null) {\n                processSubLanguage();\n            } else {\n                processKeywords();\n            }\n            modeBuffer = \"\";\n        }\n        /**\n     * @param {string} text\n     * @param {string} scope\n     */ function emitKeyword(keyword, scope) {\n            if (keyword === \"\") return;\n            emitter.startScope(scope);\n            emitter.addText(keyword);\n            emitter.endScope();\n        }\n        /**\n     * @param {CompiledScope} scope\n     * @param {RegExpMatchArray} match\n     */ function emitMultiClass(scope, match) {\n            let i = 1;\n            const max = match.length - 1;\n            while(i <= max){\n                if (!scope._emit[i]) {\n                    i++;\n                    continue;\n                }\n                const klass = language.classNameAliases[scope[i]] || scope[i];\n                const text = match[i];\n                if (klass) {\n                    emitKeyword(text, klass);\n                } else {\n                    modeBuffer = text;\n                    processKeywords();\n                    modeBuffer = \"\";\n                }\n                i++;\n            }\n        }\n        /**\n     * @param {CompiledMode} mode - new mode to start\n     * @param {RegExpMatchArray} match\n     */ function startNewMode(mode, match) {\n            if (mode.scope && typeof mode.scope === \"string\") {\n                emitter.openNode(language.classNameAliases[mode.scope] || mode.scope);\n            }\n            if (mode.beginScope) {\n                // beginScope just wraps the begin match itself in a scope\n                if (mode.beginScope._wrap) {\n                    emitKeyword(modeBuffer, language.classNameAliases[mode.beginScope._wrap] || mode.beginScope._wrap);\n                    modeBuffer = \"\";\n                } else if (mode.beginScope._multi) {\n                    // at this point modeBuffer should just be the match\n                    emitMultiClass(mode.beginScope, match);\n                    modeBuffer = \"\";\n                }\n            }\n            top = Object.create(mode, {\n                parent: {\n                    value: top\n                }\n            });\n            return top;\n        }\n        /**\n     * @param {CompiledMode } mode - the mode to potentially end\n     * @param {RegExpMatchArray} match - the latest match\n     * @param {string} matchPlusRemainder - match plus remainder of content\n     * @returns {CompiledMode | void} - the next mode, or if void continue on in current mode\n     */ function endOfMode(mode, match, matchPlusRemainder) {\n            let matched = startsWith(mode.endRe, matchPlusRemainder);\n            if (matched) {\n                if (mode[\"on:end\"]) {\n                    const resp = new Response(mode);\n                    mode[\"on:end\"](match, resp);\n                    if (resp.isMatchIgnored) matched = false;\n                }\n                if (matched) {\n                    while(mode.endsParent && mode.parent){\n                        mode = mode.parent;\n                    }\n                    return mode;\n                }\n            }\n            // even if on:end fires an `ignore` it's still possible\n            // that we might trigger the end node because of a parent mode\n            if (mode.endsWithParent) {\n                return endOfMode(mode.parent, match, matchPlusRemainder);\n            }\n        }\n        /**\n     * Handle matching but then ignoring a sequence of text\n     *\n     * @param {string} lexeme - string containing full match text\n     */ function doIgnore(lexeme) {\n            if (top.matcher.regexIndex === 0) {\n                // no more regexes to potentially match here, so we move the cursor forward one\n                // space\n                modeBuffer += lexeme[0];\n                return 1;\n            } else {\n                // no need to move the cursor, we still have additional regexes to try and\n                // match at this very spot\n                resumeScanAtSamePosition = true;\n                return 0;\n            }\n        }\n        /**\n     * Handle the start of a new potential mode match\n     *\n     * @param {EnhancedMatch} match - the current match\n     * @returns {number} how far to advance the parse cursor\n     */ function doBeginMatch(match) {\n            const lexeme = match[0];\n            const newMode = match.rule;\n            const resp = new Response(newMode);\n            // first internal before callbacks, then the public ones\n            const beforeCallbacks = [\n                newMode.__beforeBegin,\n                newMode[\"on:begin\"]\n            ];\n            for (const cb of beforeCallbacks){\n                if (!cb) continue;\n                cb(match, resp);\n                if (resp.isMatchIgnored) return doIgnore(lexeme);\n            }\n            if (newMode.skip) {\n                modeBuffer += lexeme;\n            } else {\n                if (newMode.excludeBegin) {\n                    modeBuffer += lexeme;\n                }\n                processBuffer();\n                if (!newMode.returnBegin && !newMode.excludeBegin) {\n                    modeBuffer = lexeme;\n                }\n            }\n            startNewMode(newMode, match);\n            return newMode.returnBegin ? 0 : lexeme.length;\n        }\n        /**\n     * Handle the potential end of mode\n     *\n     * @param {RegExpMatchArray} match - the current match\n     */ function doEndMatch(match) {\n            const lexeme = match[0];\n            const matchPlusRemainder = codeToHighlight.substring(match.index);\n            const endMode = endOfMode(top, match, matchPlusRemainder);\n            if (!endMode) {\n                return NO_MATCH;\n            }\n            const origin = top;\n            if (top.endScope && top.endScope._wrap) {\n                processBuffer();\n                emitKeyword(lexeme, top.endScope._wrap);\n            } else if (top.endScope && top.endScope._multi) {\n                processBuffer();\n                emitMultiClass(top.endScope, match);\n            } else if (origin.skip) {\n                modeBuffer += lexeme;\n            } else {\n                if (!(origin.returnEnd || origin.excludeEnd)) {\n                    modeBuffer += lexeme;\n                }\n                processBuffer();\n                if (origin.excludeEnd) {\n                    modeBuffer = lexeme;\n                }\n            }\n            do {\n                if (top.scope) {\n                    emitter.closeNode();\n                }\n                if (!top.skip && !top.subLanguage) {\n                    relevance += top.relevance;\n                }\n                top = top.parent;\n            }while (top !== endMode.parent);\n            if (endMode.starts) {\n                startNewMode(endMode.starts, match);\n            }\n            return origin.returnEnd ? 0 : lexeme.length;\n        }\n        function processContinuations() {\n            const list = [];\n            for(let current = top; current !== language; current = current.parent){\n                if (current.scope) {\n                    list.unshift(current.scope);\n                }\n            }\n            list.forEach((item)=>emitter.openNode(item));\n        }\n        /** @type {{type?: MatchType, index?: number, rule?: Mode}}} */ let lastMatch = {};\n        /**\n     *  Process an individual match\n     *\n     * @param {string} textBeforeMatch - text preceding the match (since the last match)\n     * @param {EnhancedMatch} [match] - the match itself\n     */ function processLexeme(textBeforeMatch, match) {\n            const lexeme = match && match[0];\n            // add non-matched text to the current mode buffer\n            modeBuffer += textBeforeMatch;\n            if (lexeme == null) {\n                processBuffer();\n                return 0;\n            }\n            // we've found a 0 width match and we're stuck, so we need to advance\n            // this happens when we have badly behaved rules that have optional matchers to the degree that\n            // sometimes they can end up matching nothing at all\n            // Ref: https://github.com/highlightjs/highlight.js/issues/2140\n            if (lastMatch.type === \"begin\" && match.type === \"end\" && lastMatch.index === match.index && lexeme === \"\") {\n                // spit the \"skipped\" character that our regex choked on back into the output sequence\n                modeBuffer += codeToHighlight.slice(match.index, match.index + 1);\n                if (!SAFE_MODE) {\n                    /** @type {AnnotatedError} */ const err = new Error(`0 width match regex (${languageName})`);\n                    err.languageName = languageName;\n                    err.badRule = lastMatch.rule;\n                    throw err;\n                }\n                return 1;\n            }\n            lastMatch = match;\n            if (match.type === \"begin\") {\n                return doBeginMatch(match);\n            } else if (match.type === \"illegal\" && !ignoreIllegals) {\n                // illegal match, we do not continue processing\n                /** @type {AnnotatedError} */ const err = new Error('Illegal lexeme \"' + lexeme + '\" for mode \"' + (top.scope || \"<unnamed>\") + '\"');\n                err.mode = top;\n                throw err;\n            } else if (match.type === \"end\") {\n                const processed = doEndMatch(match);\n                if (processed !== NO_MATCH) {\n                    return processed;\n                }\n            }\n            // edge case for when illegal matches $ (end of line) which is technically\n            // a 0 width match but not a begin/end match so it's not caught by the\n            // first handler (when ignoreIllegals is true)\n            if (match.type === \"illegal\" && lexeme === \"\") {\n                // advance so we aren't stuck in an infinite loop\n                return 1;\n            }\n            // infinite loops are BAD, this is a last ditch catch all. if we have a\n            // decent number of iterations yet our index (cursor position in our\n            // parsing) still 3x behind our index then something is very wrong\n            // so we bail\n            if (iterations > 100000 && iterations > match.index * 3) {\n                const err = new Error(\"potential infinite loop, way more iterations than matches\");\n                throw err;\n            }\n            /*\n      Why might be find ourselves here?  An potential end match that was\n      triggered but could not be completed.  IE, `doEndMatch` returned NO_MATCH.\n      (this could be because a callback requests the match be ignored, etc)\n\n      This causes no real harm other than stopping a few times too many.\n      */ modeBuffer += lexeme;\n            return lexeme.length;\n        }\n        const language = getLanguage(languageName);\n        if (!language) {\n            error(LANGUAGE_NOT_FOUND.replace(\"{}\", languageName));\n            throw new Error('Unknown language: \"' + languageName + '\"');\n        }\n        const md = compileLanguage(language);\n        let result = \"\";\n        /** @type {CompiledMode} */ let top = continuation || md;\n        /** @type Record<string,CompiledMode> */ const continuations = {}; // keep continuations for sub-languages\n        const emitter = new options.__emitter(options);\n        processContinuations();\n        let modeBuffer = \"\";\n        let relevance = 0;\n        let index = 0;\n        let iterations = 0;\n        let resumeScanAtSamePosition = false;\n        try {\n            if (!language.__emitTokens) {\n                top.matcher.considerAll();\n                for(;;){\n                    iterations++;\n                    if (resumeScanAtSamePosition) {\n                        // only regexes not matched previously will now be\n                        // considered for a potential match\n                        resumeScanAtSamePosition = false;\n                    } else {\n                        top.matcher.considerAll();\n                    }\n                    top.matcher.lastIndex = index;\n                    const match = top.matcher.exec(codeToHighlight);\n                    // console.log(\"match\", match[0], match.rule && match.rule.begin)\n                    if (!match) break;\n                    const beforeMatch = codeToHighlight.substring(index, match.index);\n                    const processedCount = processLexeme(beforeMatch, match);\n                    index = match.index + processedCount;\n                }\n                processLexeme(codeToHighlight.substring(index));\n            } else {\n                language.__emitTokens(codeToHighlight, emitter);\n            }\n            emitter.finalize();\n            result = emitter.toHTML();\n            return {\n                language: languageName,\n                value: result,\n                relevance,\n                illegal: false,\n                _emitter: emitter,\n                _top: top\n            };\n        } catch (err) {\n            if (err.message && err.message.includes(\"Illegal\")) {\n                return {\n                    language: languageName,\n                    value: escape(codeToHighlight),\n                    illegal: true,\n                    relevance: 0,\n                    _illegalBy: {\n                        message: err.message,\n                        index,\n                        context: codeToHighlight.slice(index - 100, index + 100),\n                        mode: err.mode,\n                        resultSoFar: result\n                    },\n                    _emitter: emitter\n                };\n            } else if (SAFE_MODE) {\n                return {\n                    language: languageName,\n                    value: escape(codeToHighlight),\n                    illegal: false,\n                    relevance: 0,\n                    errorRaised: err,\n                    _emitter: emitter,\n                    _top: top\n                };\n            } else {\n                throw err;\n            }\n        }\n    }\n    /**\n   * returns a valid highlight result, without actually doing any actual work,\n   * auto highlight starts with this and it's possible for small snippets that\n   * auto-detection may not find a better match\n   * @param {string} code\n   * @returns {HighlightResult}\n   */ function justTextHighlightResult(code) {\n        const result = {\n            value: escape(code),\n            illegal: false,\n            relevance: 0,\n            _top: PLAINTEXT_LANGUAGE,\n            _emitter: new options.__emitter(options)\n        };\n        result._emitter.addText(code);\n        return result;\n    }\n    /**\n  Highlighting with language detection. Accepts a string with the code to\n  highlight. Returns an object with the following properties:\n\n  - language (detected language)\n  - relevance (int)\n  - value (an HTML string with highlighting markup)\n  - secondBest (object with the same structure for second-best heuristically\n    detected language, may be absent)\n\n    @param {string} code\n    @param {Array<string>} [languageSubset]\n    @returns {AutoHighlightResult}\n  */ function highlightAuto(code, languageSubset) {\n        languageSubset = languageSubset || options.languages || Object.keys(languages);\n        const plaintext = justTextHighlightResult(code);\n        const results = languageSubset.filter(getLanguage).filter(autoDetection).map((name)=>_highlight(name, code, false));\n        results.unshift(plaintext); // plaintext is always an option\n        const sorted = results.sort((a, b)=>{\n            // sort base on relevance\n            if (a.relevance !== b.relevance) return b.relevance - a.relevance;\n            // always award the tie to the base language\n            // ie if C++ and Arduino are tied, it's more likely to be C++\n            if (a.language && b.language) {\n                if (getLanguage(a.language).supersetOf === b.language) {\n                    return 1;\n                } else if (getLanguage(b.language).supersetOf === a.language) {\n                    return -1;\n                }\n            }\n            // otherwise say they are equal, which has the effect of sorting on\n            // relevance while preserving the original ordering - which is how ties\n            // have historically been settled, ie the language that comes first always\n            // wins in the case of a tie\n            return 0;\n        });\n        const [best, secondBest] = sorted;\n        /** @type {AutoHighlightResult} */ const result = best;\n        result.secondBest = secondBest;\n        return result;\n    }\n    /**\n   * Builds new class name for block given the language name\n   *\n   * @param {HTMLElement} element\n   * @param {string} [currentLang]\n   * @param {string} [resultLang]\n   */ function updateClassName(element, currentLang, resultLang) {\n        const language = currentLang && aliases[currentLang] || resultLang;\n        element.classList.add(\"hljs\");\n        element.classList.add(`language-${language}`);\n    }\n    /**\n   * Applies highlighting to a DOM node containing code.\n   *\n   * @param {HighlightedHTMLElement} element - the HTML element to highlight\n  */ function highlightElement(element) {\n        /** @type HTMLElement */ let node = null;\n        const language = blockLanguage(element);\n        if (shouldNotHighlight(language)) return;\n        fire(\"before:highlightElement\", {\n            el: element,\n            language\n        });\n        if (element.dataset.highlighted) {\n            console.log(\"Element previously highlighted. To highlight again, first unset `dataset.highlighted`.\", element);\n            return;\n        }\n        // we should be all text, no child nodes (unescaped HTML) - this is possibly\n        // an HTML injection attack - it's likely too late if this is already in\n        // production (the code has likely already done its damage by the time\n        // we're seeing it)... but we yell loudly about this so that hopefully it's\n        // more likely to be caught in development before making it to production\n        if (element.children.length > 0) {\n            if (!options.ignoreUnescapedHTML) {\n                console.warn(\"One of your code blocks includes unescaped HTML. This is a potentially serious security risk.\");\n                console.warn(\"https://github.com/highlightjs/highlight.js/wiki/security\");\n                console.warn(\"The element with unescaped HTML:\");\n                console.warn(element);\n            }\n            if (options.throwUnescapedHTML) {\n                const err = new HTMLInjectionError(\"One of your code blocks includes unescaped HTML.\", element.innerHTML);\n                throw err;\n            }\n        }\n        node = element;\n        const text = node.textContent;\n        const result = language ? highlight(text, {\n            language,\n            ignoreIllegals: true\n        }) : highlightAuto(text);\n        element.innerHTML = result.value;\n        element.dataset.highlighted = \"yes\";\n        updateClassName(element, language, result.language);\n        element.result = {\n            language: result.language,\n            // TODO: remove with version 11.0\n            re: result.relevance,\n            relevance: result.relevance\n        };\n        if (result.secondBest) {\n            element.secondBest = {\n                language: result.secondBest.language,\n                relevance: result.secondBest.relevance\n            };\n        }\n        fire(\"after:highlightElement\", {\n            el: element,\n            result,\n            text\n        });\n    }\n    /**\n   * Updates highlight.js global options with the passed options\n   *\n   * @param {Partial<HLJSOptions>} userOptions\n   */ function configure(userOptions) {\n        options = inherit(options, userOptions);\n    }\n    // TODO: remove v12, deprecated\n    const initHighlighting = ()=>{\n        highlightAll();\n        deprecated(\"10.6.0\", \"initHighlighting() deprecated.  Use highlightAll() now.\");\n    };\n    // TODO: remove v12, deprecated\n    function initHighlightingOnLoad() {\n        highlightAll();\n        deprecated(\"10.6.0\", \"initHighlightingOnLoad() deprecated.  Use highlightAll() now.\");\n    }\n    let wantsHighlight = false;\n    /**\n   * auto-highlights all pre>code elements on the page\n   */ function highlightAll() {\n        // if we are called too early in the loading process\n        if (document.readyState === \"loading\") {\n            wantsHighlight = true;\n            return;\n        }\n        const blocks = document.querySelectorAll(options.cssSelector);\n        blocks.forEach(highlightElement);\n    }\n    function boot() {\n        // if a highlight was requested before DOM was loaded, do now\n        if (wantsHighlight) highlightAll();\n    }\n    // make sure we are in the browser environment\n    if (false) {}\n    /**\n   * Register a language grammar module\n   *\n   * @param {string} languageName\n   * @param {LanguageFn} languageDefinition\n   */ function registerLanguage(languageName, languageDefinition) {\n        let lang = null;\n        try {\n            lang = languageDefinition(hljs);\n        } catch (error$1) {\n            error(\"Language definition for '{}' could not be registered.\".replace(\"{}\", languageName));\n            // hard or soft error\n            if (!SAFE_MODE) {\n                throw error$1;\n            } else {\n                error(error$1);\n            }\n            // languages that have serious errors are replaced with essentially a\n            // \"plaintext\" stand-in so that the code blocks will still get normal\n            // css classes applied to them - and one bad language won't break the\n            // entire highlighter\n            lang = PLAINTEXT_LANGUAGE;\n        }\n        // give it a temporary name if it doesn't have one in the meta-data\n        if (!lang.name) lang.name = languageName;\n        languages[languageName] = lang;\n        lang.rawDefinition = languageDefinition.bind(null, hljs);\n        if (lang.aliases) {\n            registerAliases(lang.aliases, {\n                languageName\n            });\n        }\n    }\n    /**\n   * Remove a language grammar module\n   *\n   * @param {string} languageName\n   */ function unregisterLanguage(languageName) {\n        delete languages[languageName];\n        for (const alias of Object.keys(aliases)){\n            if (aliases[alias] === languageName) {\n                delete aliases[alias];\n            }\n        }\n    }\n    /**\n   * @returns {string[]} List of language internal names\n   */ function listLanguages() {\n        return Object.keys(languages);\n    }\n    /**\n   * @param {string} name - name of the language to retrieve\n   * @returns {Language | undefined}\n   */ function getLanguage(name) {\n        name = (name || \"\").toLowerCase();\n        return languages[name] || languages[aliases[name]];\n    }\n    /**\n   *\n   * @param {string|string[]} aliasList - single alias or list of aliases\n   * @param {{languageName: string}} opts\n   */ function registerAliases(aliasList, { languageName }) {\n        if (typeof aliasList === \"string\") {\n            aliasList = [\n                aliasList\n            ];\n        }\n        aliasList.forEach((alias)=>{\n            aliases[alias.toLowerCase()] = languageName;\n        });\n    }\n    /**\n   * Determines if a given language has auto-detection enabled\n   * @param {string} name - name of the language\n   */ function autoDetection(name) {\n        const lang = getLanguage(name);\n        return lang && !lang.disableAutodetect;\n    }\n    /**\n   * Upgrades the old highlightBlock plugins to the new\n   * highlightElement API\n   * @param {HLJSPlugin} plugin\n   */ function upgradePluginAPI(plugin) {\n        // TODO: remove with v12\n        if (plugin[\"before:highlightBlock\"] && !plugin[\"before:highlightElement\"]) {\n            plugin[\"before:highlightElement\"] = (data)=>{\n                plugin[\"before:highlightBlock\"](Object.assign({\n                    block: data.el\n                }, data));\n            };\n        }\n        if (plugin[\"after:highlightBlock\"] && !plugin[\"after:highlightElement\"]) {\n            plugin[\"after:highlightElement\"] = (data)=>{\n                plugin[\"after:highlightBlock\"](Object.assign({\n                    block: data.el\n                }, data));\n            };\n        }\n    }\n    /**\n   * @param {HLJSPlugin} plugin\n   */ function addPlugin(plugin) {\n        upgradePluginAPI(plugin);\n        plugins.push(plugin);\n    }\n    /**\n   * @param {HLJSPlugin} plugin\n   */ function removePlugin(plugin) {\n        const index = plugins.indexOf(plugin);\n        if (index !== -1) {\n            plugins.splice(index, 1);\n        }\n    }\n    /**\n   *\n   * @param {PluginEvent} event\n   * @param {any} args\n   */ function fire(event, args) {\n        const cb = event;\n        plugins.forEach(function(plugin) {\n            if (plugin[cb]) {\n                plugin[cb](args);\n            }\n        });\n    }\n    /**\n   * DEPRECATED\n   * @param {HighlightedHTMLElement} el\n   */ function deprecateHighlightBlock(el) {\n        deprecated(\"10.7.0\", \"highlightBlock will be removed entirely in v12.0\");\n        deprecated(\"10.7.0\", \"Please use highlightElement now.\");\n        return highlightElement(el);\n    }\n    /* Interface definition */ Object.assign(hljs, {\n        highlight,\n        highlightAuto,\n        highlightAll,\n        highlightElement,\n        // TODO: Remove with v12 API\n        highlightBlock: deprecateHighlightBlock,\n        configure,\n        initHighlighting,\n        initHighlightingOnLoad,\n        registerLanguage,\n        unregisterLanguage,\n        listLanguages,\n        getLanguage,\n        registerAliases,\n        autoDetection,\n        inherit,\n        addPlugin,\n        removePlugin\n    });\n    hljs.debugMode = function() {\n        SAFE_MODE = false;\n    };\n    hljs.safeMode = function() {\n        SAFE_MODE = true;\n    };\n    hljs.versionString = version;\n    hljs.regex = {\n        concat: concat,\n        lookahead: lookahead,\n        either: either,\n        optional: optional,\n        anyNumberOfTimes: anyNumberOfTimes\n    };\n    for(const key in MODES){\n        // @ts-ignore\n        if (typeof MODES[key] === \"object\") {\n            // @ts-ignore\n            deepFreeze(MODES[key]);\n        }\n    }\n    // merge all the modes/regexes into our main object\n    Object.assign(hljs, MODES);\n    return hljs;\n};\n// Other names for the variable may break build script\nconst highlight = HLJS({});\n// returns a new instance of the highlighter to be used for extensions\n// check https://github.com/wooorm/lowlight/issues/47\nhighlight.newInstance = ()=>HLJS({});\nmodule.exports = highlight;\nhighlight.HighlightJS = highlight;\nhighlight.default = highlight;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2xpYi9jb3JlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGtDQUFrQztBQUVsQyxTQUFTQSxXQUFXQyxHQUFHO0lBQ3JCLElBQUlBLGVBQWVDLEtBQUs7UUFDdEJELElBQUlFLEtBQUssR0FDUEYsSUFBSUcsTUFBTSxHQUNWSCxJQUFJSSxHQUFHLEdBQ0w7WUFDRSxNQUFNLElBQUlDLE1BQU07UUFDbEI7SUFDTixPQUFPLElBQUlMLGVBQWVNLEtBQUs7UUFDN0JOLElBQUlPLEdBQUcsR0FDTFAsSUFBSUUsS0FBSyxHQUNURixJQUFJRyxNQUFNLEdBQ1I7WUFDRSxNQUFNLElBQUlFLE1BQU07UUFDbEI7SUFDTjtJQUVBLGNBQWM7SUFDZEcsT0FBT0MsTUFBTSxDQUFDVDtJQUVkUSxPQUFPRSxtQkFBbUIsQ0FBQ1YsS0FBS1csT0FBTyxDQUFDLENBQUNDO1FBQ3ZDLE1BQU1DLE9BQU9iLEdBQUcsQ0FBQ1ksS0FBSztRQUN0QixNQUFNRSxPQUFPLE9BQU9EO1FBRXBCLHlFQUF5RTtRQUN6RSxJQUFJLENBQUNDLFNBQVMsWUFBWUEsU0FBUyxVQUFTLEtBQU0sQ0FBQ04sT0FBT08sUUFBUSxDQUFDRixPQUFPO1lBQ3hFZCxXQUFXYztRQUNiO0lBQ0Y7SUFFQSxPQUFPYjtBQUNUO0FBRUEsd0VBQXdFLEdBQ3hFLGdFQUFnRSxHQUNoRSxpQ0FBaUMsR0FFakMsTUFBTWdCO0lBQ0o7O0dBRUMsR0FDREMsWUFBWUMsSUFBSSxDQUFFO1FBQ2hCLHdDQUF3QztRQUN4QyxJQUFJQSxLQUFLQyxJQUFJLEtBQUtDLFdBQVdGLEtBQUtDLElBQUksR0FBRyxDQUFDO1FBRTFDLElBQUksQ0FBQ0EsSUFBSSxHQUFHRCxLQUFLQyxJQUFJO1FBQ3JCLElBQUksQ0FBQ0UsY0FBYyxHQUFHO0lBQ3hCO0lBRUFDLGNBQWM7UUFDWixJQUFJLENBQUNELGNBQWMsR0FBRztJQUN4QjtBQUNGO0FBRUE7OztDQUdDLEdBQ0QsU0FBU0UsV0FBV0Ms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QVcsR0FBRzNIO0FBQ3hCQSxVQUFVNEgsT0FBTyxHQUFHNUgiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kZWZyYWdtZW50aW5nLWlkZWFzLy4vbm9kZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9saWIvY29yZS5qcz9kOTU4Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludC1kaXNhYmxlIG5vLW11bHRpLWFzc2lnbiAqL1xuXG5mdW5jdGlvbiBkZWVwRnJlZXplKG9iaikge1xuICBpZiAob2JqIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgb2JqLmNsZWFyID1cbiAgICAgIG9iai5kZWxldGUgPVxuICAgICAgb2JqLnNldCA9XG4gICAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21hcCBpcyByZWFkLW9ubHknKTtcbiAgICAgICAgfTtcbiAgfSBlbHNlIGlmIChvYmogaW5zdGFuY2VvZiBTZXQpIHtcbiAgICBvYmouYWRkID1cbiAgICAgIG9iai5jbGVhciA9XG4gICAgICBvYmouZGVsZXRlID1cbiAgICAgICAgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignc2V0IGlzIHJlYWQtb25seScpO1xuICAgICAgICB9O1xuICB9XG5cbiAgLy8gRnJlZXplIHNlbGZcbiAgT2JqZWN0LmZyZWV6ZShvYmopO1xuXG4gIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgIGNvbnN0IHByb3AgPSBvYmpbbmFtZV07XG4gICAgY29uc3QgdHlwZSA9IHR5cGVvZiBwcm9wO1xuXG4gICAgLy8gRnJlZXplIHByb3AgaWYgaXQgaXMgYW4gb2JqZWN0IG9yIGZ1bmN0aW9uIGFuZCBhbHNvIG5vdCBhbHJlYWR5IGZyb3plblxuICAgIGlmICgodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykgJiYgIU9iamVjdC5pc0Zyb3plbihwcm9wKSkge1xuICAgICAgZGVlcEZyZWV6ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBvYmo7XG59XG5cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5DYWxsYmFja1Jlc3BvbnNlfSBDYWxsYmFja1Jlc3BvbnNlICovXG4vKiogQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRNb2RlfSBDb21waWxlZE1vZGUgKi9cbi8qKiBAaW1wbGVtZW50cyBDYWxsYmFja1Jlc3BvbnNlICovXG5cbmNsYXNzIFJlc3BvbnNlIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihtb2RlKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIGlmIChtb2RlLmRhdGEgPT09IHVuZGVmaW5lZCkgbW9kZS5kYXRhID0ge307XG5cbiAgICB0aGlzLmRhdGEgPSBtb2RlLmRhdGE7XG4gICAgdGhpcy5pc01hdGNoSWdub3JlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWdub3JlTWF0Y2goKSB7XG4gICAgdGhpcy5pc01hdGNoSWdub3JlZCA9IHRydWU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVzY2FwZUhUTUwodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlXG4gICAgLnJlcGxhY2UoLyYvZywgJyZhbXA7JylcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXG4gICAgLnJlcGxhY2UoLz4vZywgJyZndDsnKVxuICAgIC5yZXBsYWNlKC9cIi9nLCAnJnF1b3Q7JylcbiAgICAucmVwbGFjZSgvJy9nLCAnJiN4Mjc7Jyk7XG59XG5cbi8qKlxuICogcGVyZm9ybXMgYSBzaGFsbG93IG1lcmdlIG9mIG11bHRpcGxlIG9iamVjdHMgaW50byBvbmVcbiAqXG4gKiBAdGVtcGxhdGUgVFxuICogQHBhcmFtIHtUfSBvcmlnaW5hbFxuICogQHBhcmFtIHtSZWNvcmQ8c3RyaW5nLGFueT5bXX0gb2JqZWN0c1xuICogQHJldHVybnMge1R9IGEgc2luZ2xlIG5ldyBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5oZXJpdCQxKG9yaWdpbmFsLCAuLi5vYmplY3RzKSB7XG4gIC8qKiBAdHlwZSBSZWNvcmQ8c3RyaW5nLGFueT4gKi9cbiAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvcmlnaW5hbCkge1xuICAgIHJlc3VsdFtrZXldID0gb3JpZ2luYWxba2V5XTtcbiAgfVxuICBvYmplY3RzLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG9ialtrZXldO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiogQHR5cGUge1R9ICovIChyZXN1bHQpO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIHtvYmplY3R9IFJlbmRlcmVyXG4gKiBAcHJvcGVydHkgeyh0ZXh0OiBzdHJpbmcpID0+IHZvaWR9IGFkZFRleHRcbiAqIEBwcm9wZXJ0eSB7KG5vZGU6IE5vZGUpID0+IHZvaWR9IG9wZW5Ob2RlXG4gKiBAcHJvcGVydHkgeyhub2RlOiBOb2RlKSA9PiB2b2lkfSBjbG9zZU5vZGVcbiAqIEBwcm9wZXJ0eSB7KCkgPT4gc3RyaW5nfSB2YWx1ZVxuICovXG5cbi8qKiBAdHlwZWRlZiB7e3Njb3BlPzogc3RyaW5nLCBsYW5ndWFnZT86IHN0cmluZywgc3VibGFuZ3VhZ2U/OiBib29sZWFufX0gTm9kZSAqL1xuLyoqIEB0eXBlZGVmIHt7d2FsazogKHI6IFJlbmRlcmVyKSA9PiB2b2lkfX0gVHJlZSAqL1xuLyoqICovXG5cbmNvbnN0IFNQQU5fQ0xPU0UgPSAnPC9zcGFuPic7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIG5vZGUgbmVlZHMgdG8gYmUgd3JhcHBlZCBpbiA8c3Bhbj5cbiAqXG4gKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbmNvbnN0IGVtaXRzV3JhcHBpbmdUYWdzID0gKG5vZGUpID0+IHtcbiAgLy8gcmFyZWx5IHdlIGNhbiBoYXZlIGEgc3VibGFuZ3VhZ2Ugd2hlcmUgbGFuZ3VhZ2UgaXMgdW5kZWZpbmVkXG4gIC8vIFRPRE86IHRyYWNrIGRvd24gd2h5XG4gIHJldHVybiAhIW5vZGUuc2NvcGU7XG59O1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHt7cHJlZml4OnN0cmluZ319IG9wdGlvbnNcbiAqL1xuY29uc3Qgc2NvcGVUb0NTU0NsYXNzID0gKG5hbWUsIHsgcHJlZml4IH0pID0+IHtcbiAgLy8gc3ViLWxhbmd1YWdlXG4gIGlmIChuYW1lLnN0YXJ0c1dpdGgoXCJsYW5ndWFnZTpcIikpIHtcbiAgICByZXR1cm4gbmFtZS5yZXBsYWNlKFwibGFuZ3VhZ2U6XCIsIFwibGFuZ3VhZ2UtXCIpO1xuICB9XG4gIC8vIHRpZXJlZCBzY29wZTogY29tbWVudC5saW5lXG4gIGlmIChuYW1lLmluY2x1ZGVzKFwiLlwiKSkge1xuICAgIGNvbnN0IHBpZWNlcyA9IG5hbWUuc3BsaXQoXCIuXCIpO1xuICAgIHJldHVybiBbXG4gICAgICBgJHtwcmVmaXh9JHtwaWVjZXMuc2hpZnQoKX1gLFxuICAgICAgLi4uKHBpZWNlcy5tYXAoKHgsIGkpID0+IGAke3h9JHtcIl9cIi5yZXBlYXQoaSArIDEpfWApKVxuICAgIF0uam9pbihcIiBcIik7XG4gIH1cbiAgLy8gc2ltcGxlIHNjb3BlXG4gIHJldHVybiBgJHtwcmVmaXh9JHtuYW1lfWA7XG59O1xuXG4vKiogQHR5cGUge1JlbmRlcmVyfSAqL1xuY2xhc3MgSFRNTFJlbmRlcmVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgSFRNTFJlbmRlcmVyXG4gICAqXG4gICAqIEBwYXJhbSB7VHJlZX0gcGFyc2VUcmVlIC0gdGhlIHBhcnNlIHRyZWUgKG11c3Qgc3VwcG9ydCBgd2Fsa2AgQVBJKVxuICAgKiBAcGFyYW0ge3tjbGFzc1ByZWZpeDogc3RyaW5nfX0gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IocGFyc2VUcmVlLCBvcHRpb25zKSB7XG4gICAgdGhpcy5idWZmZXIgPSBcIlwiO1xuICAgIHRoaXMuY2xhc3NQcmVmaXggPSBvcHRpb25zLmNsYXNzUHJlZml4O1xuICAgIHBhcnNlVHJlZS53YWxrKHRoaXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgdGV4dHMgdG8gdGhlIG91dHB1dCBzdHJlYW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgKi9cbiAgYWRkVGV4dCh0ZXh0KSB7XG4gICAgdGhpcy5idWZmZXIgKz0gZXNjYXBlSFRNTCh0ZXh0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbm9kZSBvcGVuIHRvIHRoZSBvdXRwdXQgc3RyZWFtIChpZiBuZWVkZWQpXG4gICAqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBvcGVuTm9kZShub2RlKSB7XG4gICAgaWYgKCFlbWl0c1dyYXBwaW5nVGFncyhub2RlKSkgcmV0dXJuO1xuXG4gICAgY29uc3QgY2xhc3NOYW1lID0gc2NvcGVUb0NTU0NsYXNzKG5vZGUuc2NvcGUsXG4gICAgICB7IHByZWZpeDogdGhpcy5jbGFzc1ByZWZpeCB9KTtcbiAgICB0aGlzLnNwYW4oY2xhc3NOYW1lKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgbm9kZSBjbG9zZSB0byB0aGUgb3V0cHV0IHN0cmVhbSAoaWYgbmVlZGVkKVxuICAgKlxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGUgKi9cbiAgY2xvc2VOb2RlKG5vZGUpIHtcbiAgICBpZiAoIWVtaXRzV3JhcHBpbmdUYWdzKG5vZGUpKSByZXR1cm47XG5cbiAgICB0aGlzLmJ1ZmZlciArPSBTUEFOX0NMT1NFO1xuICB9XG5cbiAgLyoqXG4gICAqIHJldHVybnMgdGhlIGFjY3VtdWxhdGVkIGJ1ZmZlclxuICAqL1xuICB2YWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5idWZmZXI7XG4gIH1cblxuICAvLyBoZWxwZXJzXG5cbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHNwYW4gZWxlbWVudFxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIHNwYW4oY2xhc3NOYW1lKSB7XG4gICAgdGhpcy5idWZmZXIgKz0gYDxzcGFuIGNsYXNzPVwiJHtjbGFzc05hbWV9XCI+YDtcbiAgfVxufVxuXG4vKiogQHR5cGVkZWYge3tzY29wZT86IHN0cmluZywgbGFuZ3VhZ2U/OiBzdHJpbmcsIGNoaWxkcmVuOiBOb2RlW119IHwgc3RyaW5nfSBOb2RlICovXG4vKiogQHR5cGVkZWYge3tzY29wZT86IHN0cmluZywgbGFuZ3VhZ2U/OiBzdHJpbmcsIGNoaWxkcmVuOiBOb2RlW119IH0gRGF0YU5vZGUgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5FbWl0dGVyfSBFbWl0dGVyICovXG4vKiogICovXG5cbi8qKiBAcmV0dXJucyB7RGF0YU5vZGV9ICovXG5jb25zdCBuZXdOb2RlID0gKG9wdHMgPSB7fSkgPT4ge1xuICAvKiogQHR5cGUgRGF0YU5vZGUgKi9cbiAgY29uc3QgcmVzdWx0ID0geyBjaGlsZHJlbjogW10gfTtcbiAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIG9wdHMpO1xuICByZXR1cm4gcmVzdWx0O1xufTtcblxuY2xhc3MgVG9rZW5UcmVlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgLyoqIEB0eXBlIERhdGFOb2RlICovXG4gICAgdGhpcy5yb290Tm9kZSA9IG5ld05vZGUoKTtcbiAgICB0aGlzLnN0YWNrID0gW3RoaXMucm9vdE5vZGVdO1xuICB9XG5cbiAgZ2V0IHRvcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGFja1t0aGlzLnN0YWNrLmxlbmd0aCAtIDFdO1xuICB9XG5cbiAgZ2V0IHJvb3QoKSB7IHJldHVybiB0aGlzLnJvb3ROb2RlOyB9XG5cbiAgLyoqIEBwYXJhbSB7Tm9kZX0gbm9kZSAqL1xuICBhZGQobm9kZSkge1xuICAgIHRoaXMudG9wLmNoaWxkcmVuLnB1c2gobm9kZSk7XG4gIH1cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IHNjb3BlICovXG4gIG9wZW5Ob2RlKHNjb3BlKSB7XG4gICAgLyoqIEB0eXBlIE5vZGUgKi9cbiAgICBjb25zdCBub2RlID0gbmV3Tm9kZSh7IHNjb3BlIH0pO1xuICAgIHRoaXMuYWRkKG5vZGUpO1xuICAgIHRoaXMuc3RhY2sucHVzaChub2RlKTtcbiAgfVxuXG4gIGNsb3NlTm9kZSgpIHtcbiAgICBpZiAodGhpcy5zdGFjay5sZW5ndGggPiAxKSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGFjay5wb3AoKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cblxuICBjbG9zZUFsbE5vZGVzKCkge1xuICAgIHdoaWxlICh0aGlzLmNsb3NlTm9kZSgpKTtcbiAgfVxuXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5yb290Tm9kZSwgbnVsbCwgNCk7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGVkZWYgeyBpbXBvcnQoXCIuL2h0bWxfcmVuZGVyZXJcIikuUmVuZGVyZXIgfSBSZW5kZXJlclxuICAgKiBAcGFyYW0ge1JlbmRlcmVyfSBidWlsZGVyXG4gICAqL1xuICB3YWxrKGJ1aWxkZXIpIHtcbiAgICAvLyB0aGlzIGRvZXMgbm90XG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuX3dhbGsoYnVpbGRlciwgdGhpcy5yb290Tm9kZSk7XG4gICAgLy8gdGhpcyB3b3Jrc1xuICAgIC8vIHJldHVybiBUb2tlblRyZWUuX3dhbGsoYnVpbGRlciwgdGhpcy5yb290Tm9kZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZW5kZXJlcn0gYnVpbGRlclxuICAgKiBAcGFyYW0ge05vZGV9IG5vZGVcbiAgICovXG4gIHN0YXRpYyBfd2FsayhidWlsZGVyLCBub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBidWlsZGVyLmFkZFRleHQobm9kZSk7XG4gICAgfSBlbHNlIGlmIChub2RlLmNoaWxkcmVuKSB7XG4gICAgICBidWlsZGVyLm9wZW5Ob2RlKG5vZGUpO1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4gdGhpcy5fd2FsayhidWlsZGVyLCBjaGlsZCkpO1xuICAgICAgYnVpbGRlci5jbG9zZU5vZGUobm9kZSk7XG4gICAgfVxuICAgIHJldHVybiBidWlsZGVyO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7Tm9kZX0gbm9kZVxuICAgKi9cbiAgc3RhdGljIF9jb2xsYXBzZShub2RlKSB7XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSBcInN0cmluZ1wiKSByZXR1cm47XG4gICAgaWYgKCFub2RlLmNoaWxkcmVuKSByZXR1cm47XG5cbiAgICBpZiAobm9kZS5jaGlsZHJlbi5ldmVyeShlbCA9PiB0eXBlb2YgZWwgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAvLyBub2RlLnRleHQgPSBub2RlLmNoaWxkcmVuLmpvaW4oXCJcIik7XG4gICAgICAvLyBkZWxldGUgbm9kZS5jaGlsZHJlbjtcbiAgICAgIG5vZGUuY2hpbGRyZW4gPSBbbm9kZS5jaGlsZHJlbi5qb2luKFwiXCIpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbm9kZS5jaGlsZHJlbi5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICBUb2tlblRyZWUuX2NvbGxhcHNlKGNoaWxkKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAgQ3VycmVudGx5IHRoaXMgaXMgYWxsIHByaXZhdGUgQVBJLCBidXQgdGhpcyBpcyB0aGUgbWluaW1hbCBBUEkgbmVjZXNzYXJ5XG4gIHRoYXQgYW4gRW1pdHRlciBtdXN0IGltcGxlbWVudCB0byBmdWxseSBzdXBwb3J0IHRoZSBwYXJzZXIuXG5cbiAgTWluaW1hbCBpbnRlcmZhY2U6XG5cbiAgLSBhZGRUZXh0KHRleHQpXG4gIC0gX19hZGRTdWJsYW5ndWFnZShlbWl0dGVyLCBzdWJMYW5ndWFnZU5hbWUpXG4gIC0gc3RhcnRTY29wZShzY29wZSlcbiAgLSBlbmRTY29wZSgpXG4gIC0gZmluYWxpemUoKVxuICAtIHRvSFRNTCgpXG5cbiovXG5cbi8qKlxuICogQGltcGxlbWVudHMge0VtaXR0ZXJ9XG4gKi9cbmNsYXNzIFRva2VuVHJlZUVtaXR0ZXIgZXh0ZW5kcyBUb2tlblRyZWUge1xuICAvKipcbiAgICogQHBhcmFtIHsqfSBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAqL1xuICBhZGRUZXh0KHRleHQpIHtcbiAgICBpZiAodGV4dCA9PT0gXCJcIikgeyByZXR1cm47IH1cblxuICAgIHRoaXMuYWRkKHRleHQpO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzY29wZSAqL1xuICBzdGFydFNjb3BlKHNjb3BlKSB7XG4gICAgdGhpcy5vcGVuTm9kZShzY29wZSk7XG4gIH1cblxuICBlbmRTY29wZSgpIHtcbiAgICB0aGlzLmNsb3NlTm9kZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7RW1pdHRlciAmIHtyb290OiBEYXRhTm9kZX19IGVtaXR0ZXJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICovXG4gIF9fYWRkU3VibGFuZ3VhZ2UoZW1pdHRlciwgbmFtZSkge1xuICAgIC8qKiBAdHlwZSBEYXRhTm9kZSAqL1xuICAgIGNvbnN0IG5vZGUgPSBlbWl0dGVyLnJvb3Q7XG4gICAgaWYgKG5hbWUpIG5vZGUuc2NvcGUgPSBgbGFuZ3VhZ2U6JHtuYW1lfWA7XG5cbiAgICB0aGlzLmFkZChub2RlKTtcbiAgfVxuXG4gIHRvSFRNTCgpIHtcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBIVE1MUmVuZGVyZXIodGhpcywgdGhpcy5vcHRpb25zKTtcbiAgICByZXR1cm4gcmVuZGVyZXIudmFsdWUoKTtcbiAgfVxuXG4gIGZpbmFsaXplKCkge1xuICAgIHRoaXMuY2xvc2VBbGxOb2RlcygpO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7UmVnRXhwfVxuICogKi9cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBzb3VyY2UocmUpIHtcbiAgaWYgKCFyZSkgcmV0dXJuIG51bGw7XG4gIGlmICh0eXBlb2YgcmUgPT09IFwic3RyaW5nXCIpIHJldHVybiByZTtcblxuICByZXR1cm4gcmUuc291cmNlO1xufVxuXG4vKipcbiAqIEBwYXJhbSB7UmVnRXhwIHwgc3RyaW5nIH0gcmVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGxvb2thaGVhZChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoPz0nLCByZSwgJyknKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBhbnlOdW1iZXJPZlRpbWVzKHJlKSB7XG4gIHJldHVybiBjb25jYXQoJyg/OicsIHJlLCAnKSonKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZyB9IHJlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBvcHRpb25hbChyZSkge1xuICByZXR1cm4gY29uY2F0KCcoPzonLCByZSwgJyk/Jyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHsuLi4oUmVnRXhwIHwgc3RyaW5nKSB9IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdCguLi5hcmdzKSB7XG4gIGNvbnN0IGpvaW5lZCA9IGFyZ3MubWFwKCh4KSA9PiBzb3VyY2UoeCkpLmpvaW4oXCJcIik7XG4gIHJldHVybiBqb2luZWQ7XG59XG5cbi8qKlxuICogQHBhcmFtIHsgQXJyYXk8c3RyaW5nIHwgUmVnRXhwIHwgT2JqZWN0PiB9IGFyZ3NcbiAqIEByZXR1cm5zIHtvYmplY3R9XG4gKi9cbmZ1bmN0aW9uIHN0cmlwT3B0aW9uc0Zyb21BcmdzKGFyZ3MpIHtcbiAgY29uc3Qgb3B0cyA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcblxuICBpZiAodHlwZW9mIG9wdHMgPT09ICdvYmplY3QnICYmIG9wdHMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgIGFyZ3Muc3BsaWNlKGFyZ3MubGVuZ3RoIC0gMSwgMSk7XG4gICAgcmV0dXJuIG9wdHM7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG59XG5cbi8qKiBAdHlwZWRlZiB7IHtjYXB0dXJlPzogYm9vbGVhbn0gfSBSZWdleEVpdGhlck9wdGlvbnMgKi9cblxuLyoqXG4gKiBBbnkgb2YgdGhlIHBhc3NlZCBleHByZXNzc2lvbnMgbWF5IG1hdGNoXG4gKlxuICogQ3JlYXRlcyBhIGh1Z2UgdGhpcyB8IHRoaXMgfCB0aGF0IHwgdGhhdCBtYXRjaFxuICogQHBhcmFtIHsoUmVnRXhwIHwgc3RyaW5nKVtdIHwgWy4uLihSZWdFeHAgfCBzdHJpbmcpW10sIFJlZ2V4RWl0aGVyT3B0aW9uc119IGFyZ3NcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGVpdGhlciguLi5hcmdzKSB7XG4gIC8qKiBAdHlwZSB7IG9iamVjdCAmIHtjYXB0dXJlPzogYm9vbGVhbn0gfSAgKi9cbiAgY29uc3Qgb3B0cyA9IHN0cmlwT3B0aW9uc0Zyb21BcmdzKGFyZ3MpO1xuICBjb25zdCBqb2luZWQgPSAnKCdcbiAgICArIChvcHRzLmNhcHR1cmUgPyBcIlwiIDogXCI/OlwiKVxuICAgICsgYXJncy5tYXAoKHgpID0+IHNvdXJjZSh4KSkuam9pbihcInxcIikgKyBcIilcIjtcbiAgcmV0dXJuIGpvaW5lZDtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge1JlZ0V4cCB8IHN0cmluZ30gcmVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIGNvdW50TWF0Y2hHcm91cHMocmUpIHtcbiAgcmV0dXJuIChuZXcgUmVnRXhwKHJlLnRvU3RyaW5nKCkgKyAnfCcpKS5leGVjKCcnKS5sZW5ndGggLSAxO1xufVxuXG4vKipcbiAqIERvZXMgbGV4ZW1lIHN0YXJ0IHdpdGggYSByZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2ggYXQgdGhlIGJlZ2lubmluZ1xuICogQHBhcmFtIHtSZWdFeHB9IHJlXG4gKiBAcGFyYW0ge3N0cmluZ30gbGV4ZW1lXG4gKi9cbmZ1bmN0aW9uIHN0YXJ0c1dpdGgocmUsIGxleGVtZSkge1xuICBjb25zdCBtYXRjaCA9IHJlICYmIHJlLmV4ZWMobGV4ZW1lKTtcbiAgcmV0dXJuIG1hdGNoICYmIG1hdGNoLmluZGV4ID09PSAwO1xufVxuXG4vLyBCQUNLUkVGX1JFIG1hdGNoZXMgYW4gb3BlbiBwYXJlbnRoZXNpcyBvciBiYWNrcmVmZXJlbmNlLiBUbyBhdm9pZFxuLy8gYW4gaW5jb3JyZWN0IHBhcnNlLCBpdCBhZGRpdGlvbmFsbHkgbWF0Y2hlcyB0aGUgZm9sbG93aW5nOlxuLy8gLSBbLi4uXSBlbGVtZW50cywgd2hlcmUgdGhlIG1lYW5pbmcgb2YgcGFyZW50aGVzZXMgYW5kIGVzY2FwZXMgY2hhbmdlXG4vLyAtIG90aGVyIGVzY2FwZSBzZXF1ZW5jZXMsIHNvIHdlIGRvIG5vdCBtaXNwYXJzZSBlc2NhcGUgc2VxdWVuY2VzIGFzXG4vLyAgIGludGVyZXN0aW5nIGVsZW1lbnRzXG4vLyAtIG5vbi1tYXRjaGluZyBvciBsb29rYWhlYWQgcGFyZW50aGVzZXMsIHdoaWNoIGRvIG5vdCBjYXB0dXJlLiBUaGVzZVxuLy8gICBmb2xsb3cgdGhlICcoJyB3aXRoIGEgJz8nLlxuY29uc3QgQkFDS1JFRl9SRSA9IC9cXFsoPzpbXlxcXFxcXF1dfFxcXFwuKSpcXF18XFwoXFw/P3xcXFxcKFsxLTldWzAtOV0qKXxcXFxcLi87XG5cbi8vICoqSU5URVJOQUwqKiBOb3QgaW50ZW5kZWQgZm9yIG91dHNpZGUgdXNhZ2Vcbi8vIGpvaW4gbG9naWNhbGx5IGNvbXB1dGVzIHJlZ2V4cHMuam9pbihzZXBhcmF0b3IpLCBidXQgZml4ZXMgdGhlXG4vLyBiYWNrcmVmZXJlbmNlcyBzbyB0aGV5IGNvbnRpbnVlIHRvIG1hdGNoLlxuLy8gaXQgYWxzbyBwbGFjZXMgZWFjaCBpbmRpdmlkdWFsIHJlZ3VsYXIgZXhwcmVzc2lvbiBpbnRvIGl0J3Mgb3duXG4vLyBtYXRjaCBncm91cCwga2VlcGluZyB0cmFjayBvZiB0aGUgc2VxdWVuY2luZyBvZiB0aG9zZSBtYXRjaCBncm91cHNcbi8vIGlzIGN1cnJlbnRseSBhbiBleGVyY2lzZSBmb3IgdGhlIGNhbGxlci4gOi0pXG4vKipcbiAqIEBwYXJhbSB7KHN0cmluZyB8IFJlZ0V4cClbXX0gcmVnZXhwc1xuICogQHBhcmFtIHt7am9pbldpdGg6IHN0cmluZ319IG9wdHNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIF9yZXdyaXRlQmFja3JlZmVyZW5jZXMocmVnZXhwcywgeyBqb2luV2l0aCB9KSB7XG4gIGxldCBudW1DYXB0dXJlcyA9IDA7XG5cbiAgcmV0dXJuIHJlZ2V4cHMubWFwKChyZWdleCkgPT4ge1xuICAgIG51bUNhcHR1cmVzICs9IDE7XG4gICAgY29uc3Qgb2Zmc2V0ID0gbnVtQ2FwdHVyZXM7XG4gICAgbGV0IHJlID0gc291cmNlKHJlZ2V4KTtcbiAgICBsZXQgb3V0ID0gJyc7XG5cbiAgICB3aGlsZSAocmUubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgbWF0Y2ggPSBCQUNLUkVGX1JFLmV4ZWMocmUpO1xuICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICBvdXQgKz0gcmU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3V0ICs9IHJlLnN1YnN0cmluZygwLCBtYXRjaC5pbmRleCk7XG4gICAgICByZSA9IHJlLnN1YnN0cmluZyhtYXRjaC5pbmRleCArIG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICBpZiAobWF0Y2hbMF1bMF0gPT09ICdcXFxcJyAmJiBtYXRjaFsxXSkge1xuICAgICAgICAvLyBBZGp1c3QgdGhlIGJhY2tyZWZlcmVuY2UuXG4gICAgICAgIG91dCArPSAnXFxcXCcgKyBTdHJpbmcoTnVtYmVyKG1hdGNoWzFdKSArIG9mZnNldCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXQgKz0gbWF0Y2hbMF07XG4gICAgICAgIGlmIChtYXRjaFswXSA9PT0gJygnKSB7XG4gICAgICAgICAgbnVtQ2FwdHVyZXMrKztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KS5tYXAocmUgPT4gYCgke3JlfSlgKS5qb2luKGpvaW5XaXRoKTtcbn1cblxuLyoqIEB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLk1vZGV9IE1vZGUgKi9cbi8qKiBAdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5Nb2RlQ2FsbGJhY2t9IE1vZGVDYWxsYmFjayAqL1xuXG4vLyBDb21tb24gcmVnZXhwc1xuY29uc3QgTUFUQ0hfTk9USElOR19SRSA9IC9cXGJcXEIvO1xuY29uc3QgSURFTlRfUkUgPSAnW2EtekEtWl1cXFxcdyonO1xuY29uc3QgVU5ERVJTQ09SRV9JREVOVF9SRSA9ICdbYS16QS1aX11cXFxcdyonO1xuY29uc3QgTlVNQkVSX1JFID0gJ1xcXFxiXFxcXGQrKFxcXFwuXFxcXGQrKT8nO1xuY29uc3QgQ19OVU1CRVJfUkUgPSAnKC0/KShcXFxcYjBbeFhdW2EtZkEtRjAtOV0rfChcXFxcYlxcXFxkKyhcXFxcLlxcXFxkKik/fFxcXFwuXFxcXGQrKShbZUVdWy0rXT9cXFxcZCspPyknOyAvLyAweC4uLiwgMC4uLiwgZGVjaW1hbCwgZmxvYXRcbmNvbnN0IEJJTkFSWV9OVU1CRVJfUkUgPSAnXFxcXGIoMGJbMDFdKyknOyAvLyAwYi4uLlxuY29uc3QgUkVfU1RBUlRFUlNfUkUgPSAnIXwhPXwhPT18JXwlPXwmfCYmfCY9fFxcXFwqfFxcXFwqPXxcXFxcK3xcXFxcKz18LHwtfC09fC89fC98Onw7fDw8fDw8PXw8PXw8fD09PXw9PXw9fD4+Pj18Pj49fD49fD4+Pnw+Pnw+fFxcXFw/fFxcXFxbfFxcXFx7fFxcXFwofFxcXFxefFxcXFxePXxcXFxcfHxcXFxcfD18XFxcXHxcXFxcfHx+JztcblxuLyoqXG4qIEBwYXJhbSB7IFBhcnRpYWw8TW9kZT4gJiB7YmluYXJ5Pzogc3RyaW5nIHwgUmVnRXhwfSB9IG9wdHNcbiovXG5jb25zdCBTSEVCQU5HID0gKG9wdHMgPSB7fSkgPT4ge1xuICBjb25zdCBiZWdpblNoZWJhbmcgPSAvXiMhWyBdKlxcLy87XG4gIGlmIChvcHRzLmJpbmFyeSkge1xuICAgIG9wdHMuYmVnaW4gPSBjb25jYXQoXG4gICAgICBiZWdpblNoZWJhbmcsXG4gICAgICAvLipcXGIvLFxuICAgICAgb3B0cy5iaW5hcnksXG4gICAgICAvXFxiLiovKTtcbiAgfVxuICByZXR1cm4gaW5oZXJpdCQxKHtcbiAgICBzY29wZTogJ21ldGEnLFxuICAgIGJlZ2luOiBiZWdpblNoZWJhbmcsXG4gICAgZW5kOiAvJC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgIFwib246YmVnaW5cIjogKG0sIHJlc3ApID0+IHtcbiAgICAgIGlmIChtLmluZGV4ICE9PSAwKSByZXNwLmlnbm9yZU1hdGNoKCk7XG4gICAgfVxuICB9LCBvcHRzKTtcbn07XG5cbi8vIENvbW1vbiBtb2Rlc1xuY29uc3QgQkFDS1NMQVNIX0VTQ0FQRSA9IHtcbiAgYmVnaW46ICdcXFxcXFxcXFtcXFxcc1xcXFxTXScsIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IEFQT1NfU1RSSU5HX01PREUgPSB7XG4gIHNjb3BlOiAnc3RyaW5nJyxcbiAgYmVnaW46ICdcXCcnLFxuICBlbmQ6ICdcXCcnLFxuICBpbGxlZ2FsOiAnXFxcXG4nLFxuICBjb250YWluczogW0JBQ0tTTEFTSF9FU0NBUEVdXG59O1xuY29uc3QgUVVPVEVfU1RSSU5HX01PREUgPSB7XG4gIHNjb3BlOiAnc3RyaW5nJyxcbiAgYmVnaW46ICdcIicsXG4gIGVuZDogJ1wiJyxcbiAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgY29udGFpbnM6IFtCQUNLU0xBU0hfRVNDQVBFXVxufTtcbmNvbnN0IFBIUkFTQUxfV09SRFNfTU9ERSA9IHtcbiAgYmVnaW46IC9cXGIoYXxhbnx0aGV8YXJlfEknbXxpc24ndHxkb24ndHxkb2Vzbid0fHdvbid0fGJ1dHxqdXN0fHNob3VsZHxwcmV0dHl8c2ltcGx5fGVub3VnaHxnb25uYXxnb2luZ3x3dGZ8c298c3VjaHx3aWxsfHlvdXx5b3VyfHRoZXl8bGlrZXxtb3JlKVxcYi9cbn07XG4vKipcbiAqIENyZWF0ZXMgYSBjb21tZW50IG1vZGVcbiAqXG4gKiBAcGFyYW0ge3N0cmluZyB8IFJlZ0V4cH0gYmVnaW5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVnRXhwfSBlbmRcbiAqIEBwYXJhbSB7TW9kZSB8IHt9fSBbbW9kZU9wdGlvbnNdXG4gKiBAcmV0dXJucyB7UGFydGlhbDxNb2RlPn1cbiAqL1xuY29uc3QgQ09NTUVOVCA9IGZ1bmN0aW9uKGJlZ2luLCBlbmQsIG1vZGVPcHRpb25zID0ge30pIHtcbiAgY29uc3QgbW9kZSA9IGluaGVyaXQkMShcbiAgICB7XG4gICAgICBzY29wZTogJ2NvbW1lbnQnLFxuICAgICAgYmVnaW4sXG4gICAgICBlbmQsXG4gICAgICBjb250YWluczogW11cbiAgICB9LFxuICAgIG1vZGVPcHRpb25zXG4gICk7XG4gIG1vZGUuY29udGFpbnMucHVzaCh7XG4gICAgc2NvcGU6ICdkb2N0YWcnLFxuICAgIC8vIGhhY2sgdG8gYXZvaWQgdGhlIHNwYWNlIGZyb20gYmVpbmcgaW5jbHVkZWQuIHRoZSBzcGFjZSBpcyBuZWNlc3NhcnkgdG9cbiAgICAvLyBtYXRjaCBoZXJlIHRvIHByZXZlbnQgdGhlIHBsYWluIHRleHQgcnVsZSBiZWxvdyBmcm9tIGdvYmJsaW5nIHVwIGRvY3RhZ3NcbiAgICBiZWdpbjogJ1sgXSooPz0oVE9ET3xGSVhNRXxOT1RFfEJVR3xPUFRJTUlaRXxIQUNLfFhYWCk6KScsXG4gICAgZW5kOiAvKFRPRE98RklYTUV8Tk9URXxCVUd8T1BUSU1JWkV8SEFDS3xYWFgpOi8sXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIHJlbGV2YW5jZTogMFxuICB9KTtcbiAgY29uc3QgRU5HTElTSF9XT1JEID0gZWl0aGVyKFxuICAgIC8vIGxpc3Qgb2YgY29tbW9uIDEgYW5kIDIgbGV0dGVyIHdvcmRzIGluIEVuZ2xpc2hcbiAgICBcIklcIixcbiAgICBcImFcIixcbiAgICBcImlzXCIsXG4gICAgXCJzb1wiLFxuICAgIFwidXNcIixcbiAgICBcInRvXCIsXG4gICAgXCJhdFwiLFxuICAgIFwiaWZcIixcbiAgICBcImluXCIsXG4gICAgXCJpdFwiLFxuICAgIFwib25cIixcbiAgICAvLyBub3RlOiB0aGlzIGlzIG5vdCBhbiBleGhhdXN0aXZlIGxpc3Qgb2YgY29udHJhY3Rpb25zLCBqdXN0IHBvcHVsYXIgb25lc1xuICAgIC9bQS1aYS16XStbJ10oZHx2ZXxyZXxsbHx0fHN8bikvLCAvLyBjb250cmFjdGlvbnMgLSBjYW4ndCB3ZSdkIHRoZXkncmUgbGV0J3MsIGV0Y1xuICAgIC9bQS1aYS16XStbLV1bYS16XSsvLCAvLyBgbm8td2F5YCwgZXRjLlxuICAgIC9bQS1aYS16XVthLXpdezIsfS8gLy8gYWxsb3cgY2FwaXRhbGl6ZWQgd29yZHMgYXQgYmVnaW5uaW5nIG9mIHNlbnRlbmNlc1xuICApO1xuICAvLyBsb29raW5nIGxpa2UgcGxhaW4gdGV4dCwgbW9yZSBsaWtlbHkgdG8gYmUgYSBjb21tZW50XG4gIG1vZGUuY29udGFpbnMucHVzaChcbiAgICB7XG4gICAgICAvLyBUT0RPOiBob3cgdG8gaW5jbHVkZSBcIiwgKCwgKSB3aXRob3V0IGJyZWFraW5nIGdyYW1tYXJzIHRoYXQgdXNlIHRoZXNlIGZvclxuICAgICAgLy8gY29tbWVudCBkZWxpbWl0ZXJzP1xuICAgICAgLy8gYmVnaW46IC9bIF0rKFsoKVwiXT8oW0EtWmEteictXXszLH18aXN8YXxJfHNvfHVzfFt0VF1bb09dfGF0fGlmfGlufGl0fG9uKVsuXT9bKClcIjpdPyhbLl1bIF18WyBdfFxcKSkpezN9L1xuICAgICAgLy8gLS0tXG5cbiAgICAgIC8vIHRoaXMgdHJpZXMgdG8gZmluZCBzZXF1ZW5jZXMgb2YgMyBlbmdsaXNoIHdvcmRzIGluIGEgcm93ICh3aXRob3V0IGFueVxuICAgICAgLy8gXCJwcm9ncmFtbWluZ1wiIHR5cGUgc3ludGF4KSB0aGlzIGdpdmVzIHVzIGEgc3Ryb25nIHNpZ25hbCB0aGF0IHdlJ3ZlXG4gICAgICAvLyBUUlVMWSBmb3VuZCBhIGNvbW1lbnQgLSB2cyBwZXJoYXBzIHNjYW5uaW5nIHdpdGggdGhlIHdyb25nIGxhbmd1YWdlLlxuICAgICAgLy8gSXQncyBwb3NzaWJsZSB0byBmaW5kIHNvbWV0aGluZyB0aGF0IExPT0tTIGxpa2UgdGhlIHN0YXJ0IG9mIHRoZVxuICAgICAgLy8gY29tbWVudCAtIGJ1dCB0aGVuIGlmIHRoZXJlIGlzIG5vIHJlYWRhYmxlIHRleHQgLSBnb29kIGNoYW5jZSBpdCBpcyBhXG4gICAgICAvLyBmYWxzZSBtYXRjaCBhbmQgbm90IGEgY29tbWVudC5cbiAgICAgIC8vXG4gICAgICAvLyBmb3IgYSB2aXN1YWwgZXhhbXBsZSBwbGVhc2Ugc2VlOlxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMjgyN1xuXG4gICAgICBiZWdpbjogY29uY2F0KFxuICAgICAgICAvWyBdKy8sIC8vIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHVzIGdvYmJsaW5nIHVwIGRvY3RhZ3MgbGlrZSAvKiBAYXV0aG9yIEJvYiBNY2dpbGwgKi9cbiAgICAgICAgJygnLFxuICAgICAgICBFTkdMSVNIX1dPUkQsXG4gICAgICAgIC9bLl0/WzpdPyhbLl1bIF18WyBdKS8sXG4gICAgICAgICcpezN9JykgLy8gbG9vayBmb3IgMyB3b3JkcyBpbiBhIHJvd1xuICAgIH1cbiAgKTtcbiAgcmV0dXJuIG1vZGU7XG59O1xuY29uc3QgQ19MSU5FX0NPTU1FTlRfTU9ERSA9IENPTU1FTlQoJy8vJywgJyQnKTtcbmNvbnN0IENfQkxPQ0tfQ09NTUVOVF9NT0RFID0gQ09NTUVOVCgnL1xcXFwqJywgJ1xcXFwqLycpO1xuY29uc3QgSEFTSF9DT01NRU5UX01PREUgPSBDT01NRU5UKCcjJywgJyQnKTtcbmNvbnN0IE5VTUJFUl9NT0RFID0ge1xuICBzY29wZTogJ251bWJlcicsXG4gIGJlZ2luOiBOVU1CRVJfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IENfTlVNQkVSX01PREUgPSB7XG4gIHNjb3BlOiAnbnVtYmVyJyxcbiAgYmVnaW46IENfTlVNQkVSX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBCSU5BUllfTlVNQkVSX01PREUgPSB7XG4gIHNjb3BlOiAnbnVtYmVyJyxcbiAgYmVnaW46IEJJTkFSWV9OVU1CRVJfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFJFR0VYUF9NT0RFID0ge1xuICBzY29wZTogXCJyZWdleHBcIixcbiAgYmVnaW46IC9cXC8oPz1bXi9cXG5dKlxcLykvLFxuICBlbmQ6IC9cXC9bZ2ltdXldKi8sXG4gIGNvbnRhaW5zOiBbXG4gICAgQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICB7XG4gICAgICBiZWdpbjogL1xcWy8sXG4gICAgICBlbmQ6IC9cXF0vLFxuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgY29udGFpbnM6IFtCQUNLU0xBU0hfRVNDQVBFXVxuICAgIH1cbiAgXVxufTtcbmNvbnN0IFRJVExFX01PREUgPSB7XG4gIHNjb3BlOiAndGl0bGUnLFxuICBiZWdpbjogSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcbmNvbnN0IFVOREVSU0NPUkVfVElUTEVfTU9ERSA9IHtcbiAgc2NvcGU6ICd0aXRsZScsXG4gIGJlZ2luOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICByZWxldmFuY2U6IDBcbn07XG5jb25zdCBNRVRIT0RfR1VBUkQgPSB7XG4gIC8vIGV4Y2x1ZGVzIG1ldGhvZCBuYW1lcyBmcm9tIGtleXdvcmQgcHJvY2Vzc2luZ1xuICBiZWdpbjogJ1xcXFwuXFxcXHMqJyArIFVOREVSU0NPUkVfSURFTlRfUkUsXG4gIHJlbGV2YW5jZTogMFxufTtcblxuLyoqXG4gKiBBZGRzIGVuZCBzYW1lIGFzIGJlZ2luIG1lY2hhbmljcyB0byBhIG1vZGVcbiAqXG4gKiBZb3VyIG1vZGUgbXVzdCBpbmNsdWRlIGF0IGxlYXN0IGEgc2luZ2xlICgpIG1hdGNoIGdyb3VwIGFzIHRoYXQgZmlyc3QgbWF0Y2hcbiAqIGdyb3VwIGlzIHdoYXQgaXMgdXNlZCBmb3IgY29tcGFyaXNvblxuICogQHBhcmFtIHtQYXJ0aWFsPE1vZGU+fSBtb2RlXG4gKi9cbmNvbnN0IEVORF9TQU1FX0FTX0JFR0lOID0gZnVuY3Rpb24obW9kZSkge1xuICByZXR1cm4gT2JqZWN0LmFzc2lnbihtb2RlLFxuICAgIHtcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmJlZ2luJzogKG0sIHJlc3ApID0+IHsgcmVzcC5kYXRhLl9iZWdpbk1hdGNoID0gbVsxXTsgfSxcbiAgICAgIC8qKiBAdHlwZSB7TW9kZUNhbGxiYWNrfSAqL1xuICAgICAgJ29uOmVuZCc6IChtLCByZXNwKSA9PiB7IGlmIChyZXNwLmRhdGEuX2JlZ2luTWF0Y2ggIT09IG1bMV0pIHJlc3AuaWdub3JlTWF0Y2goKTsgfVxuICAgIH0pO1xufTtcblxudmFyIE1PREVTID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoe1xuICBfX3Byb3RvX186IG51bGwsXG4gIEFQT1NfU1RSSU5HX01PREU6IEFQT1NfU1RSSU5HX01PREUsXG4gIEJBQ0tTTEFTSF9FU0NBUEU6IEJBQ0tTTEFTSF9FU0NBUEUsXG4gIEJJTkFSWV9OVU1CRVJfTU9ERTogQklOQVJZX05VTUJFUl9NT0RFLFxuICBCSU5BUllfTlVNQkVSX1JFOiBCSU5BUllfTlVNQkVSX1JFLFxuICBDT01NRU5UOiBDT01NRU5ULFxuICBDX0JMT0NLX0NPTU1FTlRfTU9ERTogQ19CTE9DS19DT01NRU5UX01PREUsXG4gIENfTElORV9DT01NRU5UX01PREU6IENfTElORV9DT01NRU5UX01PREUsXG4gIENfTlVNQkVSX01PREU6IENfTlVNQkVSX01PREUsXG4gIENfTlVNQkVSX1JFOiBDX05VTUJFUl9SRSxcbiAgRU5EX1NBTUVfQVNfQkVHSU46IEVORF9TQU1FX0FTX0JFR0lOLFxuICBIQVNIX0NPTU1FTlRfTU9ERTogSEFTSF9DT01NRU5UX01PREUsXG4gIElERU5UX1JFOiBJREVOVF9SRSxcbiAgTUFUQ0hfTk9USElOR19SRTogTUFUQ0hfTk9USElOR19SRSxcbiAgTUVUSE9EX0dVQVJEOiBNRVRIT0RfR1VBUkQsXG4gIE5VTUJFUl9NT0RFOiBOVU1CRVJfTU9ERSxcbiAgTlVNQkVSX1JFOiBOVU1CRVJfUkUsXG4gIFBIUkFTQUxfV09SRFNfTU9ERTogUEhSQVNBTF9XT1JEU19NT0RFLFxuICBRVU9URV9TVFJJTkdfTU9ERTogUVVPVEVfU1RSSU5HX01PREUsXG4gIFJFR0VYUF9NT0RFOiBSRUdFWFBfTU9ERSxcbiAgUkVfU1RBUlRFUlNfUkU6IFJFX1NUQVJURVJTX1JFLFxuICBTSEVCQU5HOiBTSEVCQU5HLFxuICBUSVRMRV9NT0RFOiBUSVRMRV9NT0RFLFxuICBVTkRFUlNDT1JFX0lERU5UX1JFOiBVTkRFUlNDT1JFX0lERU5UX1JFLFxuICBVTkRFUlNDT1JFX1RJVExFX01PREU6IFVOREVSU0NPUkVfVElUTEVfTU9ERVxufSk7XG5cbi8qKlxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ2FsbGJhY2tSZXNwb25zZX0gQ2FsbGJhY2tSZXNwb25zZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZXJFeHR9IENvbXBpbGVyRXh0XG4qL1xuXG4vLyBHcmFtbWFyIGV4dGVuc2lvbnMgLyBwbHVnaW5zXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4MzNcblxuLy8gR3JhbW1hciBleHRlbnNpb25zIGFsbG93IFwic3ludGFjdGljIHN1Z2FyXCIgdG8gYmUgYWRkZWQgdG8gdGhlIGdyYW1tYXIgbW9kZXNcbi8vIHdpdGhvdXQgcmVxdWlyaW5nIGFueSB1bmRlcmx5aW5nIGNoYW5nZXMgdG8gdGhlIGNvbXBpbGVyIGludGVybmFscy5cblxuLy8gYGNvbXBpbGVNYXRjaGAgYmVpbmcgdGhlIHBlcmZlY3Qgc21hbGwgZXhhbXBsZSBvZiBub3cgYWxsb3dpbmcgYSBncmFtbWFyXG4vLyBhdXRob3IgdG8gd3JpdGUgYG1hdGNoYCB3aGVuIHRoZXkgZGVzaXJlIHRvIG1hdGNoIGEgc2luZ2xlIGV4cHJlc3Npb24gcmF0aGVyXG4vLyB0aGFuIGJlaW5nIGZvcmNlZCB0byB1c2UgYGJlZ2luYC4gIFRoZSBleHRlbnNpb24gdGhlbiBqdXN0IG1vdmVzIGBtYXRjaGAgaW50b1xuLy8gYGJlZ2luYCB3aGVuIGl0IHJ1bnMuICBJZSwgbm8gZmVhdHVyZXMgaGF2ZSBiZWVuIGFkZGVkLCBidXQgd2UndmUganVzdCBtYWRlXG4vLyB0aGUgZXhwZXJpZW5jZSBvZiB3cml0aW5nIChhbmQgcmVhZGluZyBncmFtbWFycykgYSBsaXR0bGUgYml0IG5pY2VyLlxuXG4vLyAtLS0tLS1cblxuLy8gVE9ETzogV2UgbmVlZCBuZWdhdGl2ZSBsb29rLWJlaGluZCBzdXBwb3J0IHRvIGRvIHRoaXMgcHJvcGVybHlcbi8qKlxuICogU2tpcCBhIG1hdGNoIGlmIGl0IGhhcyBhIHByZWNlZGluZyBkb3RcbiAqXG4gKiBUaGlzIGlzIHVzZWQgZm9yIGBiZWdpbktleXdvcmRzYCB0byBwcmV2ZW50IG1hdGNoaW5nIGV4cHJlc3Npb25zIHN1Y2ggYXNcbiAqIGBib2Iua2V5d29yZC5kbygpYC4gVGhlIG1vZGUgY29tcGlsZXIgYXV0b21hdGljYWxseSB3aXJlcyB0aGlzIHVwIGFzIGFcbiAqIHNwZWNpYWwgX2ludGVybmFsXyAnb246YmVnaW4nIGNhbGxiYWNrIGZvciBtb2RlcyB3aXRoIGBiZWdpbktleXdvcmRzYFxuICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICogQHBhcmFtIHtDYWxsYmFja1Jlc3BvbnNlfSByZXNwb25zZVxuICovXG5mdW5jdGlvbiBza2lwSWZIYXNQcmVjZWRpbmdEb3QobWF0Y2gsIHJlc3BvbnNlKSB7XG4gIGNvbnN0IGJlZm9yZSA9IG1hdGNoLmlucHV0W21hdGNoLmluZGV4IC0gMV07XG4gIGlmIChiZWZvcmUgPT09IFwiLlwiKSB7XG4gICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgfVxufVxuXG4vKipcbiAqXG4gKiBAdHlwZSB7Q29tcGlsZXJFeHR9XG4gKi9cbmZ1bmN0aW9uIHNjb3BlQ2xhc3NOYW1lKG1vZGUsIF9wYXJlbnQpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICBpZiAobW9kZS5jbGFzc05hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgIG1vZGUuc2NvcGUgPSBtb2RlLmNsYXNzTmFtZTtcbiAgICBkZWxldGUgbW9kZS5jbGFzc05hbWU7XG4gIH1cbn1cblxuLyoqXG4gKiBgYmVnaW5LZXl3b3Jkc2Agc3ludGFjdGljIHN1Z2FyXG4gKiBAdHlwZSB7Q29tcGlsZXJFeHR9XG4gKi9cbmZ1bmN0aW9uIGJlZ2luS2V5d29yZHMobW9kZSwgcGFyZW50KSB7XG4gIGlmICghcGFyZW50KSByZXR1cm47XG4gIGlmICghbW9kZS5iZWdpbktleXdvcmRzKSByZXR1cm47XG5cbiAgLy8gZm9yIGxhbmd1YWdlcyB3aXRoIGtleXdvcmRzIHRoYXQgaW5jbHVkZSBub24td29yZCBjaGFyYWN0ZXJzIGNoZWNraW5nIGZvclxuICAvLyBhIHdvcmQgYm91bmRhcnkgaXMgbm90IHN1ZmZpY2llbnQsIHNvIGluc3RlYWQgd2UgY2hlY2sgZm9yIGEgd29yZCBib3VuZGFyeVxuICAvLyBvciB3aGl0ZXNwYWNlIC0gdGhpcyBkb2VzIG5vIGhhcm0gaW4gYW55IGNhc2Ugc2luY2Ugb3VyIGtleXdvcmQgZW5naW5lXG4gIC8vIGRvZXNuJ3QgYWxsb3cgc3BhY2VzIGluIGtleXdvcmRzIGFueXdheXMgYW5kIHdlIHN0aWxsIGNoZWNrIGZvciB0aGUgYm91bmRhcnlcbiAgLy8gZmlyc3RcbiAgbW9kZS5iZWdpbiA9ICdcXFxcYignICsgbW9kZS5iZWdpbktleXdvcmRzLnNwbGl0KCcgJykuam9pbignfCcpICsgJykoPyFcXFxcLikoPz1cXFxcYnxcXFxccyknO1xuICBtb2RlLl9fYmVmb3JlQmVnaW4gPSBza2lwSWZIYXNQcmVjZWRpbmdEb3Q7XG4gIG1vZGUua2V5d29yZHMgPSBtb2RlLmtleXdvcmRzIHx8IG1vZGUuYmVnaW5LZXl3b3JkcztcbiAgZGVsZXRlIG1vZGUuYmVnaW5LZXl3b3JkcztcblxuICAvLyBwcmV2ZW50cyBkb3VibGUgcmVsZXZhbmNlLCB0aGUga2V5d29yZHMgdGhlbXNlbHZlcyBwcm92aWRlXG4gIC8vIHJlbGV2YW5jZSwgdGhlIG1vZGUgZG9lc24ndCBuZWVkIHRvIGRvdWJsZSBpdFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZpbmVkXG4gIGlmIChtb2RlLnJlbGV2YW5jZSA9PT0gdW5kZWZpbmVkKSBtb2RlLnJlbGV2YW5jZSA9IDA7XG59XG5cbi8qKlxuICogQWxsb3cgYGlsbGVnYWxgIHRvIGNvbnRhaW4gYW4gYXJyYXkgb2YgaWxsZWdhbCB2YWx1ZXNcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZUlsbGVnYWwobW9kZSwgX3BhcmVudCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZS5pbGxlZ2FsKSkgcmV0dXJuO1xuXG4gIG1vZGUuaWxsZWdhbCA9IGVpdGhlciguLi5tb2RlLmlsbGVnYWwpO1xufVxuXG4vKipcbiAqIGBtYXRjaGAgdG8gbWF0Y2ggYSBzaW5nbGUgZXhwcmVzc2lvbiBmb3IgcmVhZGFiaWxpdHlcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZU1hdGNoKG1vZGUsIF9wYXJlbnQpIHtcbiAgaWYgKCFtb2RlLm1hdGNoKSByZXR1cm47XG4gIGlmIChtb2RlLmJlZ2luIHx8IG1vZGUuZW5kKSB0aHJvdyBuZXcgRXJyb3IoXCJiZWdpbiAmIGVuZCBhcmUgbm90IHN1cHBvcnRlZCB3aXRoIG1hdGNoXCIpO1xuXG4gIG1vZGUuYmVnaW4gPSBtb2RlLm1hdGNoO1xuICBkZWxldGUgbW9kZS5tYXRjaDtcbn1cblxuLyoqXG4gKiBwcm92aWRlcyB0aGUgZGVmYXVsdCAxIHJlbGV2YW5jZSB0byBhbGwgbW9kZXNcbiAqIEB0eXBlIHtDb21waWxlckV4dH1cbiAqL1xuZnVuY3Rpb24gY29tcGlsZVJlbGV2YW5jZShtb2RlLCBfcGFyZW50KSB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZmluZWRcbiAgaWYgKG1vZGUucmVsZXZhbmNlID09PSB1bmRlZmluZWQpIG1vZGUucmVsZXZhbmNlID0gMTtcbn1cblxuLy8gYWxsb3cgYmVmb3JlTWF0Y2ggdG8gYWN0IGFzIGEgXCJxdWFsaWZpZXJcIiBmb3IgdGhlIG1hdGNoXG4vLyB0aGUgZnVsbCBtYXRjaCBiZWdpbiBtdXN0IGJlIFtiZWZvcmVNYXRjaF1bYmVnaW5dXG5jb25zdCBiZWZvcmVNYXRjaEV4dCA9IChtb2RlLCBwYXJlbnQpID0+IHtcbiAgaWYgKCFtb2RlLmJlZm9yZU1hdGNoKSByZXR1cm47XG4gIC8vIHN0YXJ0cyBjb25mbGljdHMgd2l0aCBlbmRzUGFyZW50IHdoaWNoIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBjaGlsZFxuICAvLyBydWxlIGlzIG5vdCBtYXRjaGVkIG11bHRpcGxlIHRpbWVzXG4gIGlmIChtb2RlLnN0YXJ0cykgdGhyb3cgbmV3IEVycm9yKFwiYmVmb3JlTWF0Y2ggY2Fubm90IGJlIHVzZWQgd2l0aCBzdGFydHNcIik7XG5cbiAgY29uc3Qgb3JpZ2luYWxNb2RlID0gT2JqZWN0LmFzc2lnbih7fSwgbW9kZSk7XG4gIE9iamVjdC5rZXlzKG1vZGUpLmZvckVhY2goKGtleSkgPT4geyBkZWxldGUgbW9kZVtrZXldOyB9KTtcblxuICBtb2RlLmtleXdvcmRzID0gb3JpZ2luYWxNb2RlLmtleXdvcmRzO1xuICBtb2RlLmJlZ2luID0gY29uY2F0KG9yaWdpbmFsTW9kZS5iZWZvcmVNYXRjaCwgbG9va2FoZWFkKG9yaWdpbmFsTW9kZS5iZWdpbikpO1xuICBtb2RlLnN0YXJ0cyA9IHtcbiAgICByZWxldmFuY2U6IDAsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIE9iamVjdC5hc3NpZ24ob3JpZ2luYWxNb2RlLCB7IGVuZHNQYXJlbnQ6IHRydWUgfSlcbiAgICBdXG4gIH07XG4gIG1vZGUucmVsZXZhbmNlID0gMDtcblxuICBkZWxldGUgb3JpZ2luYWxNb2RlLmJlZm9yZU1hdGNoO1xufTtcblxuLy8ga2V5d29yZHMgdGhhdCBzaG91bGQgaGF2ZSBubyBkZWZhdWx0IHJlbGV2YW5jZSB2YWx1ZVxuY29uc3QgQ09NTU9OX0tFWVdPUkRTID0gW1xuICAnb2YnLFxuICAnYW5kJyxcbiAgJ2ZvcicsXG4gICdpbicsXG4gICdub3QnLFxuICAnb3InLFxuICAnaWYnLFxuICAndGhlbicsXG4gICdwYXJlbnQnLCAvLyBjb21tb24gdmFyaWFibGUgbmFtZVxuICAnbGlzdCcsIC8vIGNvbW1vbiB2YXJpYWJsZSBuYW1lXG4gICd2YWx1ZScgLy8gY29tbW9uIHZhcmlhYmxlIG5hbWVcbl07XG5cbmNvbnN0IERFRkFVTFRfS0VZV09SRF9TQ09QRSA9IFwia2V5d29yZFwiO1xuXG4vKipcbiAqIEdpdmVuIHJhdyBrZXl3b3JkcyBmcm9tIGEgbGFuZ3VhZ2UgZGVmaW5pdGlvbiwgY29tcGlsZSB0aGVtLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nIHwgUmVjb3JkPHN0cmluZyxzdHJpbmd8c3RyaW5nW10+IHwgQXJyYXk8c3RyaW5nPn0gcmF3S2V5d29yZHNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY2FzZUluc2Vuc2l0aXZlXG4gKi9cbmZ1bmN0aW9uIGNvbXBpbGVLZXl3b3JkcyhyYXdLZXl3b3JkcywgY2FzZUluc2Vuc2l0aXZlLCBzY29wZU5hbWUgPSBERUZBVUxUX0tFWVdPUkRfU0NPUEUpIHtcbiAgLyoqIEB0eXBlIHtpbXBvcnQoXCJoaWdobGlnaHQuanMvcHJpdmF0ZVwiKS5LZXl3b3JkRGljdH0gKi9cbiAgY29uc3QgY29tcGlsZWRLZXl3b3JkcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgLy8gaW5wdXQgY2FuIGJlIGEgc3RyaW5nIG9mIGtleXdvcmRzLCBhbiBhcnJheSBvZiBrZXl3b3Jkcywgb3IgYSBvYmplY3Qgd2l0aFxuICAvLyBuYW1lZCBrZXlzIHJlcHJlc2VudGluZyBzY29wZU5hbWUgKHdoaWNoIGNhbiB0aGVuIHBvaW50IHRvIGEgc3RyaW5nIG9yIGFycmF5KVxuICBpZiAodHlwZW9mIHJhd0tleXdvcmRzID09PSAnc3RyaW5nJykge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMuc3BsaXQoXCIgXCIpKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHJhd0tleXdvcmRzKSkge1xuICAgIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwgcmF3S2V5d29yZHMpO1xuICB9IGVsc2Uge1xuICAgIE9iamVjdC5rZXlzKHJhd0tleXdvcmRzKS5mb3JFYWNoKGZ1bmN0aW9uKHNjb3BlTmFtZSkge1xuICAgICAgLy8gY29sbGFwc2UgYWxsIG91ciBvYmplY3RzIGJhY2sgaW50byB0aGUgcGFyZW50IG9iamVjdFxuICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgY29tcGlsZWRLZXl3b3JkcyxcbiAgICAgICAgY29tcGlsZUtleXdvcmRzKHJhd0tleXdvcmRzW3Njb3BlTmFtZV0sIGNhc2VJbnNlbnNpdGl2ZSwgc2NvcGVOYW1lKVxuICAgICAgKTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY29tcGlsZWRLZXl3b3JkcztcblxuICAvLyAtLS1cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBsaXN0IG9mIGtleXdvcmRzXG4gICAqXG4gICAqIEV4OiBcImZvciBpZiB3aGVuIHdoaWxlfDVcIlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gc2NvcGVOYW1lXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0ga2V5d29yZExpc3RcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVMaXN0KHNjb3BlTmFtZSwga2V5d29yZExpc3QpIHtcbiAgICBpZiAoY2FzZUluc2Vuc2l0aXZlKSB7XG4gICAgICBrZXl3b3JkTGlzdCA9IGtleXdvcmRMaXN0Lm1hcCh4ID0+IHgudG9Mb3dlckNhc2UoKSk7XG4gICAgfVxuICAgIGtleXdvcmRMaXN0LmZvckVhY2goZnVuY3Rpb24oa2V5d29yZCkge1xuICAgICAgY29uc3QgcGFpciA9IGtleXdvcmQuc3BsaXQoJ3wnKTtcbiAgICAgIGNvbXBpbGVkS2V5d29yZHNbcGFpclswXV0gPSBbc2NvcGVOYW1lLCBzY29yZUZvcktleXdvcmQocGFpclswXSwgcGFpclsxXSldO1xuICAgIH0pO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcHJvcGVyIHNjb3JlIGZvciBhIGdpdmVuIGtleXdvcmRcbiAqXG4gKiBBbHNvIHRha2VzIGludG8gYWNjb3VudCBjb21tZW50IGtleXdvcmRzLCB3aGljaCB3aWxsIGJlIHNjb3JlZCAwIFVOTEVTU1xuICogYW5vdGhlciBzY29yZSBoYXMgYmVlbiBtYW51YWxseSBhc3NpZ25lZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXl3b3JkXG4gKiBAcGFyYW0ge3N0cmluZ30gW3Byb3ZpZGVkU2NvcmVdXG4gKi9cbmZ1bmN0aW9uIHNjb3JlRm9yS2V5d29yZChrZXl3b3JkLCBwcm92aWRlZFNjb3JlKSB7XG4gIC8vIG1hbnVhbCBzY29yZXMgYWx3YXlzIHdpbiBvdmVyIGNvbW1vbiBrZXl3b3Jkc1xuICAvLyBzbyB5b3UgY2FuIGZvcmNlIGEgc2NvcmUgb2YgMSBpZiB5b3UgcmVhbGx5IGluc2lzdFxuICBpZiAocHJvdmlkZWRTY29yZSkge1xuICAgIHJldHVybiBOdW1iZXIocHJvdmlkZWRTY29yZSk7XG4gIH1cblxuICByZXR1cm4gY29tbW9uS2V5d29yZChrZXl3b3JkKSA/IDAgOiAxO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBrZXl3b3JkIGlzIGNvbW1vbiBvciBub3RcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5d29yZCAqL1xuZnVuY3Rpb24gY29tbW9uS2V5d29yZChrZXl3b3JkKSB7XG4gIHJldHVybiBDT01NT05fS0VZV09SRFMuaW5jbHVkZXMoa2V5d29yZC50b0xvd2VyQ2FzZSgpKTtcbn1cblxuLypcblxuRm9yIHRoZSByZWFzb25pbmcgYmVoaW5kIHRoaXMgcGxlYXNlIHNlZTpcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzI4ODAjaXNzdWVjb21tZW50LTc0NzI3NTQxOVxuXG4qL1xuXG4vKipcbiAqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBib29sZWFuPn1cbiAqL1xuY29uc3Qgc2VlbkRlcHJlY2F0aW9ucyA9IHt9O1xuXG4vKipcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKi9cbmNvbnN0IGVycm9yID0gKG1lc3NhZ2UpID0+IHtcbiAgY29uc29sZS5lcnJvcihtZXNzYWdlKTtcbn07XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqIEBwYXJhbSB7YW55fSBhcmdzXG4gKi9cbmNvbnN0IHdhcm4gPSAobWVzc2FnZSwgLi4uYXJncykgPT4ge1xuICBjb25zb2xlLmxvZyhgV0FSTjogJHttZXNzYWdlfWAsIC4uLmFyZ3MpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2VcbiAqL1xuY29uc3QgZGVwcmVjYXRlZCA9ICh2ZXJzaW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmIChzZWVuRGVwcmVjYXRpb25zW2Ake3ZlcnNpb259LyR7bWVzc2FnZX1gXSkgcmV0dXJuO1xuXG4gIGNvbnNvbGUubG9nKGBEZXByZWNhdGVkIGFzIG9mICR7dmVyc2lvbn0uICR7bWVzc2FnZX1gKTtcbiAgc2VlbkRlcHJlY2F0aW9uc1tgJHt2ZXJzaW9ufS8ke21lc3NhZ2V9YF0gPSB0cnVlO1xufTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tdGhyb3ctbGl0ZXJhbCAqL1xuXG4vKipcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkTW9kZX0gQ29tcGlsZWRNb2RlXG4qL1xuXG5jb25zdCBNdWx0aUNsYXNzRXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuLyoqXG4gKiBSZW51bWJlcnMgbGFiZWxlZCBzY29wZSBuYW1lcyB0byBhY2NvdW50IGZvciBhZGRpdGlvbmFsIGlubmVyIG1hdGNoXG4gKiBncm91cHMgdGhhdCBvdGhlcndpc2Ugd291bGQgYnJlYWsgZXZlcnl0aGluZy5cbiAqXG4gKiBMZXRzIHNheSB3ZSAzIG1hdGNoIHNjb3BlczpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCAzID0+IC4uLiB9XG4gKlxuICogU28gd2hhdCB3ZSBuZWVkIGlzIGEgY2xlYW4gbWF0Y2ggbGlrZSB0aGlzOlxuICpcbiAqICAgKGEpKGIpKGMpID0+IFsgXCJhXCIsIFwiYlwiLCBcImNcIiBdXG4gKlxuICogQnV0IHRoaXMgZmFsbHMgYXBhcnQgd2l0aCBpbm5lciBtYXRjaCBncm91cHM6XG4gKlxuICogKGEpKCgoYikpKShjKSA9PiBbXCJhXCIsIFwiYlwiLCBcImJcIiwgXCJiXCIsIFwiY1wiIF1cbiAqXG4gKiBPdXIgc2NvcGVzIGFyZSBub3cgXCJvdXQgb2YgYWxpZ25tZW50XCIgYW5kIHdlJ3JlIHJlcGVhdGluZyBgYmAgMyB0aW1lcy5cbiAqIFdoYXQgbmVlZHMgdG8gaGFwcGVuIGlzIHRoZSBudW1iZXJzIGFyZSByZW1hcHBlZDpcbiAqXG4gKiAgIHsgMSA9PiAuLi4sIDIgPT4gLi4uLCA1ID0+IC4uLiB9XG4gKlxuICogV2UgYWxzbyBuZWVkIHRvIGtub3cgdGhhdCB0aGUgT05MWSBncm91cHMgdGhhdCBzaG91bGQgYmUgb3V0cHV0XG4gKiBhcmUgMSwgMiwgYW5kIDUuICBUaGlzIGZ1bmN0aW9uIGhhbmRsZXMgdGhpcyBiZWhhdmlvci5cbiAqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICogQHBhcmFtIHtBcnJheTxSZWdFeHAgfCBzdHJpbmc+fSByZWdleGVzXG4gKiBAcGFyYW0ge3trZXk6IFwiYmVnaW5TY29wZVwifFwiZW5kU2NvcGVcIn19IG9wdHNcbiAqL1xuZnVuY3Rpb24gcmVtYXBTY29wZU5hbWVzKG1vZGUsIHJlZ2V4ZXMsIHsga2V5IH0pIHtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGNvbnN0IHNjb3BlTmFtZXMgPSBtb2RlW2tleV07XG4gIC8qKiBAdHlwZSBSZWNvcmQ8bnVtYmVyLGJvb2xlYW4+ICovXG4gIGNvbnN0IGVtaXQgPSB7fTtcbiAgLyoqIEB0eXBlIFJlY29yZDxudW1iZXIsc3RyaW5nPiAqL1xuICBjb25zdCBwb3NpdGlvbnMgPSB7fTtcblxuICBmb3IgKGxldCBpID0gMTsgaSA8PSByZWdleGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgcG9zaXRpb25zW2kgKyBvZmZzZXRdID0gc2NvcGVOYW1lc1tpXTtcbiAgICBlbWl0W2kgKyBvZmZzZXRdID0gdHJ1ZTtcbiAgICBvZmZzZXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZWdleGVzW2kgLSAxXSk7XG4gIH1cbiAgLy8gd2UgdXNlIF9lbWl0IHRvIGtlZXAgdHJhY2sgb2Ygd2hpY2ggbWF0Y2ggZ3JvdXBzIGFyZSBcInRvcC1sZXZlbFwiIHRvIGF2b2lkIGRvdWJsZVxuICAvLyBvdXRwdXQgZnJvbSBpbnNpZGUgbWF0Y2ggZ3JvdXBzXG4gIG1vZGVba2V5XSA9IHBvc2l0aW9ucztcbiAgbW9kZVtrZXldLl9lbWl0ID0gZW1pdDtcbiAgbW9kZVtrZXldLl9tdWx0aSA9IHRydWU7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gYmVnaW5NdWx0aUNsYXNzKG1vZGUpIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KG1vZGUuYmVnaW4pKSByZXR1cm47XG5cbiAgaWYgKG1vZGUuc2tpcCB8fCBtb2RlLmV4Y2x1ZGVCZWdpbiB8fCBtb2RlLnJldHVybkJlZ2luKSB7XG4gICAgZXJyb3IoXCJza2lwLCBleGNsdWRlQmVnaW4sIHJldHVybkJlZ2luIG5vdCBjb21wYXRpYmxlIHdpdGggYmVnaW5TY29wZToge31cIik7XG4gICAgdGhyb3cgTXVsdGlDbGFzc0Vycm9yO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBtb2RlLmJlZ2luU2NvcGUgIT09IFwib2JqZWN0XCIgfHwgbW9kZS5iZWdpblNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJiZWdpblNjb3BlIG11c3QgYmUgb2JqZWN0XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIHJlbWFwU2NvcGVOYW1lcyhtb2RlLCBtb2RlLmJlZ2luLCB7IGtleTogXCJiZWdpblNjb3BlXCIgfSk7XG4gIG1vZGUuYmVnaW4gPSBfcmV3cml0ZUJhY2tyZWZlcmVuY2VzKG1vZGUuYmVnaW4sIHsgam9pbldpdGg6IFwiXCIgfSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAqL1xuZnVuY3Rpb24gZW5kTXVsdGlDbGFzcyhtb2RlKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShtb2RlLmVuZCkpIHJldHVybjtcblxuICBpZiAobW9kZS5za2lwIHx8IG1vZGUuZXhjbHVkZUVuZCB8fCBtb2RlLnJldHVybkVuZCkge1xuICAgIGVycm9yKFwic2tpcCwgZXhjbHVkZUVuZCwgcmV0dXJuRW5kIG5vdCBjb21wYXRpYmxlIHdpdGggZW5kU2NvcGU6IHt9XCIpO1xuICAgIHRocm93IE11bHRpQ2xhc3NFcnJvcjtcbiAgfVxuXG4gIGlmICh0eXBlb2YgbW9kZS5lbmRTY29wZSAhPT0gXCJvYmplY3RcIiB8fCBtb2RlLmVuZFNjb3BlID09PSBudWxsKSB7XG4gICAgZXJyb3IoXCJlbmRTY29wZSBtdXN0IGJlIG9iamVjdFwiKTtcbiAgICB0aHJvdyBNdWx0aUNsYXNzRXJyb3I7XG4gIH1cblxuICByZW1hcFNjb3BlTmFtZXMobW9kZSwgbW9kZS5lbmQsIHsga2V5OiBcImVuZFNjb3BlXCIgfSk7XG4gIG1vZGUuZW5kID0gX3Jld3JpdGVCYWNrcmVmZXJlbmNlcyhtb2RlLmVuZCwgeyBqb2luV2l0aDogXCJcIiB9KTtcbn1cblxuLyoqXG4gKiB0aGlzIGV4aXN0cyBvbmx5IHRvIGFsbG93IGBzY29wZToge31gIHRvIGJlIHVzZWQgYmVzaWRlIGBtYXRjaDpgXG4gKiBPdGhlcndpc2UgYGJlZ2luU2NvcGVgIHdvdWxkIG5lY2Vzc2FyeSBhbmQgdGhhdCB3b3VsZCBsb29rIHdlaXJkXG5cbiAge1xuICAgIG1hdGNoOiBbIC9kZWYvLCAvXFx3Ky8gXVxuICAgIHNjb3BlOiB7IDE6IFwia2V5d29yZFwiICwgMjogXCJ0aXRsZVwiIH1cbiAgfVxuXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICovXG5mdW5jdGlvbiBzY29wZVN1Z2FyKG1vZGUpIHtcbiAgaWYgKG1vZGUuc2NvcGUgJiYgdHlwZW9mIG1vZGUuc2NvcGUgPT09IFwib2JqZWN0XCIgJiYgbW9kZS5zY29wZSAhPT0gbnVsbCkge1xuICAgIG1vZGUuYmVnaW5TY29wZSA9IG1vZGUuc2NvcGU7XG4gICAgZGVsZXRlIG1vZGUuc2NvcGU7XG4gIH1cbn1cblxuLyoqXG4gKiBAcGFyYW0ge0NvbXBpbGVkTW9kZX0gbW9kZVxuICovXG5mdW5jdGlvbiBNdWx0aUNsYXNzKG1vZGUpIHtcbiAgc2NvcGVTdWdhcihtb2RlKTtcblxuICBpZiAodHlwZW9mIG1vZGUuYmVnaW5TY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1vZGUuYmVnaW5TY29wZSA9IHsgX3dyYXA6IG1vZGUuYmVnaW5TY29wZSB9O1xuICB9XG4gIGlmICh0eXBlb2YgbW9kZS5lbmRTY29wZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIG1vZGUuZW5kU2NvcGUgPSB7IF93cmFwOiBtb2RlLmVuZFNjb3BlIH07XG4gIH1cblxuICBiZWdpbk11bHRpQ2xhc3MobW9kZSk7XG4gIGVuZE11bHRpQ2xhc3MobW9kZSk7XG59XG5cbi8qKlxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRNb2RlfSBDb21waWxlZE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkxhbmd1YWdlfSBMYW5ndWFnZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU1BsdWdpbn0gSExKU1BsdWdpblxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRMYW5ndWFnZX0gQ29tcGlsZWRMYW5ndWFnZVxuKi9cblxuLy8gY29tcGlsYXRpb25cblxuLyoqXG4gKiBDb21waWxlcyBhIGxhbmd1YWdlIGRlZmluaXRpb24gcmVzdWx0XG4gKlxuICogR2l2ZW4gdGhlIHJhdyByZXN1bHQgb2YgYSBsYW5ndWFnZSBkZWZpbml0aW9uIChMYW5ndWFnZSksIGNvbXBpbGVzIHRoaXMgc29cbiAqIHRoYXQgaXQgaXMgcmVhZHkgZm9yIGhpZ2hsaWdodGluZyBjb2RlLlxuICogQHBhcmFtIHtMYW5ndWFnZX0gbGFuZ3VhZ2VcbiAqIEByZXR1cm5zIHtDb21waWxlZExhbmd1YWdlfVxuICovXG5mdW5jdGlvbiBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpIHtcbiAgLyoqXG4gICAqIEJ1aWxkcyBhIHJlZ2V4IHdpdGggdGhlIGNhc2Ugc2Vuc2l0aXZpdHkgb2YgdGhlIGN1cnJlbnQgbGFuZ3VhZ2VcbiAgICpcbiAgICogQHBhcmFtIHtSZWdFeHAgfCBzdHJpbmd9IHZhbHVlXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2dsb2JhbF1cbiAgICovXG4gIGZ1bmN0aW9uIGxhbmdSZSh2YWx1ZSwgZ2xvYmFsKSB7XG4gICAgcmV0dXJuIG5ldyBSZWdFeHAoXG4gICAgICBzb3VyY2UodmFsdWUpLFxuICAgICAgJ20nXG4gICAgICArIChsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gJ2knIDogJycpXG4gICAgICArIChsYW5ndWFnZS51bmljb2RlUmVnZXggPyAndScgOiAnJylcbiAgICAgICsgKGdsb2JhbCA/ICdnJyA6ICcnKVxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICBTdG9yZXMgbXVsdGlwbGUgcmVndWxhciBleHByZXNzaW9ucyBhbmQgYWxsb3dzIHlvdSB0byBxdWlja2x5IHNlYXJjaCBmb3JcbiAgICB0aGVtIGFsbCBpbiBhIHN0cmluZyBzaW11bHRhbmVvdXNseSAtIHJldHVybmluZyB0aGUgZmlyc3QgbWF0Y2guICBJdCBkb2VzXG4gICAgdGhpcyBieSBjcmVhdGluZyBhIGh1Z2UgKGF8YnxjKSByZWdleCAtIGVhY2ggaW5kaXZpZHVhbCBpdGVtIHdyYXBwZWQgd2l0aCAoKVxuICAgIGFuZCBqb2luZWQgYnkgYHxgIC0gdXNpbmcgbWF0Y2ggZ3JvdXBzIHRvIHRyYWNrIHBvc2l0aW9uLiAgV2hlbiBhIG1hdGNoIGlzXG4gICAgZm91bmQgY2hlY2tpbmcgd2hpY2ggcG9zaXRpb24gaW4gdGhlIGFycmF5IGhhcyBjb250ZW50IGFsbG93cyB1cyB0byBmaWd1cmVcbiAgICBvdXQgd2hpY2ggb2YgdGhlIG9yaWdpbmFsIHJlZ2V4ZXMgLyBtYXRjaCBncm91cHMgdHJpZ2dlcmVkIHRoZSBtYXRjaC5cblxuICAgIFRoZSBtYXRjaCBvYmplY3QgaXRzZWxmICh0aGUgcmVzdWx0IG9mIGBSZWdleC5leGVjYCkgaXMgcmV0dXJuZWQgYnV0IGFsc29cbiAgICBlbmhhbmNlZCBieSBtZXJnaW5nIGluIGFueSBtZXRhLWRhdGEgdGhhdCB3YXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSByZWdleC5cbiAgICBUaGlzIGlzIGhvdyB3ZSBrZWVwIHRyYWNrIG9mIHdoaWNoIG1vZGUgbWF0Y2hlZCwgYW5kIHdoYXQgdHlwZSBvZiBydWxlXG4gICAgKGBpbGxlZ2FsYCwgYGJlZ2luYCwgZW5kLCBldGMpLlxuICAqL1xuICBjbGFzcyBNdWx0aVJlZ2V4IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzID0ge307XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJlZ2V4ZXMgPSBbXTtcbiAgICAgIHRoaXMubWF0Y2hBdCA9IDE7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gMDtcbiAgICB9XG5cbiAgICAvLyBAdHMtaWdub3JlXG4gICAgYWRkUnVsZShyZSwgb3B0cykge1xuICAgICAgb3B0cy5wb3NpdGlvbiA9IHRoaXMucG9zaXRpb24rKztcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHRoaXMubWF0Y2hJbmRleGVzW3RoaXMubWF0Y2hBdF0gPSBvcHRzO1xuICAgICAgdGhpcy5yZWdleGVzLnB1c2goW29wdHMsIHJlXSk7XG4gICAgICB0aGlzLm1hdGNoQXQgKz0gY291bnRNYXRjaEdyb3VwcyhyZSkgKyAxO1xuICAgIH1cblxuICAgIGNvbXBpbGUoKSB7XG4gICAgICBpZiAodGhpcy5yZWdleGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAvLyBhdm9pZHMgdGhlIG5lZWQgdG8gY2hlY2sgbGVuZ3RoIGV2ZXJ5IHRpbWUgZXhlYyBpcyBjYWxsZWRcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICB0aGlzLmV4ZWMgPSAoKSA9PiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVybWluYXRvcnMgPSB0aGlzLnJlZ2V4ZXMubWFwKGVsID0+IGVsWzFdKTtcbiAgICAgIHRoaXMubWF0Y2hlclJlID0gbGFuZ1JlKF9yZXdyaXRlQmFja3JlZmVyZW5jZXModGVybWluYXRvcnMsIHsgam9pbldpdGg6ICd8JyB9KSwgdHJ1ZSk7XG4gICAgICB0aGlzLmxhc3RJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLyoqIEBwYXJhbSB7c3RyaW5nfSBzICovXG4gICAgZXhlYyhzKSB7XG4gICAgICB0aGlzLm1hdGNoZXJSZS5sYXN0SW5kZXggPSB0aGlzLmxhc3RJbmRleDtcbiAgICAgIGNvbnN0IG1hdGNoID0gdGhpcy5tYXRjaGVyUmUuZXhlYyhzKTtcbiAgICAgIGlmICghbWF0Y2gpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgICAgY29uc3QgaSA9IG1hdGNoLmZpbmRJbmRleCgoZWwsIGkpID0+IGkgPiAwICYmIGVsICE9PSB1bmRlZmluZWQpO1xuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgY29uc3QgbWF0Y2hEYXRhID0gdGhpcy5tYXRjaEluZGV4ZXNbaV07XG4gICAgICAvLyB0cmltIG9mZiBhbnkgZWFybGllciBub24tcmVsZXZhbnQgbWF0Y2ggZ3JvdXBzIChpZSwgdGhlIG90aGVyIHJlZ2V4XG4gICAgICAvLyBtYXRjaCBncm91cHMgdGhhdCBtYWtlIHVwIHRoZSBtdWx0aS1tYXRjaGVyKVxuICAgICAgbWF0Y2guc3BsaWNlKDAsIGkpO1xuXG4gICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihtYXRjaCwgbWF0Y2hEYXRhKTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgIENyZWF0ZWQgdG8gc29sdmUgdGhlIGtleSBkZWZpY2llbnRseSB3aXRoIE11bHRpUmVnZXggLSB0aGVyZSBpcyBubyB3YXkgdG9cbiAgICB0ZXN0IGZvciBtdWx0aXBsZSBtYXRjaGVzIGF0IGEgc2luZ2xlIGxvY2F0aW9uLiAgV2h5IHdvdWxkIHdlIG5lZWQgdG8gZG9cbiAgICB0aGF0PyAgSW4gdGhlIGZ1dHVyZSBhIG1vcmUgZHluYW1pYyBlbmdpbmUgd2lsbCBhbGxvdyBjZXJ0YWluIG1hdGNoZXMgdG8gYmVcbiAgICBpZ25vcmVkLiAgQW4gZXhhbXBsZTogaWYgd2UgbWF0Y2hlZCBzYXkgdGhlIDNyZCByZWdleCBpbiBhIGxhcmdlIGdyb3VwIGJ1dFxuICAgIGRlY2lkZWQgdG8gaWdub3JlIGl0IC0gd2UnZCBuZWVkIHRvIHN0YXJ0ZWQgdGVzdGluZyBhZ2FpbiBhdCB0aGUgNHRoXG4gICAgcmVnZXguLi4gYnV0IE11bHRpUmVnZXggaXRzZWxmIGdpdmVzIHVzIG5vIHJlYWwgd2F5IHRvIGRvIHRoYXQuXG5cbiAgICBTbyB3aGF0IHRoaXMgY2xhc3MgY3JlYXRlcyBNdWx0aVJlZ2V4cyBvbiB0aGUgZmx5IGZvciB3aGF0ZXZlciBzZWFyY2hcbiAgICBwb3NpdGlvbiB0aGV5IGFyZSBuZWVkZWQuXG5cbiAgICBOT1RFOiBUaGVzZSBhZGRpdGlvbmFsIE11bHRpUmVnZXggb2JqZWN0cyBhcmUgY3JlYXRlZCBkeW5hbWljYWxseS4gIEZvciBtb3N0XG4gICAgZ3JhbW1hcnMgbW9zdCBvZiB0aGUgdGltZSB3ZSB3aWxsIG5ldmVyIGFjdHVhbGx5IG5lZWQgYW55dGhpbmcgbW9yZSB0aGFuIHRoZVxuICAgIGZpcnN0IE11bHRpUmVnZXggLSBzbyB0aGlzIHNob3VsZG4ndCBoYXZlIHRvbyBtdWNoIG92ZXJoZWFkLlxuXG4gICAgU2F5IHRoaXMgaXMgb3VyIHNlYXJjaCBncm91cCwgYW5kIHdlIG1hdGNoIHJlZ2V4MywgYnV0IHdpc2ggdG8gaWdub3JlIGl0LlxuXG4gICAgICByZWdleDEgfCByZWdleDIgfCByZWdleDMgfCByZWdleDQgfCByZWdleDUgICAgJyBpZSwgc3RhcnRBdCA9IDBcblxuICAgIFdoYXQgd2UgbmVlZCBpcyBhIG5ldyBNdWx0aVJlZ2V4IHRoYXQgb25seSBpbmNsdWRlcyB0aGUgcmVtYWluaW5nXG4gICAgcG9zc2liaWxpdGllczpcblxuICAgICAgcmVnZXg0IHwgcmVnZXg1ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICcgaWUsIHN0YXJ0QXQgPSAzXG5cbiAgICBUaGlzIGNsYXNzIHdyYXBzIGFsbCB0aGF0IGNvbXBsZXhpdHkgdXAgaW4gYSBzaW1wbGUgQVBJLi4uIGBzdGFydEF0YCBkZWNpZGVzXG4gICAgd2hlcmUgaW4gdGhlIGFycmF5IG9mIGV4cHJlc3Npb25zIHRvIHN0YXJ0IGRvaW5nIHRoZSBtYXRjaGluZy4gSXRcbiAgICBhdXRvLWluY3JlbWVudHMsIHNvIGlmIGEgbWF0Y2ggaXMgZm91bmQgYXQgcG9zaXRpb24gMiwgdGhlbiBzdGFydEF0IHdpbGwgYmVcbiAgICBzZXQgdG8gMy4gIElmIHRoZSBlbmQgaXMgcmVhY2hlZCBzdGFydEF0IHdpbGwgcmV0dXJuIHRvIDAuXG5cbiAgICBNT1NUIG9mIHRoZSB0aW1lIHRoZSBwYXJzZXIgd2lsbCBiZSBzZXR0aW5nIHN0YXJ0QXQgbWFudWFsbHkgdG8gMC5cbiAgKi9cbiAgY2xhc3MgUmVzdW1hYmxlTXVsdGlSZWdleCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLnJ1bGVzID0gW107XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0aGlzLm11bHRpUmVnZXhlcyA9IFtdO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG5cbiAgICAgIHRoaXMubGFzdEluZGV4ID0gMDtcbiAgICAgIHRoaXMucmVnZXhJbmRleCA9IDA7XG4gICAgfVxuXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGdldE1hdGNoZXIoaW5kZXgpIHtcbiAgICAgIGlmICh0aGlzLm11bHRpUmVnZXhlc1tpbmRleF0pIHJldHVybiB0aGlzLm11bHRpUmVnZXhlc1tpbmRleF07XG5cbiAgICAgIGNvbnN0IG1hdGNoZXIgPSBuZXcgTXVsdGlSZWdleCgpO1xuICAgICAgdGhpcy5ydWxlcy5zbGljZShpbmRleCkuZm9yRWFjaCgoW3JlLCBvcHRzXSkgPT4gbWF0Y2hlci5hZGRSdWxlKHJlLCBvcHRzKSk7XG4gICAgICBtYXRjaGVyLmNvbXBpbGUoKTtcbiAgICAgIHRoaXMubXVsdGlSZWdleGVzW2luZGV4XSA9IG1hdGNoZXI7XG4gICAgICByZXR1cm4gbWF0Y2hlcjtcbiAgICB9XG5cbiAgICByZXN1bWluZ1NjYW5BdFNhbWVQb3NpdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnJlZ2V4SW5kZXggIT09IDA7XG4gICAgfVxuXG4gICAgY29uc2lkZXJBbGwoKSB7XG4gICAgICB0aGlzLnJlZ2V4SW5kZXggPSAwO1xuICAgIH1cblxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBhZGRSdWxlKHJlLCBvcHRzKSB7XG4gICAgICB0aGlzLnJ1bGVzLnB1c2goW3JlLCBvcHRzXSk7XG4gICAgICBpZiAob3B0cy50eXBlID09PSBcImJlZ2luXCIpIHRoaXMuY291bnQrKztcbiAgICB9XG5cbiAgICAvKiogQHBhcmFtIHtzdHJpbmd9IHMgKi9cbiAgICBleGVjKHMpIHtcbiAgICAgIGNvbnN0IG0gPSB0aGlzLmdldE1hdGNoZXIodGhpcy5yZWdleEluZGV4KTtcbiAgICAgIG0ubGFzdEluZGV4ID0gdGhpcy5sYXN0SW5kZXg7XG4gICAgICBsZXQgcmVzdWx0ID0gbS5leGVjKHMpO1xuXG4gICAgICAvLyBUaGUgZm9sbG93aW5nIGlzIGJlY2F1c2Ugd2UgaGF2ZSBubyBlYXN5IHdheSB0byBzYXkgXCJyZXN1bWUgc2Nhbm5pbmcgYXQgdGhlXG4gICAgICAvLyBleGlzdGluZyBwb3NpdGlvbiBidXQgYWxzbyBza2lwIHRoZSBjdXJyZW50IHJ1bGUgT05MWVwiLiBXaGF0IGhhcHBlbnMgaXNcbiAgICAgIC8vIGFsbCBwcmlvciBydWxlcyBhcmUgYWxzbyBza2lwcGVkIHdoaWNoIGNhbiByZXN1bHQgaW4gbWF0Y2hpbmcgdGhlIHdyb25nXG4gICAgICAvLyB0aGluZy4gRXhhbXBsZSBvZiBtYXRjaGluZyBcImJvb2dlclwiOlxuXG4gICAgICAvLyBvdXIgbWF0Y2hlciBpcyBbc3RyaW5nLCBcImJvb2dlclwiLCBudW1iZXJdXG4gICAgICAvL1xuICAgICAgLy8gLi4uLmJvb2dlci4uLi5cblxuICAgICAgLy8gaWYgXCJib29nZXJcIiBpcyBpZ25vcmVkIHRoZW4gd2UnZCByZWFsbHkgbmVlZCBhIHJlZ2V4IHRvIHNjYW4gZnJvbSB0aGVcbiAgICAgIC8vIFNBTUUgcG9zaXRpb24gZm9yIG9ubHk6IFtzdHJpbmcsIG51bWJlcl0gYnV0IGlnbm9yaW5nIFwiYm9vZ2VyXCIgKGlmIGl0XG4gICAgICAvLyB3YXMgdGhlIGZpcnN0IG1hdGNoKSwgYSBzaW1wbGUgcmVzdW1lIHdvdWxkIHNjYW4gYWhlYWQgd2hvIGtub3dzIGhvd1xuICAgICAgLy8gZmFyIGxvb2tpbmcgb25seSBmb3IgXCJudW1iZXJcIiwgaWdub3JpbmcgcG90ZW50aWFsIHN0cmluZyBtYXRjaGVzIChvclxuICAgICAgLy8gZnV0dXJlIFwiYm9vZ2VyXCIgbWF0Y2hlcyB0aGF0IG1pZ2h0IGJlIHZhbGlkLilcblxuICAgICAgLy8gU28gd2hhdCB3ZSBkbzogV2UgZXhlY3V0ZSB0d28gbWF0Y2hlcnMsIG9uZSByZXN1bWluZyBhdCB0aGUgc2FtZVxuICAgICAgLy8gcG9zaXRpb24sIGJ1dCB0aGUgc2Vjb25kIGZ1bGwgbWF0Y2hlciBzdGFydGluZyBhdCB0aGUgcG9zaXRpb24gYWZ0ZXI6XG5cbiAgICAgIC8vICAgICAvLS0tIHJlc3VtZSBmaXJzdCByZWdleCBtYXRjaCBoZXJlIChmb3IgW251bWJlcl0pXG4gICAgICAvLyAgICAgfC8tLS0tIGZ1bGwgbWF0Y2ggaGVyZSBmb3IgW3N0cmluZywgXCJib29nZXJcIiwgbnVtYmVyXVxuICAgICAgLy8gICAgIHZ2XG4gICAgICAvLyAuLi4uYm9vZ2VyLi4uLlxuXG4gICAgICAvLyBXaGljaCBldmVyIHJlc3VsdHMgaW4gYSBtYXRjaCBmaXJzdCBpcyB0aGVuIHVzZWQuIFNvIHRoaXMgMy00IHN0ZXBcbiAgICAgIC8vIHByb2Nlc3MgZXNzZW50aWFsbHkgYWxsb3dzIHVzIHRvIHNheSBcIm1hdGNoIGF0IHRoaXMgcG9zaXRpb24sIGV4Y2x1ZGluZ1xuICAgICAgLy8gYSBwcmlvciBydWxlIHRoYXQgd2FzIGlnbm9yZWRcIi5cbiAgICAgIC8vXG4gICAgICAvLyAxLiBNYXRjaCBcImJvb2dlclwiIGZpcnN0LCBpZ25vcmUuIEFsc28gcHJvdmVzIHRoYXQgW3N0cmluZ10gZG9lcyBub24gbWF0Y2guXG4gICAgICAvLyAyLiBSZXN1bWUgbWF0Y2hpbmcgZm9yIFtudW1iZXJdXG4gICAgICAvLyAzLiBNYXRjaCBhdCBpbmRleCArIDEgZm9yIFtzdHJpbmcsIFwiYm9vZ2VyXCIsIG51bWJlcl1cbiAgICAgIC8vIDQuIElmICMyIGFuZCAjMyByZXN1bHQgaW4gbWF0Y2hlcywgd2hpY2ggY2FtZSBmaXJzdD9cbiAgICAgIGlmICh0aGlzLnJlc3VtaW5nU2NhbkF0U2FtZVBvc2l0aW9uKCkpIHtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuaW5kZXggPT09IHRoaXMubGFzdEluZGV4KSA7IGVsc2UgeyAvLyB1c2UgdGhlIHNlY29uZCBtYXRjaGVyIHJlc3VsdFxuICAgICAgICAgIGNvbnN0IG0yID0gdGhpcy5nZXRNYXRjaGVyKDApO1xuICAgICAgICAgIG0yLmxhc3RJbmRleCA9IHRoaXMubGFzdEluZGV4ICsgMTtcbiAgICAgICAgICByZXN1bHQgPSBtMi5leGVjKHMpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgdGhpcy5yZWdleEluZGV4ICs9IHJlc3VsdC5wb3NpdGlvbiArIDE7XG4gICAgICAgIGlmICh0aGlzLnJlZ2V4SW5kZXggPT09IHRoaXMuY291bnQpIHtcbiAgICAgICAgICAvLyB3cmFwLWFyb3VuZCB0byBjb25zaWRlcmluZyBhbGwgbWF0Y2hlcyBhZ2FpblxuICAgICAgICAgIHRoaXMuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlbiBhIG1vZGUsIGJ1aWxkcyBhIGh1Z2UgUmVzdW1hYmxlTXVsdGlSZWdleCB0aGF0IGNhbiBiZSB1c2VkIHRvIHdhbGtcbiAgICogdGhlIGNvbnRlbnQgYW5kIGZpbmQgbWF0Y2hlcy5cbiAgICpcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGVcbiAgICogQHJldHVybnMge1Jlc3VtYWJsZU11bHRpUmVnZXh9XG4gICAqL1xuICBmdW5jdGlvbiBidWlsZE1vZGVSZWdleChtb2RlKSB7XG4gICAgY29uc3QgbW0gPSBuZXcgUmVzdW1hYmxlTXVsdGlSZWdleCgpO1xuXG4gICAgbW9kZS5jb250YWlucy5mb3JFYWNoKHRlcm0gPT4gbW0uYWRkUnVsZSh0ZXJtLmJlZ2luLCB7IHJ1bGU6IHRlcm0sIHR5cGU6IFwiYmVnaW5cIiB9KSk7XG5cbiAgICBpZiAobW9kZS50ZXJtaW5hdG9yRW5kKSB7XG4gICAgICBtbS5hZGRSdWxlKG1vZGUudGVybWluYXRvckVuZCwgeyB0eXBlOiBcImVuZFwiIH0pO1xuICAgIH1cbiAgICBpZiAobW9kZS5pbGxlZ2FsKSB7XG4gICAgICBtbS5hZGRSdWxlKG1vZGUuaWxsZWdhbCwgeyB0eXBlOiBcImlsbGVnYWxcIiB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gbW07XG4gIH1cblxuICAvKiogc2tpcCB2cyBhYm9ydCB2cyBpZ25vcmVcbiAgICpcbiAgICogQHNraXAgICAtIFRoZSBtb2RlIGlzIHN0aWxsIGVudGVyZWQgYW5kIGV4aXRlZCBub3JtYWxseSAoYW5kIGNvbnRhaW5zIHJ1bGVzIGFwcGx5KSxcbiAgICogICAgICAgICAgIGJ1dCBhbGwgY29udGVudCBpcyBoZWxkIGFuZCBhZGRlZCB0byB0aGUgcGFyZW50IGJ1ZmZlciByYXRoZXIgdGhhbiBiZWluZ1xuICAgKiAgICAgICAgICAgb3V0cHV0IHdoZW4gdGhlIG1vZGUgZW5kcy4gIE1vc3RseSB1c2VkIHdpdGggYHN1Ymxhbmd1YWdlYCB0byBidWlsZCB1cFxuICAgKiAgICAgICAgICAgYSBzaW5nbGUgbGFyZ2UgYnVmZmVyIHRoYW4gY2FuIGJlIHBhcnNlZCBieSBzdWJsYW5ndWFnZS5cbiAgICpcbiAgICogICAgICAgICAgICAgLSBUaGUgbW9kZSBiZWdpbiBhbmRzIGVuZHMgbm9ybWFsbHkuXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGlzIGFkZGVkIHRvIHRoZSBwYXJlbnQgbW9kZSBidWZmZXIuXG4gICAqICAgICAgICAgICAgIC0gVGhlIHBhcnNlciBjdXJzb3IgaXMgbW92ZWQgZm9yd2FyZCBub3JtYWxseS5cbiAgICpcbiAgICogQGFib3J0ICAtIEEgaGFjayBwbGFjZWhvbGRlciB1bnRpbCB3ZSBoYXZlIGlnbm9yZS4gIEFib3J0cyB0aGUgbW9kZSAoYXMgaWYgaXRcbiAgICogICAgICAgICAgIG5ldmVyIG1hdGNoZWQpIGJ1dCBET0VTIE5PVCBjb250aW51ZSB0byBtYXRjaCBzdWJzZXF1ZW50IGBjb250YWluc2BcbiAgICogICAgICAgICAgIG1vZGVzLiAgQWJvcnQgaXMgYmFkL3N1Ym9wdGltYWwgYmVjYXVzZSBpdCBjYW4gcmVzdWx0IGluIG1vZGVzXG4gICAqICAgICAgICAgICBmYXJ0aGVyIGRvd24gbm90IGdldHRpbmcgYXBwbGllZCBiZWNhdXNlIGFuIGVhcmxpZXIgcnVsZSBlYXRzIHRoZVxuICAgKiAgICAgICAgICAgY29udGVudCBidXQgdGhlbiBhYm9ydHMuXG4gICAqXG4gICAqICAgICAgICAgICAgIC0gVGhlIG1vZGUgZG9lcyBub3QgYmVnaW4uXG4gICAqICAgICAgICAgICAgIC0gQ29udGVudCBtYXRjaGVkIGJ5IGBiZWdpbmAgaXMgYWRkZWQgdG8gdGhlIG1vZGUgYnVmZmVyLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG1vdmVkIGZvcndhcmQgYWNjb3JkaW5nbHkuXG4gICAqXG4gICAqIEBpZ25vcmUgLSBJZ25vcmVzIHRoZSBtb2RlIChhcyBpZiBpdCBuZXZlciBtYXRjaGVkKSBhbmQgY29udGludWVzIHRvIG1hdGNoIGFueVxuICAgKiAgICAgICAgICAgc3Vic2VxdWVudCBgY29udGFpbnNgIG1vZGVzLiAgSWdub3JlIGlzbid0IHRlY2huaWNhbGx5IHBvc3NpYmxlIHdpdGhcbiAgICogICAgICAgICAgIHRoZSBjdXJyZW50IHBhcnNlciBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogICAgICAgICAgICAgLSBUaGUgbW9kZSBkb2VzIG5vdCBiZWdpbi5cbiAgICogICAgICAgICAgICAgLSBDb250ZW50IG1hdGNoZWQgYnkgYGJlZ2luYCBpcyBpZ25vcmVkLlxuICAgKiAgICAgICAgICAgICAtIFRoZSBwYXJzZXIgY3Vyc29yIGlzIG5vdCBtb3ZlZCBmb3J3YXJkLlxuICAgKi9cblxuICAvKipcbiAgICogQ29tcGlsZXMgYW4gaW5kaXZpZHVhbCBtb2RlXG4gICAqXG4gICAqIFRoaXMgY2FuIHJhaXNlIGFuIGVycm9yIGlmIHRoZSBtb2RlIGNvbnRhaW5zIGNlcnRhaW4gZGV0ZWN0YWJsZSBrbm93biBsb2dpY1xuICAgKiBpc3N1ZXMuXG4gICAqIEBwYXJhbSB7TW9kZX0gbW9kZVxuICAgKiBAcGFyYW0ge0NvbXBpbGVkTW9kZSB8IG51bGx9IFtwYXJlbnRdXG4gICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCBuZXZlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBpbGVNb2RlKG1vZGUsIHBhcmVudCkge1xuICAgIGNvbnN0IGNtb2RlID0gLyoqIEB0eXBlIENvbXBpbGVkTW9kZSAqLyAobW9kZSk7XG4gICAgaWYgKG1vZGUuaXNDb21waWxlZCkgcmV0dXJuIGNtb2RlO1xuXG4gICAgW1xuICAgICAgc2NvcGVDbGFzc05hbWUsXG4gICAgICAvLyBkbyB0aGlzIGVhcmx5IHNvIGNvbXBpbGVyIGV4dGVuc2lvbnMgZ2VuZXJhbGx5IGRvbid0IGhhdmUgdG8gd29ycnkgYWJvdXRcbiAgICAgIC8vIHRoZSBkaXN0aW5jdGlvbiBiZXR3ZWVuIG1hdGNoL2JlZ2luXG4gICAgICBjb21waWxlTWF0Y2gsXG4gICAgICBNdWx0aUNsYXNzLFxuICAgICAgYmVmb3JlTWF0Y2hFeHRcbiAgICBdLmZvckVhY2goZXh0ID0+IGV4dChtb2RlLCBwYXJlbnQpKTtcblxuICAgIGxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucy5mb3JFYWNoKGV4dCA9PiBleHQobW9kZSwgcGFyZW50KSk7XG5cbiAgICAvLyBfX2JlZm9yZUJlZ2luIGlzIGNvbnNpZGVyZWQgcHJpdmF0ZSBBUEksIGludGVybmFsIHVzZSBvbmx5XG4gICAgbW9kZS5fX2JlZm9yZUJlZ2luID0gbnVsbDtcblxuICAgIFtcbiAgICAgIGJlZ2luS2V5d29yZHMsXG4gICAgICAvLyBkbyB0aGlzIGxhdGVyIHNvIGNvbXBpbGVyIGV4dGVuc2lvbnMgdGhhdCBjb21lIGVhcmxpZXIgaGF2ZSBhY2Nlc3MgdG8gdGhlXG4gICAgICAvLyByYXcgYXJyYXkgaWYgdGhleSB3YW50ZWQgdG8gcGVyaGFwcyBtYW5pcHVsYXRlIGl0LCBldGMuXG4gICAgICBjb21waWxlSWxsZWdhbCxcbiAgICAgIC8vIGRlZmF1bHQgdG8gMSByZWxldmFuY2UgaWYgbm90IHNwZWNpZmllZFxuICAgICAgY29tcGlsZVJlbGV2YW5jZVxuICAgIF0uZm9yRWFjaChleHQgPT4gZXh0KG1vZGUsIHBhcmVudCkpO1xuXG4gICAgbW9kZS5pc0NvbXBpbGVkID0gdHJ1ZTtcblxuICAgIGxldCBrZXl3b3JkUGF0dGVybiA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBtb2RlLmtleXdvcmRzID09PSBcIm9iamVjdFwiICYmIG1vZGUua2V5d29yZHMuJHBhdHRlcm4pIHtcbiAgICAgIC8vIHdlIG5lZWQgYSBjb3B5IGJlY2F1c2Uga2V5d29yZHMgbWlnaHQgYmUgY29tcGlsZWQgbXVsdGlwbGUgdGltZXNcbiAgICAgIC8vIHNvIHdlIGNhbid0IGdvIGRlbGV0aW5nICRwYXR0ZXJuIGZyb20gdGhlIG9yaWdpbmFsIG9uIHRoZSBmaXJzdFxuICAgICAgLy8gcGFzc1xuICAgICAgbW9kZS5rZXl3b3JkcyA9IE9iamVjdC5hc3NpZ24oe30sIG1vZGUua2V5d29yZHMpO1xuICAgICAga2V5d29yZFBhdHRlcm4gPSBtb2RlLmtleXdvcmRzLiRwYXR0ZXJuO1xuICAgICAgZGVsZXRlIG1vZGUua2V5d29yZHMuJHBhdHRlcm47XG4gICAgfVxuICAgIGtleXdvcmRQYXR0ZXJuID0ga2V5d29yZFBhdHRlcm4gfHwgL1xcdysvO1xuXG4gICAgaWYgKG1vZGUua2V5d29yZHMpIHtcbiAgICAgIG1vZGUua2V5d29yZHMgPSBjb21waWxlS2V5d29yZHMobW9kZS5rZXl3b3JkcywgbGFuZ3VhZ2UuY2FzZV9pbnNlbnNpdGl2ZSk7XG4gICAgfVxuXG4gICAgY21vZGUua2V5d29yZFBhdHRlcm5SZSA9IGxhbmdSZShrZXl3b3JkUGF0dGVybiwgdHJ1ZSk7XG5cbiAgICBpZiAocGFyZW50KSB7XG4gICAgICBpZiAoIW1vZGUuYmVnaW4pIG1vZGUuYmVnaW4gPSAvXFxCfFxcYi87XG4gICAgICBjbW9kZS5iZWdpblJlID0gbGFuZ1JlKGNtb2RlLmJlZ2luKTtcbiAgICAgIGlmICghbW9kZS5lbmQgJiYgIW1vZGUuZW5kc1dpdGhQYXJlbnQpIG1vZGUuZW5kID0gL1xcQnxcXGIvO1xuICAgICAgaWYgKG1vZGUuZW5kKSBjbW9kZS5lbmRSZSA9IGxhbmdSZShjbW9kZS5lbmQpO1xuICAgICAgY21vZGUudGVybWluYXRvckVuZCA9IHNvdXJjZShjbW9kZS5lbmQpIHx8ICcnO1xuICAgICAgaWYgKG1vZGUuZW5kc1dpdGhQYXJlbnQgJiYgcGFyZW50LnRlcm1pbmF0b3JFbmQpIHtcbiAgICAgICAgY21vZGUudGVybWluYXRvckVuZCArPSAobW9kZS5lbmQgPyAnfCcgOiAnJykgKyBwYXJlbnQudGVybWluYXRvckVuZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG1vZGUuaWxsZWdhbCkgY21vZGUuaWxsZWdhbFJlID0gbGFuZ1JlKC8qKiBAdHlwZSB7UmVnRXhwIHwgc3RyaW5nfSAqLyAobW9kZS5pbGxlZ2FsKSk7XG4gICAgaWYgKCFtb2RlLmNvbnRhaW5zKSBtb2RlLmNvbnRhaW5zID0gW107XG5cbiAgICBtb2RlLmNvbnRhaW5zID0gW10uY29uY2F0KC4uLm1vZGUuY29udGFpbnMubWFwKGZ1bmN0aW9uKGMpIHtcbiAgICAgIHJldHVybiBleHBhbmRPckNsb25lTW9kZShjID09PSAnc2VsZicgPyBtb2RlIDogYyk7XG4gICAgfSkpO1xuICAgIG1vZGUuY29udGFpbnMuZm9yRWFjaChmdW5jdGlvbihjKSB7IGNvbXBpbGVNb2RlKC8qKiBAdHlwZSBNb2RlICovIChjKSwgY21vZGUpOyB9KTtcblxuICAgIGlmIChtb2RlLnN0YXJ0cykge1xuICAgICAgY29tcGlsZU1vZGUobW9kZS5zdGFydHMsIHBhcmVudCk7XG4gICAgfVxuXG4gICAgY21vZGUubWF0Y2hlciA9IGJ1aWxkTW9kZVJlZ2V4KGNtb2RlKTtcbiAgICByZXR1cm4gY21vZGU7XG4gIH1cblxuICBpZiAoIWxhbmd1YWdlLmNvbXBpbGVyRXh0ZW5zaW9ucykgbGFuZ3VhZ2UuY29tcGlsZXJFeHRlbnNpb25zID0gW107XG5cbiAgLy8gc2VsZiBpcyBub3QgdmFsaWQgYXQgdGhlIHRvcC1sZXZlbFxuICBpZiAobGFuZ3VhZ2UuY29udGFpbnMgJiYgbGFuZ3VhZ2UuY29udGFpbnMuaW5jbHVkZXMoJ3NlbGYnKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkVSUjogY29udGFpbnMgYHNlbGZgIGlzIG5vdCBzdXBwb3J0ZWQgYXQgdGhlIHRvcC1sZXZlbCBvZiBhIGxhbmd1YWdlLiAgU2VlIGRvY3VtZW50YXRpb24uXCIpO1xuICB9XG5cbiAgLy8gd2UgbmVlZCBhIG51bGwgb2JqZWN0LCB3aGljaCBpbmhlcml0IHdpbGwgZ3VhcmFudGVlXG4gIGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXMgPSBpbmhlcml0JDEobGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlcyB8fCB7fSk7XG5cbiAgcmV0dXJuIGNvbXBpbGVNb2RlKC8qKiBAdHlwZSBNb2RlICovIChsYW5ndWFnZSkpO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBtb2RlIGhhcyBhIGRlcGVuZGVuY3kgb24gaXQncyBwYXJlbnQgb3Igbm90XG4gKlxuICogSWYgYSBtb2RlIGRvZXMgaGF2ZSBhIHBhcmVudCBkZXBlbmRlbmN5IHRoZW4gb2Z0ZW4gd2UgbmVlZCB0byBjbG9uZSBpdCBpZlxuICogaXQncyB1c2VkIGluIG11bHRpcGxlIHBsYWNlcyBzbyB0aGF0IGVhY2ggY29weSBwb2ludHMgdG8gdGhlIGNvcnJlY3QgcGFyZW50LFxuICogd2hlcmUtYXMgbW9kZXMgd2l0aG91dCBhIHBhcmVudCBjYW4gb2Z0ZW4gc2FmZWx5IGJlIHJlLXVzZWQgYXQgdGhlIGJvdHRvbSBvZlxuICogYSBtb2RlIGNoYWluLlxuICpcbiAqIEBwYXJhbSB7TW9kZSB8IG51bGx9IG1vZGVcbiAqIEByZXR1cm5zIHtib29sZWFufSAtIGlzIHRoZXJlIGEgZGVwZW5kZW5jeSBvbiB0aGUgcGFyZW50P1xuICogKi9cbmZ1bmN0aW9uIGRlcGVuZGVuY3lPblBhcmVudChtb2RlKSB7XG4gIGlmICghbW9kZSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiBtb2RlLmVuZHNXaXRoUGFyZW50IHx8IGRlcGVuZGVuY3lPblBhcmVudChtb2RlLnN0YXJ0cyk7XG59XG5cbi8qKlxuICogRXhwYW5kcyBhIG1vZGUgb3IgY2xvbmVzIGl0IGlmIG5lY2Vzc2FyeVxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGZvciBtb2RlcyB3aXRoIHBhcmVudGFsIGRlcGVuZGVuY2VpcyAoc2VlIG5vdGVzIG9uXG4gKiBgZGVwZW5kZW5jeU9uUGFyZW50YCkgYW5kIGZvciBub2RlcyB0aGF0IGhhdmUgYHZhcmlhbnRzYCAtIHdoaWNoIG11c3QgdGhlbiBiZVxuICogZXhwbG9kZWQgaW50byB0aGVpciBvd24gaW5kaXZpZHVhbCBtb2RlcyBhdCBjb21waWxlIHRpbWUuXG4gKlxuICogQHBhcmFtIHtNb2RlfSBtb2RlXG4gKiBAcmV0dXJucyB7TW9kZSB8IE1vZGVbXX1cbiAqICovXG5mdW5jdGlvbiBleHBhbmRPckNsb25lTW9kZShtb2RlKSB7XG4gIGlmIChtb2RlLnZhcmlhbnRzICYmICFtb2RlLmNhY2hlZFZhcmlhbnRzKSB7XG4gICAgbW9kZS5jYWNoZWRWYXJpYW50cyA9IG1vZGUudmFyaWFudHMubWFwKGZ1bmN0aW9uKHZhcmlhbnQpIHtcbiAgICAgIHJldHVybiBpbmhlcml0JDEobW9kZSwgeyB2YXJpYW50czogbnVsbCB9LCB2YXJpYW50KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIEVYUEFORFxuICAvLyBpZiB3ZSBoYXZlIHZhcmlhbnRzIHRoZW4gZXNzZW50aWFsbHkgXCJyZXBsYWNlXCIgdGhlIG1vZGUgd2l0aCB0aGUgdmFyaWFudHNcbiAgLy8gdGhpcyBoYXBwZW5zIGluIGNvbXBpbGVNb2RlLCB3aGVyZSB0aGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBmcm9tXG4gIGlmIChtb2RlLmNhY2hlZFZhcmlhbnRzKSB7XG4gICAgcmV0dXJuIG1vZGUuY2FjaGVkVmFyaWFudHM7XG4gIH1cblxuICAvLyBDTE9ORVxuICAvLyBpZiB3ZSBoYXZlIGRlcGVuZGVuY2llcyBvbiBwYXJlbnRzIHRoZW4gd2UgbmVlZCBhIHVuaXF1ZVxuICAvLyBpbnN0YW5jZSBvZiBvdXJzZWx2ZXMsIHNvIHdlIGNhbiBiZSByZXVzZWQgd2l0aCBtYW55XG4gIC8vIGRpZmZlcmVudCBwYXJlbnRzIHdpdGhvdXQgaXNzdWVcbiAgaWYgKGRlcGVuZGVuY3lPblBhcmVudChtb2RlKSkge1xuICAgIHJldHVybiBpbmhlcml0JDEobW9kZSwgeyBzdGFydHM6IG1vZGUuc3RhcnRzID8gaW5oZXJpdCQxKG1vZGUuc3RhcnRzKSA6IG51bGwgfSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmlzRnJvemVuKG1vZGUpKSB7XG4gICAgcmV0dXJuIGluaGVyaXQkMShtb2RlKTtcbiAgfVxuXG4gIC8vIG5vIHNwZWNpYWwgZGVwZW5kZW5jeSBpc3N1ZXMsIGp1c3QgcmV0dXJuIG91cnNlbHZlc1xuICByZXR1cm4gbW9kZTtcbn1cblxudmFyIHZlcnNpb24gPSBcIjExLjkuMFwiO1xuXG5jbGFzcyBIVE1MSW5qZWN0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHJlYXNvbiwgaHRtbCkge1xuICAgIHN1cGVyKHJlYXNvbik7XG4gICAgdGhpcy5uYW1lID0gXCJIVE1MSW5qZWN0aW9uRXJyb3JcIjtcbiAgICB0aGlzLmh0bWwgPSBodG1sO1xuICB9XG59XG5cbi8qXG5TeW50YXggaGlnaGxpZ2h0aW5nIHdpdGggbGFuZ3VhZ2UgYXV0b2RldGVjdGlvbi5cbmh0dHBzOi8vaGlnaGxpZ2h0anMub3JnL1xuKi9cblxuXG5cbi8qKlxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuTW9kZX0gTW9kZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuQ29tcGlsZWRNb2RlfSBDb21waWxlZE1vZGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkNvbXBpbGVkU2NvcGV9IENvbXBpbGVkU2NvcGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkxhbmd1YWdlfSBMYW5ndWFnZVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU0FwaX0gSExKU0FwaVxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuSExKU1BsdWdpbn0gSExKU1BsdWdpblxuQHR5cGVkZWYge2ltcG9ydCgnaGlnaGxpZ2h0LmpzJykuUGx1Z2luRXZlbnR9IFBsdWdpbkV2ZW50XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5ITEpTT3B0aW9uc30gSExKU09wdGlvbnNcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkxhbmd1YWdlRm59IExhbmd1YWdlRm5cbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkhpZ2hsaWdodGVkSFRNTEVsZW1lbnR9IEhpZ2hsaWdodGVkSFRNTEVsZW1lbnRcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcycpLkJlZm9yZUhpZ2hsaWdodENvbnRleHR9IEJlZm9yZUhpZ2hsaWdodENvbnRleHRcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcy9wcml2YXRlJykuTWF0Y2hUeXBlfSBNYXRjaFR5cGVcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcy9wcml2YXRlJykuS2V5d29yZERhdGF9IEtleXdvcmREYXRhXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMvcHJpdmF0ZScpLkVuaGFuY2VkTWF0Y2h9IEVuaGFuY2VkTWF0Y2hcbkB0eXBlZGVmIHtpbXBvcnQoJ2hpZ2hsaWdodC5qcy9wcml2YXRlJykuQW5ub3RhdGVkRXJyb3J9IEFubm90YXRlZEVycm9yXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5BdXRvSGlnaGxpZ2h0UmVzdWx0fSBBdXRvSGlnaGxpZ2h0UmVzdWx0XG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5IaWdobGlnaHRPcHRpb25zfSBIaWdobGlnaHRPcHRpb25zXG5AdHlwZWRlZiB7aW1wb3J0KCdoaWdobGlnaHQuanMnKS5IaWdobGlnaHRSZXN1bHR9IEhpZ2hsaWdodFJlc3VsdFxuKi9cblxuXG5jb25zdCBlc2NhcGUgPSBlc2NhcGVIVE1MO1xuY29uc3QgaW5oZXJpdCA9IGluaGVyaXQkMTtcbmNvbnN0IE5PX01BVENIID0gU3ltYm9sKFwibm9tYXRjaFwiKTtcbmNvbnN0IE1BWF9LRVlXT1JEX0hJVFMgPSA3O1xuXG4vKipcbiAqIEBwYXJhbSB7YW55fSBobGpzIC0gb2JqZWN0IHRoYXQgaXMgZXh0ZW5kZWQgKGxlZ2FjeSlcbiAqIEByZXR1cm5zIHtITEpTQXBpfVxuICovXG5jb25zdCBITEpTID0gZnVuY3Rpb24oaGxqcykge1xuICAvLyBHbG9iYWwgaW50ZXJuYWwgdmFyaWFibGVzIHVzZWQgd2l0aGluIHRoZSBoaWdobGlnaHQuanMgbGlicmFyeS5cbiAgLyoqIEB0eXBlIHtSZWNvcmQ8c3RyaW5nLCBMYW5ndWFnZT59ICovXG4gIGNvbnN0IGxhbmd1YWdlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8qKiBAdHlwZSB7UmVjb3JkPHN0cmluZywgc3RyaW5nPn0gKi9cbiAgY29uc3QgYWxpYXNlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8qKiBAdHlwZSB7SExKU1BsdWdpbltdfSAqL1xuICBjb25zdCBwbHVnaW5zID0gW107XG5cbiAgLy8gc2FmZS9wcm9kdWN0aW9uIG1vZGUgLSBzd2FsbG93cyBtb3JlIGVycm9ycywgdHJpZXMgdG8ga2VlcCBydW5uaW5nXG4gIC8vIGV2ZW4gaWYgYSBzaW5nbGUgc3ludGF4IG9yIHBhcnNlIGhpdHMgYSBmYXRhbCBlcnJvclxuICBsZXQgU0FGRV9NT0RFID0gdHJ1ZTtcbiAgY29uc3QgTEFOR1VBR0VfTk9UX0ZPVU5EID0gXCJDb3VsZCBub3QgZmluZCB0aGUgbGFuZ3VhZ2UgJ3t9JywgZGlkIHlvdSBmb3JnZXQgdG8gbG9hZC9pbmNsdWRlIGEgbGFuZ3VhZ2UgbW9kdWxlP1wiO1xuICAvKiogQHR5cGUge0xhbmd1YWdlfSAqL1xuICBjb25zdCBQTEFJTlRFWFRfTEFOR1VBR0UgPSB7IGRpc2FibGVBdXRvZGV0ZWN0OiB0cnVlLCBuYW1lOiAnUGxhaW4gdGV4dCcsIGNvbnRhaW5zOiBbXSB9O1xuXG4gIC8vIEdsb2JhbCBvcHRpb25zIHVzZWQgd2hlbiB3aXRoaW4gZXh0ZXJuYWwgQVBJcy4gVGhpcyBpcyBtb2RpZmllZCB3aGVuXG4gIC8vIGNhbGxpbmcgdGhlIGBobGpzLmNvbmZpZ3VyZWAgZnVuY3Rpb24uXG4gIC8qKiBAdHlwZSBITEpTT3B0aW9ucyAqL1xuICBsZXQgb3B0aW9ucyA9IHtcbiAgICBpZ25vcmVVbmVzY2FwZWRIVE1MOiBmYWxzZSxcbiAgICB0aHJvd1VuZXNjYXBlZEhUTUw6IGZhbHNlLFxuICAgIG5vSGlnaGxpZ2h0UmU6IC9eKG5vLT9oaWdobGlnaHQpJC9pLFxuICAgIGxhbmd1YWdlRGV0ZWN0UmU6IC9cXGJsYW5nKD86dWFnZSk/LShbXFx3LV0rKVxcYi9pLFxuICAgIGNsYXNzUHJlZml4OiAnaGxqcy0nLFxuICAgIGNzc1NlbGVjdG9yOiAncHJlIGNvZGUnLFxuICAgIGxhbmd1YWdlczogbnVsbCxcbiAgICAvLyBiZXRhIGNvbmZpZ3VyYXRpb24gb3B0aW9ucywgc3ViamVjdCB0byBjaGFuZ2UsIHdlbGNvbWUgdG8gZGlzY3Vzc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzEwODZcbiAgICBfX2VtaXR0ZXI6IFRva2VuVHJlZUVtaXR0ZXJcbiAgfTtcblxuICAvKiBVdGlsaXR5IGZ1bmN0aW9ucyAqL1xuXG4gIC8qKlxuICAgKiBUZXN0cyBhIGxhbmd1YWdlIG5hbWUgdG8gc2VlIGlmIGhpZ2hsaWdodGluZyBzaG91bGQgYmUgc2tpcHBlZFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VOYW1lXG4gICAqL1xuICBmdW5jdGlvbiBzaG91bGROb3RIaWdobGlnaHQobGFuZ3VhZ2VOYW1lKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubm9IaWdobGlnaHRSZS50ZXN0KGxhbmd1YWdlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBibG9jayAtIHRoZSBIVE1MIGVsZW1lbnQgdG8gZGV0ZXJtaW5lIGxhbmd1YWdlIGZvclxuICAgKi9cbiAgZnVuY3Rpb24gYmxvY2tMYW5ndWFnZShibG9jaykge1xuICAgIGxldCBjbGFzc2VzID0gYmxvY2suY2xhc3NOYW1lICsgJyAnO1xuXG4gICAgY2xhc3NlcyArPSBibG9jay5wYXJlbnROb2RlID8gYmxvY2sucGFyZW50Tm9kZS5jbGFzc05hbWUgOiAnJztcblxuICAgIC8vIGxhbmd1YWdlLSogdGFrZXMgcHJlY2VkZW5jZSBvdmVyIG5vbi1wcmVmaXhlZCBjbGFzcyBuYW1lcy5cbiAgICBjb25zdCBtYXRjaCA9IG9wdGlvbnMubGFuZ3VhZ2VEZXRlY3RSZS5leGVjKGNsYXNzZXMpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgY29uc3QgbGFuZ3VhZ2UgPSBnZXRMYW5ndWFnZShtYXRjaFsxXSk7XG4gICAgICBpZiAoIWxhbmd1YWdlKSB7XG4gICAgICAgIHdhcm4oTEFOR1VBR0VfTk9UX0ZPVU5ELnJlcGxhY2UoXCJ7fVwiLCBtYXRjaFsxXSkpO1xuICAgICAgICB3YXJuKFwiRmFsbGluZyBiYWNrIHRvIG5vLWhpZ2hsaWdodCBtb2RlIGZvciB0aGlzIGJsb2NrLlwiLCBibG9jayk7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGFuZ3VhZ2UgPyBtYXRjaFsxXSA6ICduby1oaWdobGlnaHQnO1xuICAgIH1cblxuICAgIHJldHVybiBjbGFzc2VzXG4gICAgICAuc3BsaXQoL1xccysvKVxuICAgICAgLmZpbmQoKF9jbGFzcykgPT4gc2hvdWxkTm90SGlnaGxpZ2h0KF9jbGFzcykgfHwgZ2V0TGFuZ3VhZ2UoX2NsYXNzKSk7XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBoaWdobGlnaHRpbmcgZnVuY3Rpb24uXG4gICAqXG4gICAqIE9MRCBBUElcbiAgICogaGlnaGxpZ2h0KGxhbmcsIGNvZGUsIGlnbm9yZUlsbGVnYWxzLCBjb250aW51YXRpb24pXG4gICAqXG4gICAqIE5FVyBBUElcbiAgICogaGlnaGxpZ2h0KGNvZGUsIHtsYW5nLCBpZ25vcmVJbGxlZ2Fsc30pXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlT3JMYW5ndWFnZU5hbWUgLSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBoaWdobGlnaHRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmcgfCBIaWdobGlnaHRPcHRpb25zfSBvcHRpb25zT3JDb2RlIC0gdGhlIGNvZGUgdG8gaGlnaGxpZ2h0XG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lnbm9yZUlsbGVnYWxzXSAtIHdoZXRoZXIgdG8gaWdub3JlIGlsbGVnYWwgbWF0Y2hlcywgZGVmYXVsdCBpcyB0byBiYWlsXG4gICAqXG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9IFJlc3VsdCAtIGFuIG9iamVjdCB0aGF0IHJlcHJlc2VudHMgdGhlIHJlc3VsdFxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gbGFuZ3VhZ2UgLSB0aGUgbGFuZ3VhZ2UgbmFtZVxuICAgKiBAcHJvcGVydHkge251bWJlcn0gcmVsZXZhbmNlIC0gdGhlIHJlbGV2YW5jZSBzY29yZVxuICAgKiBAcHJvcGVydHkge3N0cmluZ30gdmFsdWUgLSB0aGUgaGlnaGxpZ2h0ZWQgSFRNTCBjb2RlXG4gICAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBjb2RlIC0gdGhlIG9yaWdpbmFsIHJhdyBjb2RlXG4gICAqIEBwcm9wZXJ0eSB7Q29tcGlsZWRNb2RlfSB0b3AgLSB0b3Agb2YgdGhlIGN1cnJlbnQgbW9kZSBzdGFja1xuICAgKiBAcHJvcGVydHkge2Jvb2xlYW59IGlsbGVnYWwgLSBpbmRpY2F0ZXMgd2hldGhlciBhbnkgaWxsZWdhbCBtYXRjaGVzIHdlcmUgZm91bmRcbiAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0KGNvZGVPckxhbmd1YWdlTmFtZSwgb3B0aW9uc09yQ29kZSwgaWdub3JlSWxsZWdhbHMpIHtcbiAgICBsZXQgY29kZSA9IFwiXCI7XG4gICAgbGV0IGxhbmd1YWdlTmFtZSA9IFwiXCI7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zT3JDb2RlID09PSBcIm9iamVjdFwiKSB7XG4gICAgICBjb2RlID0gY29kZU9yTGFuZ3VhZ2VOYW1lO1xuICAgICAgaWdub3JlSWxsZWdhbHMgPSBvcHRpb25zT3JDb2RlLmlnbm9yZUlsbGVnYWxzO1xuICAgICAgbGFuZ3VhZ2VOYW1lID0gb3B0aW9uc09yQ29kZS5sYW5ndWFnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gb2xkIEFQSVxuICAgICAgZGVwcmVjYXRlZChcIjEwLjcuMFwiLCBcImhpZ2hsaWdodChsYW5nLCBjb2RlLCAuLi5hcmdzKSBoYXMgYmVlbiBkZXByZWNhdGVkLlwiKTtcbiAgICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJQbGVhc2UgdXNlIGhpZ2hsaWdodChjb2RlLCBvcHRpb25zKSBpbnN0ZWFkLlxcbmh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzIyNzdcIik7XG4gICAgICBsYW5ndWFnZU5hbWUgPSBjb2RlT3JMYW5ndWFnZU5hbWU7XG4gICAgICBjb2RlID0gb3B0aW9uc09yQ29kZTtcbiAgICB9XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8zMTQ5XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmaW5lZFxuICAgIGlmIChpZ25vcmVJbGxlZ2FscyA9PT0gdW5kZWZpbmVkKSB7IGlnbm9yZUlsbGVnYWxzID0gdHJ1ZTsgfVxuXG4gICAgLyoqIEB0eXBlIHtCZWZvcmVIaWdobGlnaHRDb250ZXh0fSAqL1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb2RlLFxuICAgICAgbGFuZ3VhZ2U6IGxhbmd1YWdlTmFtZVxuICAgIH07XG4gICAgLy8gdGhlIHBsdWdpbiBjYW4gY2hhbmdlIHRoZSBkZXNpcmVkIGxhbmd1YWdlIG9yIHRoZSBjb2RlIHRvIGJlIGhpZ2hsaWdodGVkXG4gICAgLy8ganVzdCBiZSBjaGFuZ2luZyB0aGUgb2JqZWN0IGl0IHdhcyBwYXNzZWRcbiAgICBmaXJlKFwiYmVmb3JlOmhpZ2hsaWdodFwiLCBjb250ZXh0KTtcblxuICAgIC8vIGEgYmVmb3JlIHBsdWdpbiBjYW4gdXN1cnAgdGhlIHJlc3VsdCBjb21wbGV0ZWx5IGJ5IHByb3ZpZGluZyBpdCdzIG93blxuICAgIC8vIGluIHdoaWNoIGNhc2Ugd2UgZG9uJ3QgZXZlbiBuZWVkIHRvIGNhbGwgaGlnaGxpZ2h0XG4gICAgY29uc3QgcmVzdWx0ID0gY29udGV4dC5yZXN1bHRcbiAgICAgID8gY29udGV4dC5yZXN1bHRcbiAgICAgIDogX2hpZ2hsaWdodChjb250ZXh0Lmxhbmd1YWdlLCBjb250ZXh0LmNvZGUsIGlnbm9yZUlsbGVnYWxzKTtcblxuICAgIHJlc3VsdC5jb2RlID0gY29udGV4dC5jb2RlO1xuICAgIC8vIHRoZSBwbHVnaW4gY2FuIGNoYW5nZSBhbnl0aGluZyBpbiByZXN1bHQgdG8gc3VpdGUgaXRcbiAgICBmaXJlKFwiYWZ0ZXI6aGlnaGxpZ2h0XCIsIHJlc3VsdCk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIHByaXZhdGUgaGlnaGxpZ2h0IHRoYXQncyB1c2VkIGludGVybmFsbHkgYW5kIGRvZXMgbm90IGZpcmUgY2FsbGJhY2tzXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWUgLSB0aGUgbGFuZ3VhZ2UgdG8gdXNlIGZvciBoaWdobGlnaHRpbmdcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNvZGVUb0hpZ2hsaWdodCAtIHRoZSBjb2RlIHRvIGhpZ2hsaWdodFxuICAgKiBAcGFyYW0ge2Jvb2xlYW4/fSBbaWdub3JlSWxsZWdhbHNdIC0gd2hldGhlciB0byBpZ25vcmUgaWxsZWdhbCBtYXRjaGVzLCBkZWZhdWx0IGlzIHRvIGJhaWxcbiAgICogQHBhcmFtIHtDb21waWxlZE1vZGU/fSBbY29udGludWF0aW9uXSAtIGN1cnJlbnQgY29udGludWF0aW9uIG1vZGUsIGlmIGFueVxuICAgKiBAcmV0dXJucyB7SGlnaGxpZ2h0UmVzdWx0fSAtIHJlc3VsdCBvZiB0aGUgaGlnaGxpZ2h0IG9wZXJhdGlvblxuICAqL1xuICBmdW5jdGlvbiBfaGlnaGxpZ2h0KGxhbmd1YWdlTmFtZSwgY29kZVRvSGlnaGxpZ2h0LCBpZ25vcmVJbGxlZ2FscywgY29udGludWF0aW9uKSB7XG4gICAgY29uc3Qga2V5d29yZEhpdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuXG4gICAgLyoqXG4gICAgICogUmV0dXJuIGtleXdvcmQgZGF0YSBpZiBhIG1hdGNoIGlzIGEga2V5d29yZFxuICAgICAqIEBwYXJhbSB7Q29tcGlsZWRNb2RlfSBtb2RlIC0gY3VycmVudCBtb2RlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1hdGNoVGV4dCAtIHRoZSB0ZXh0dWFsIG1hdGNoXG4gICAgICogQHJldHVybnMge0tleXdvcmREYXRhIHwgZmFsc2V9XG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5d29yZERhdGEobW9kZSwgbWF0Y2hUZXh0KSB7XG4gICAgICByZXR1cm4gbW9kZS5rZXl3b3Jkc1ttYXRjaFRleHRdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NLZXl3b3JkcygpIHtcbiAgICAgIGlmICghdG9wLmtleXdvcmRzKSB7XG4gICAgICAgIGVtaXR0ZXIuYWRkVGV4dChtb2RlQnVmZmVyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgbGFzdEluZGV4ID0gMDtcbiAgICAgIHRvcC5rZXl3b3JkUGF0dGVyblJlLmxhc3RJbmRleCA9IDA7XG4gICAgICBsZXQgbWF0Y2ggPSB0b3Aua2V5d29yZFBhdHRlcm5SZS5leGVjKG1vZGVCdWZmZXIpO1xuICAgICAgbGV0IGJ1ZiA9IFwiXCI7XG5cbiAgICAgIHdoaWxlIChtYXRjaCkge1xuICAgICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHJpbmcobGFzdEluZGV4LCBtYXRjaC5pbmRleCk7XG4gICAgICAgIGNvbnN0IHdvcmQgPSBsYW5ndWFnZS5jYXNlX2luc2Vuc2l0aXZlID8gbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSA6IG1hdGNoWzBdO1xuICAgICAgICBjb25zdCBkYXRhID0ga2V5d29yZERhdGEodG9wLCB3b3JkKTtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICBjb25zdCBba2luZCwga2V5d29yZFJlbGV2YW5jZV0gPSBkYXRhO1xuICAgICAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgICAgICAgIGJ1ZiA9IFwiXCI7XG5cbiAgICAgICAgICBrZXl3b3JkSGl0c1t3b3JkXSA9IChrZXl3b3JkSGl0c1t3b3JkXSB8fCAwKSArIDE7XG4gICAgICAgICAgaWYgKGtleXdvcmRIaXRzW3dvcmRdIDw9IE1BWF9LRVlXT1JEX0hJVFMpIHJlbGV2YW5jZSArPSBrZXl3b3JkUmVsZXZhbmNlO1xuICAgICAgICAgIGlmIChraW5kLnN0YXJ0c1dpdGgoXCJfXCIpKSB7XG4gICAgICAgICAgICAvLyBfIGltcGxpZWQgZm9yIHJlbGV2YW5jZSBvbmx5LCBkbyBub3QgaGlnaGxpZ2h0XG4gICAgICAgICAgICAvLyBieSBhcHBseWluZyBhIGNsYXNzIG5hbWVcbiAgICAgICAgICAgIGJ1ZiArPSBtYXRjaFswXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY3NzQ2xhc3MgPSBsYW5ndWFnZS5jbGFzc05hbWVBbGlhc2VzW2tpbmRdIHx8IGtpbmQ7XG4gICAgICAgICAgICBlbWl0S2V5d29yZChtYXRjaFswXSwgY3NzQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBidWYgKz0gbWF0Y2hbMF07XG4gICAgICAgIH1cbiAgICAgICAgbGFzdEluZGV4ID0gdG9wLmtleXdvcmRQYXR0ZXJuUmUubGFzdEluZGV4O1xuICAgICAgICBtYXRjaCA9IHRvcC5rZXl3b3JkUGF0dGVyblJlLmV4ZWMobW9kZUJ1ZmZlcik7XG4gICAgICB9XG4gICAgICBidWYgKz0gbW9kZUJ1ZmZlci5zdWJzdHJpbmcobGFzdEluZGV4KTtcbiAgICAgIGVtaXR0ZXIuYWRkVGV4dChidWYpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NTdWJMYW5ndWFnZSgpIHtcbiAgICAgIGlmIChtb2RlQnVmZmVyID09PSBcIlwiKSByZXR1cm47XG4gICAgICAvKiogQHR5cGUgSGlnaGxpZ2h0UmVzdWx0ICovXG4gICAgICBsZXQgcmVzdWx0ID0gbnVsbDtcblxuICAgICAgaWYgKHR5cGVvZiB0b3Auc3ViTGFuZ3VhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmICghbGFuZ3VhZ2VzW3RvcC5zdWJMYW5ndWFnZV0pIHtcbiAgICAgICAgICBlbWl0dGVyLmFkZFRleHQobW9kZUJ1ZmZlcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IF9oaWdobGlnaHQodG9wLnN1Ykxhbmd1YWdlLCBtb2RlQnVmZmVyLCB0cnVlLCBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0pO1xuICAgICAgICBjb250aW51YXRpb25zW3RvcC5zdWJMYW5ndWFnZV0gPSAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi8gKHJlc3VsdC5fdG9wKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IGhpZ2hsaWdodEF1dG8obW9kZUJ1ZmZlciwgdG9wLnN1Ykxhbmd1YWdlLmxlbmd0aCA/IHRvcC5zdWJMYW5ndWFnZSA6IG51bGwpO1xuICAgICAgfVxuXG4gICAgICAvLyBDb3VudGluZyBlbWJlZGRlZCBsYW5ndWFnZSBzY29yZSB0b3dhcmRzIHRoZSBob3N0IGxhbmd1YWdlIG1heSBiZSBkaXNhYmxlZFxuICAgICAgLy8gd2l0aCB6ZXJvaW5nIHRoZSBjb250YWluaW5nIG1vZGUgcmVsZXZhbmNlLiBVc2UgY2FzZSBpbiBwb2ludCBpcyBNYXJrZG93biB0aGF0XG4gICAgICAvLyBhbGxvd3MgWE1MIGV2ZXJ5d2hlcmUgYW5kIG1ha2VzIGV2ZXJ5IFhNTCBzbmlwcGV0IHRvIGhhdmUgYSBtdWNoIGxhcmdlciBNYXJrZG93blxuICAgICAgLy8gc2NvcmUuXG4gICAgICBpZiAodG9wLnJlbGV2YW5jZSA+IDApIHtcbiAgICAgICAgcmVsZXZhbmNlICs9IHJlc3VsdC5yZWxldmFuY2U7XG4gICAgICB9XG4gICAgICBlbWl0dGVyLl9fYWRkU3VibGFuZ3VhZ2UocmVzdWx0Ll9lbWl0dGVyLCByZXN1bHQubGFuZ3VhZ2UpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHByb2Nlc3NCdWZmZXIoKSB7XG4gICAgICBpZiAodG9wLnN1Ykxhbmd1YWdlICE9IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc1N1Ykxhbmd1YWdlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzS2V5d29yZHMoKTtcbiAgICAgIH1cbiAgICAgIG1vZGVCdWZmZXIgPSAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzY29wZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVtaXRLZXl3b3JkKGtleXdvcmQsIHNjb3BlKSB7XG4gICAgICBpZiAoa2V5d29yZCA9PT0gXCJcIikgcmV0dXJuO1xuXG4gICAgICBlbWl0dGVyLnN0YXJ0U2NvcGUoc2NvcGUpO1xuICAgICAgZW1pdHRlci5hZGRUZXh0KGtleXdvcmQpO1xuICAgICAgZW1pdHRlci5lbmRTY29wZSgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7Q29tcGlsZWRTY29wZX0gc2NvcGVcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW1pdE11bHRpQ2xhc3Moc2NvcGUsIG1hdGNoKSB7XG4gICAgICBsZXQgaSA9IDE7XG4gICAgICBjb25zdCBtYXggPSBtYXRjaC5sZW5ndGggLSAxO1xuICAgICAgd2hpbGUgKGkgPD0gbWF4KSB7XG4gICAgICAgIGlmICghc2NvcGUuX2VtaXRbaV0pIHsgaSsrOyBjb250aW51ZTsgfVxuICAgICAgICBjb25zdCBrbGFzcyA9IGxhbmd1YWdlLmNsYXNzTmFtZUFsaWFzZXNbc2NvcGVbaV1dIHx8IHNjb3BlW2ldO1xuICAgICAgICBjb25zdCB0ZXh0ID0gbWF0Y2hbaV07XG4gICAgICAgIGlmIChrbGFzcykge1xuICAgICAgICAgIGVtaXRLZXl3b3JkKHRleHQsIGtsYXNzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gdGV4dDtcbiAgICAgICAgICBwcm9jZXNzS2V5d29yZHMoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGV9IG1vZGUgLSBuZXcgbW9kZSB0byBzdGFydFxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFydE5ld01vZGUobW9kZSwgbWF0Y2gpIHtcbiAgICAgIGlmIChtb2RlLnNjb3BlICYmIHR5cGVvZiBtb2RlLnNjb3BlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGVtaXR0ZXIub3Blbk5vZGUobGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLnNjb3BlXSB8fCBtb2RlLnNjb3BlKTtcbiAgICAgIH1cbiAgICAgIGlmIChtb2RlLmJlZ2luU2NvcGUpIHtcbiAgICAgICAgLy8gYmVnaW5TY29wZSBqdXN0IHdyYXBzIHRoZSBiZWdpbiBtYXRjaCBpdHNlbGYgaW4gYSBzY29wZVxuICAgICAgICBpZiAobW9kZS5iZWdpblNjb3BlLl93cmFwKSB7XG4gICAgICAgICAgZW1pdEtleXdvcmQobW9kZUJ1ZmZlciwgbGFuZ3VhZ2UuY2xhc3NOYW1lQWxpYXNlc1ttb2RlLmJlZ2luU2NvcGUuX3dyYXBdIHx8IG1vZGUuYmVnaW5TY29wZS5fd3JhcCk7XG4gICAgICAgICAgbW9kZUJ1ZmZlciA9IFwiXCI7XG4gICAgICAgIH0gZWxzZSBpZiAobW9kZS5iZWdpblNjb3BlLl9tdWx0aSkge1xuICAgICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgbW9kZUJ1ZmZlciBzaG91bGQganVzdCBiZSB0aGUgbWF0Y2hcbiAgICAgICAgICBlbWl0TXVsdGlDbGFzcyhtb2RlLmJlZ2luU2NvcGUsIG1hdGNoKTtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b3AgPSBPYmplY3QuY3JlYXRlKG1vZGUsIHsgcGFyZW50OiB7IHZhbHVlOiB0b3AgfSB9KTtcbiAgICAgIHJldHVybiB0b3A7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtDb21waWxlZE1vZGUgfSBtb2RlIC0gdGhlIG1vZGUgdG8gcG90ZW50aWFsbHkgZW5kXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaCAtIHRoZSBsYXRlc3QgbWF0Y2hcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWF0Y2hQbHVzUmVtYWluZGVyIC0gbWF0Y2ggcGx1cyByZW1haW5kZXIgb2YgY29udGVudFxuICAgICAqIEByZXR1cm5zIHtDb21waWxlZE1vZGUgfCB2b2lkfSAtIHRoZSBuZXh0IG1vZGUsIG9yIGlmIHZvaWQgY29udGludWUgb24gaW4gY3VycmVudCBtb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kT2ZNb2RlKG1vZGUsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpIHtcbiAgICAgIGxldCBtYXRjaGVkID0gc3RhcnRzV2l0aChtb2RlLmVuZFJlLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuXG4gICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICBpZiAobW9kZVtcIm9uOmVuZFwiXSkge1xuICAgICAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobW9kZSk7XG4gICAgICAgICAgbW9kZVtcIm9uOmVuZFwiXShtYXRjaCwgcmVzcCk7XG4gICAgICAgICAgaWYgKHJlc3AuaXNNYXRjaElnbm9yZWQpIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtYXRjaGVkKSB7XG4gICAgICAgICAgd2hpbGUgKG1vZGUuZW5kc1BhcmVudCAmJiBtb2RlLnBhcmVudCkge1xuICAgICAgICAgICAgbW9kZSA9IG1vZGUucGFyZW50O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbW9kZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gZXZlbiBpZiBvbjplbmQgZmlyZXMgYW4gYGlnbm9yZWAgaXQncyBzdGlsbCBwb3NzaWJsZVxuICAgICAgLy8gdGhhdCB3ZSBtaWdodCB0cmlnZ2VyIHRoZSBlbmQgbm9kZSBiZWNhdXNlIG9mIGEgcGFyZW50IG1vZGVcbiAgICAgIGlmIChtb2RlLmVuZHNXaXRoUGFyZW50KSB7XG4gICAgICAgIHJldHVybiBlbmRPZk1vZGUobW9kZS5wYXJlbnQsIG1hdGNoLCBtYXRjaFBsdXNSZW1haW5kZXIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSBtYXRjaGluZyBidXQgdGhlbiBpZ25vcmluZyBhIHNlcXVlbmNlIG9mIHRleHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBsZXhlbWUgLSBzdHJpbmcgY29udGFpbmluZyBmdWxsIG1hdGNoIHRleHRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0lnbm9yZShsZXhlbWUpIHtcbiAgICAgIGlmICh0b3AubWF0Y2hlci5yZWdleEluZGV4ID09PSAwKSB7XG4gICAgICAgIC8vIG5vIG1vcmUgcmVnZXhlcyB0byBwb3RlbnRpYWxseSBtYXRjaCBoZXJlLCBzbyB3ZSBtb3ZlIHRoZSBjdXJzb3IgZm9yd2FyZCBvbmVcbiAgICAgICAgLy8gc3BhY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWVbMF07XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbm8gbmVlZCB0byBtb3ZlIHRoZSBjdXJzb3IsIHdlIHN0aWxsIGhhdmUgYWRkaXRpb25hbCByZWdleGVzIHRvIHRyeSBhbmRcbiAgICAgICAgLy8gbWF0Y2ggYXQgdGhpcyB2ZXJ5IHNwb3RcbiAgICAgICAgcmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSGFuZGxlIHRoZSBzdGFydCBvZiBhIG5ldyBwb3RlbnRpYWwgbW9kZSBtYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHtFbmhhbmNlZE1hdGNofSBtYXRjaCAtIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICogQHJldHVybnMge251bWJlcn0gaG93IGZhciB0byBhZHZhbmNlIHRoZSBwYXJzZSBjdXJzb3JcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0JlZ2luTWF0Y2gobWF0Y2gpIHtcbiAgICAgIGNvbnN0IGxleGVtZSA9IG1hdGNoWzBdO1xuICAgICAgY29uc3QgbmV3TW9kZSA9IG1hdGNoLnJ1bGU7XG5cbiAgICAgIGNvbnN0IHJlc3AgPSBuZXcgUmVzcG9uc2UobmV3TW9kZSk7XG4gICAgICAvLyBmaXJzdCBpbnRlcm5hbCBiZWZvcmUgY2FsbGJhY2tzLCB0aGVuIHRoZSBwdWJsaWMgb25lc1xuICAgICAgY29uc3QgYmVmb3JlQ2FsbGJhY2tzID0gW25ld01vZGUuX19iZWZvcmVCZWdpbiwgbmV3TW9kZVtcIm9uOmJlZ2luXCJdXTtcbiAgICAgIGZvciAoY29uc3QgY2Igb2YgYmVmb3JlQ2FsbGJhY2tzKSB7XG4gICAgICAgIGlmICghY2IpIGNvbnRpbnVlO1xuICAgICAgICBjYihtYXRjaCwgcmVzcCk7XG4gICAgICAgIGlmIChyZXNwLmlzTWF0Y2hJZ25vcmVkKSByZXR1cm4gZG9JZ25vcmUobGV4ZW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5ld01vZGUuc2tpcCkge1xuICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgKz0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgaWYgKCFuZXdNb2RlLnJldHVybkJlZ2luICYmICFuZXdNb2RlLmV4Y2x1ZGVCZWdpbikge1xuICAgICAgICAgIG1vZGVCdWZmZXIgPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHN0YXJ0TmV3TW9kZShuZXdNb2RlLCBtYXRjaCk7XG4gICAgICByZXR1cm4gbmV3TW9kZS5yZXR1cm5CZWdpbiA/IDAgOiBsZXhlbWUubGVuZ3RoO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEhhbmRsZSB0aGUgcG90ZW50aWFsIGVuZCBvZiBtb2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoIC0gdGhlIGN1cnJlbnQgbWF0Y2hcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkb0VuZE1hdGNoKG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaFswXTtcbiAgICAgIGNvbnN0IG1hdGNoUGx1c1JlbWFpbmRlciA9IGNvZGVUb0hpZ2hsaWdodC5zdWJzdHJpbmcobWF0Y2guaW5kZXgpO1xuXG4gICAgICBjb25zdCBlbmRNb2RlID0gZW5kT2ZNb2RlKHRvcCwgbWF0Y2gsIG1hdGNoUGx1c1JlbWFpbmRlcik7XG4gICAgICBpZiAoIWVuZE1vZGUpIHsgcmV0dXJuIE5PX01BVENIOyB9XG5cbiAgICAgIGNvbnN0IG9yaWdpbiA9IHRvcDtcbiAgICAgIGlmICh0b3AuZW5kU2NvcGUgJiYgdG9wLmVuZFNjb3BlLl93cmFwKSB7XG4gICAgICAgIHByb2Nlc3NCdWZmZXIoKTtcbiAgICAgICAgZW1pdEtleXdvcmQobGV4ZW1lLCB0b3AuZW5kU2NvcGUuX3dyYXApO1xuICAgICAgfSBlbHNlIGlmICh0b3AuZW5kU2NvcGUgJiYgdG9wLmVuZFNjb3BlLl9tdWx0aSkge1xuICAgICAgICBwcm9jZXNzQnVmZmVyKCk7XG4gICAgICAgIGVtaXRNdWx0aUNsYXNzKHRvcC5lbmRTY29wZSwgbWF0Y2gpO1xuICAgICAgfSBlbHNlIGlmIChvcmlnaW4uc2tpcCkge1xuICAgICAgICBtb2RlQnVmZmVyICs9IGxleGVtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghKG9yaWdpbi5yZXR1cm5FbmQgfHwgb3JpZ2luLmV4Y2x1ZGVFbmQpKSB7XG4gICAgICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICBpZiAob3JpZ2luLmV4Y2x1ZGVFbmQpIHtcbiAgICAgICAgICBtb2RlQnVmZmVyID0gbGV4ZW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBkbyB7XG4gICAgICAgIGlmICh0b3Auc2NvcGUpIHtcbiAgICAgICAgICBlbWl0dGVyLmNsb3NlTm9kZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdG9wLnNraXAgJiYgIXRvcC5zdWJMYW5ndWFnZSkge1xuICAgICAgICAgIHJlbGV2YW5jZSArPSB0b3AucmVsZXZhbmNlO1xuICAgICAgICB9XG4gICAgICAgIHRvcCA9IHRvcC5wYXJlbnQ7XG4gICAgICB9IHdoaWxlICh0b3AgIT09IGVuZE1vZGUucGFyZW50KTtcbiAgICAgIGlmIChlbmRNb2RlLnN0YXJ0cykge1xuICAgICAgICBzdGFydE5ld01vZGUoZW5kTW9kZS5zdGFydHMsIG1hdGNoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvcmlnaW4ucmV0dXJuRW5kID8gMCA6IGxleGVtZS5sZW5ndGg7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0NvbnRpbnVhdGlvbnMoKSB7XG4gICAgICBjb25zdCBsaXN0ID0gW107XG4gICAgICBmb3IgKGxldCBjdXJyZW50ID0gdG9wOyBjdXJyZW50ICE9PSBsYW5ndWFnZTsgY3VycmVudCA9IGN1cnJlbnQucGFyZW50KSB7XG4gICAgICAgIGlmIChjdXJyZW50LnNjb3BlKSB7XG4gICAgICAgICAgbGlzdC51bnNoaWZ0KGN1cnJlbnQuc2NvcGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LmZvckVhY2goaXRlbSA9PiBlbWl0dGVyLm9wZW5Ob2RlKGl0ZW0pKTtcbiAgICB9XG5cbiAgICAvKiogQHR5cGUge3t0eXBlPzogTWF0Y2hUeXBlLCBpbmRleD86IG51bWJlciwgcnVsZT86IE1vZGV9fX0gKi9cbiAgICBsZXQgbGFzdE1hdGNoID0ge307XG5cbiAgICAvKipcbiAgICAgKiAgUHJvY2VzcyBhbiBpbmRpdmlkdWFsIG1hdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dEJlZm9yZU1hdGNoIC0gdGV4dCBwcmVjZWRpbmcgdGhlIG1hdGNoIChzaW5jZSB0aGUgbGFzdCBtYXRjaClcbiAgICAgKiBAcGFyYW0ge0VuaGFuY2VkTWF0Y2h9IFttYXRjaF0gLSB0aGUgbWF0Y2ggaXRzZWxmXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xleGVtZSh0ZXh0QmVmb3JlTWF0Y2gsIG1hdGNoKSB7XG4gICAgICBjb25zdCBsZXhlbWUgPSBtYXRjaCAmJiBtYXRjaFswXTtcblxuICAgICAgLy8gYWRkIG5vbi1tYXRjaGVkIHRleHQgdG8gdGhlIGN1cnJlbnQgbW9kZSBidWZmZXJcbiAgICAgIG1vZGVCdWZmZXIgKz0gdGV4dEJlZm9yZU1hdGNoO1xuXG4gICAgICBpZiAobGV4ZW1lID09IG51bGwpIHtcbiAgICAgICAgcHJvY2Vzc0J1ZmZlcigpO1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cblxuICAgICAgLy8gd2UndmUgZm91bmQgYSAwIHdpZHRoIG1hdGNoIGFuZCB3ZSdyZSBzdHVjaywgc28gd2UgbmVlZCB0byBhZHZhbmNlXG4gICAgICAvLyB0aGlzIGhhcHBlbnMgd2hlbiB3ZSBoYXZlIGJhZGx5IGJlaGF2ZWQgcnVsZXMgdGhhdCBoYXZlIG9wdGlvbmFsIG1hdGNoZXJzIHRvIHRoZSBkZWdyZWUgdGhhdFxuICAgICAgLy8gc29tZXRpbWVzIHRoZXkgY2FuIGVuZCB1cCBtYXRjaGluZyBub3RoaW5nIGF0IGFsbFxuICAgICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8yMTQwXG4gICAgICBpZiAobGFzdE1hdGNoLnR5cGUgPT09IFwiYmVnaW5cIiAmJiBtYXRjaC50eXBlID09PSBcImVuZFwiICYmIGxhc3RNYXRjaC5pbmRleCA9PT0gbWF0Y2guaW5kZXggJiYgbGV4ZW1lID09PSBcIlwiKSB7XG4gICAgICAgIC8vIHNwaXQgdGhlIFwic2tpcHBlZFwiIGNoYXJhY3RlciB0aGF0IG91ciByZWdleCBjaG9rZWQgb24gYmFjayBpbnRvIHRoZSBvdXRwdXQgc2VxdWVuY2VcbiAgICAgICAgbW9kZUJ1ZmZlciArPSBjb2RlVG9IaWdobGlnaHQuc2xpY2UobWF0Y2guaW5kZXgsIG1hdGNoLmluZGV4ICsgMSk7XG4gICAgICAgIGlmICghU0FGRV9NT0RFKSB7XG4gICAgICAgICAgLyoqIEB0eXBlIHtBbm5vdGF0ZWRFcnJvcn0gKi9cbiAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYDAgd2lkdGggbWF0Y2ggcmVnZXggKCR7bGFuZ3VhZ2VOYW1lfSlgKTtcbiAgICAgICAgICBlcnIubGFuZ3VhZ2VOYW1lID0gbGFuZ3VhZ2VOYW1lO1xuICAgICAgICAgIGVyci5iYWRSdWxlID0gbGFzdE1hdGNoLnJ1bGU7XG4gICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAxO1xuICAgICAgfVxuICAgICAgbGFzdE1hdGNoID0gbWF0Y2g7XG5cbiAgICAgIGlmIChtYXRjaC50eXBlID09PSBcImJlZ2luXCIpIHtcbiAgICAgICAgcmV0dXJuIGRvQmVnaW5NYXRjaChtYXRjaCk7XG4gICAgICB9IGVsc2UgaWYgKG1hdGNoLnR5cGUgPT09IFwiaWxsZWdhbFwiICYmICFpZ25vcmVJbGxlZ2Fscykge1xuICAgICAgICAvLyBpbGxlZ2FsIG1hdGNoLCB3ZSBkbyBub3QgY29udGludWUgcHJvY2Vzc2luZ1xuICAgICAgICAvKiogQHR5cGUge0Fubm90YXRlZEVycm9yfSAqL1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lsbGVnYWwgbGV4ZW1lIFwiJyArIGxleGVtZSArICdcIiBmb3IgbW9kZSBcIicgKyAodG9wLnNjb3BlIHx8ICc8dW5uYW1lZD4nKSArICdcIicpO1xuICAgICAgICBlcnIubW9kZSA9IHRvcDtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfSBlbHNlIGlmIChtYXRjaC50eXBlID09PSBcImVuZFwiKSB7XG4gICAgICAgIGNvbnN0IHByb2Nlc3NlZCA9IGRvRW5kTWF0Y2gobWF0Y2gpO1xuICAgICAgICBpZiAocHJvY2Vzc2VkICE9PSBOT19NQVRDSCkge1xuICAgICAgICAgIHJldHVybiBwcm9jZXNzZWQ7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZWRnZSBjYXNlIGZvciB3aGVuIGlsbGVnYWwgbWF0Y2hlcyAkIChlbmQgb2YgbGluZSkgd2hpY2ggaXMgdGVjaG5pY2FsbHlcbiAgICAgIC8vIGEgMCB3aWR0aCBtYXRjaCBidXQgbm90IGEgYmVnaW4vZW5kIG1hdGNoIHNvIGl0J3Mgbm90IGNhdWdodCBieSB0aGVcbiAgICAgIC8vIGZpcnN0IGhhbmRsZXIgKHdoZW4gaWdub3JlSWxsZWdhbHMgaXMgdHJ1ZSlcbiAgICAgIGlmIChtYXRjaC50eXBlID09PSBcImlsbGVnYWxcIiAmJiBsZXhlbWUgPT09IFwiXCIpIHtcbiAgICAgICAgLy8gYWR2YW5jZSBzbyB3ZSBhcmVuJ3Qgc3R1Y2sgaW4gYW4gaW5maW5pdGUgbG9vcFxuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cblxuICAgICAgLy8gaW5maW5pdGUgbG9vcHMgYXJlIEJBRCwgdGhpcyBpcyBhIGxhc3QgZGl0Y2ggY2F0Y2ggYWxsLiBpZiB3ZSBoYXZlIGFcbiAgICAgIC8vIGRlY2VudCBudW1iZXIgb2YgaXRlcmF0aW9ucyB5ZXQgb3VyIGluZGV4IChjdXJzb3IgcG9zaXRpb24gaW4gb3VyXG4gICAgICAvLyBwYXJzaW5nKSBzdGlsbCAzeCBiZWhpbmQgb3VyIGluZGV4IHRoZW4gc29tZXRoaW5nIGlzIHZlcnkgd3JvbmdcbiAgICAgIC8vIHNvIHdlIGJhaWxcbiAgICAgIGlmIChpdGVyYXRpb25zID4gMTAwMDAwICYmIGl0ZXJhdGlvbnMgPiBtYXRjaC5pbmRleCAqIDMpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdwb3RlbnRpYWwgaW5maW5pdGUgbG9vcCwgd2F5IG1vcmUgaXRlcmF0aW9ucyB0aGFuIG1hdGNoZXMnKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuXG4gICAgICAvKlxuICAgICAgV2h5IG1pZ2h0IGJlIGZpbmQgb3Vyc2VsdmVzIGhlcmU/ICBBbiBwb3RlbnRpYWwgZW5kIG1hdGNoIHRoYXQgd2FzXG4gICAgICB0cmlnZ2VyZWQgYnV0IGNvdWxkIG5vdCBiZSBjb21wbGV0ZWQuICBJRSwgYGRvRW5kTWF0Y2hgIHJldHVybmVkIE5PX01BVENILlxuICAgICAgKHRoaXMgY291bGQgYmUgYmVjYXVzZSBhIGNhbGxiYWNrIHJlcXVlc3RzIHRoZSBtYXRjaCBiZSBpZ25vcmVkLCBldGMpXG5cbiAgICAgIFRoaXMgY2F1c2VzIG5vIHJlYWwgaGFybSBvdGhlciB0aGFuIHN0b3BwaW5nIGEgZmV3IHRpbWVzIHRvbyBtYW55LlxuICAgICAgKi9cblxuICAgICAgbW9kZUJ1ZmZlciArPSBsZXhlbWU7XG4gICAgICByZXR1cm4gbGV4ZW1lLmxlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBsYW5ndWFnZSA9IGdldExhbmd1YWdlKGxhbmd1YWdlTmFtZSk7XG4gICAgaWYgKCFsYW5ndWFnZSkge1xuICAgICAgZXJyb3IoTEFOR1VBR0VfTk9UX0ZPVU5ELnJlcGxhY2UoXCJ7fVwiLCBsYW5ndWFnZU5hbWUpKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsYW5ndWFnZTogXCInICsgbGFuZ3VhZ2VOYW1lICsgJ1wiJyk7XG4gICAgfVxuXG4gICAgY29uc3QgbWQgPSBjb21waWxlTGFuZ3VhZ2UobGFuZ3VhZ2UpO1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICAvKiogQHR5cGUge0NvbXBpbGVkTW9kZX0gKi9cbiAgICBsZXQgdG9wID0gY29udGludWF0aW9uIHx8IG1kO1xuICAgIC8qKiBAdHlwZSBSZWNvcmQ8c3RyaW5nLENvbXBpbGVkTW9kZT4gKi9cbiAgICBjb25zdCBjb250aW51YXRpb25zID0ge307IC8vIGtlZXAgY29udGludWF0aW9ucyBmb3Igc3ViLWxhbmd1YWdlc1xuICAgIGNvbnN0IGVtaXR0ZXIgPSBuZXcgb3B0aW9ucy5fX2VtaXR0ZXIob3B0aW9ucyk7XG4gICAgcHJvY2Vzc0NvbnRpbnVhdGlvbnMoKTtcbiAgICBsZXQgbW9kZUJ1ZmZlciA9ICcnO1xuICAgIGxldCByZWxldmFuY2UgPSAwO1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgbGV0IGl0ZXJhdGlvbnMgPSAwO1xuICAgIGxldCByZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24gPSBmYWxzZTtcblxuICAgIHRyeSB7XG4gICAgICBpZiAoIWxhbmd1YWdlLl9fZW1pdFRva2Vucykge1xuICAgICAgICB0b3AubWF0Y2hlci5jb25zaWRlckFsbCgpO1xuXG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICBpdGVyYXRpb25zKys7XG4gICAgICAgICAgaWYgKHJlc3VtZVNjYW5BdFNhbWVQb3NpdGlvbikge1xuICAgICAgICAgICAgLy8gb25seSByZWdleGVzIG5vdCBtYXRjaGVkIHByZXZpb3VzbHkgd2lsbCBub3cgYmVcbiAgICAgICAgICAgIC8vIGNvbnNpZGVyZWQgZm9yIGEgcG90ZW50aWFsIG1hdGNoXG4gICAgICAgICAgICByZXN1bWVTY2FuQXRTYW1lUG9zaXRpb24gPSBmYWxzZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9wLm1hdGNoZXIuY29uc2lkZXJBbGwoKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdG9wLm1hdGNoZXIubGFzdEluZGV4ID0gaW5kZXg7XG5cbiAgICAgICAgICBjb25zdCBtYXRjaCA9IHRvcC5tYXRjaGVyLmV4ZWMoY29kZVRvSGlnaGxpZ2h0KTtcbiAgICAgICAgICAvLyBjb25zb2xlLmxvZyhcIm1hdGNoXCIsIG1hdGNoWzBdLCBtYXRjaC5ydWxlICYmIG1hdGNoLnJ1bGUuYmVnaW4pXG5cbiAgICAgICAgICBpZiAoIW1hdGNoKSBicmVhaztcblxuICAgICAgICAgIGNvbnN0IGJlZm9yZU1hdGNoID0gY29kZVRvSGlnaGxpZ2h0LnN1YnN0cmluZyhpbmRleCwgbWF0Y2guaW5kZXgpO1xuICAgICAgICAgIGNvbnN0IHByb2Nlc3NlZENvdW50ID0gcHJvY2Vzc0xleGVtZShiZWZvcmVNYXRjaCwgbWF0Y2gpO1xuICAgICAgICAgIGluZGV4ID0gbWF0Y2guaW5kZXggKyBwcm9jZXNzZWRDb3VudDtcbiAgICAgICAgfVxuICAgICAgICBwcm9jZXNzTGV4ZW1lKGNvZGVUb0hpZ2hsaWdodC5zdWJzdHJpbmcoaW5kZXgpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxhbmd1YWdlLl9fZW1pdFRva2Vucyhjb2RlVG9IaWdobGlnaHQsIGVtaXR0ZXIpO1xuICAgICAgfVxuXG4gICAgICBlbWl0dGVyLmZpbmFsaXplKCk7XG4gICAgICByZXN1bHQgPSBlbWl0dGVyLnRvSFRNTCgpO1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgICAgICB2YWx1ZTogcmVzdWx0LFxuICAgICAgICByZWxldmFuY2UsXG4gICAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgICBfZW1pdHRlcjogZW1pdHRlcixcbiAgICAgICAgX3RvcDogdG9wXG4gICAgICB9O1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKCdJbGxlZ2FsJykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBsYW5ndWFnZTogbGFuZ3VhZ2VOYW1lLFxuICAgICAgICAgIHZhbHVlOiBlc2NhcGUoY29kZVRvSGlnaGxpZ2h0KSxcbiAgICAgICAgICBpbGxlZ2FsOiB0cnVlLFxuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICBfaWxsZWdhbEJ5OiB7XG4gICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgY29udGV4dDogY29kZVRvSGlnaGxpZ2h0LnNsaWNlKGluZGV4IC0gMTAwLCBpbmRleCArIDEwMCksXG4gICAgICAgICAgICBtb2RlOiBlcnIubW9kZSxcbiAgICAgICAgICAgIHJlc3VsdFNvRmFyOiByZXN1bHRcbiAgICAgICAgICB9LFxuICAgICAgICAgIF9lbWl0dGVyOiBlbWl0dGVyXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKFNBRkVfTU9ERSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGxhbmd1YWdlOiBsYW5ndWFnZU5hbWUsXG4gICAgICAgICAgdmFsdWU6IGVzY2FwZShjb2RlVG9IaWdobGlnaHQpLFxuICAgICAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICBlcnJvclJhaXNlZDogZXJyLFxuICAgICAgICAgIF9lbWl0dGVyOiBlbWl0dGVyLFxuICAgICAgICAgIF90b3A6IHRvcFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiByZXR1cm5zIGEgdmFsaWQgaGlnaGxpZ2h0IHJlc3VsdCwgd2l0aG91dCBhY3R1YWxseSBkb2luZyBhbnkgYWN0dWFsIHdvcmssXG4gICAqIGF1dG8gaGlnaGxpZ2h0IHN0YXJ0cyB3aXRoIHRoaXMgYW5kIGl0J3MgcG9zc2libGUgZm9yIHNtYWxsIHNuaXBwZXRzIHRoYXRcbiAgICogYXV0by1kZXRlY3Rpb24gbWF5IG5vdCBmaW5kIGEgYmV0dGVyIG1hdGNoXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gICAqIEByZXR1cm5zIHtIaWdobGlnaHRSZXN1bHR9XG4gICAqL1xuICBmdW5jdGlvbiBqdXN0VGV4dEhpZ2hsaWdodFJlc3VsdChjb2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgdmFsdWU6IGVzY2FwZShjb2RlKSxcbiAgICAgIGlsbGVnYWw6IGZhbHNlLFxuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgX3RvcDogUExBSU5URVhUX0xBTkdVQUdFLFxuICAgICAgX2VtaXR0ZXI6IG5ldyBvcHRpb25zLl9fZW1pdHRlcihvcHRpb25zKVxuICAgIH07XG4gICAgcmVzdWx0Ll9lbWl0dGVyLmFkZFRleHQoY29kZSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICBIaWdobGlnaHRpbmcgd2l0aCBsYW5ndWFnZSBkZXRlY3Rpb24uIEFjY2VwdHMgYSBzdHJpbmcgd2l0aCB0aGUgY29kZSB0b1xuICBoaWdobGlnaHQuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG4gIC0gbGFuZ3VhZ2UgKGRldGVjdGVkIGxhbmd1YWdlKVxuICAtIHJlbGV2YW5jZSAoaW50KVxuICAtIHZhbHVlIChhbiBIVE1MIHN0cmluZyB3aXRoIGhpZ2hsaWdodGluZyBtYXJrdXApXG4gIC0gc2Vjb25kQmVzdCAob2JqZWN0IHdpdGggdGhlIHNhbWUgc3RydWN0dXJlIGZvciBzZWNvbmQtYmVzdCBoZXVyaXN0aWNhbGx5XG4gICAgZGV0ZWN0ZWQgbGFuZ3VhZ2UsIG1heSBiZSBhYnNlbnQpXG5cbiAgICBAcGFyYW0ge3N0cmluZ30gY29kZVxuICAgIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW2xhbmd1YWdlU3Vic2V0XVxuICAgIEByZXR1cm5zIHtBdXRvSGlnaGxpZ2h0UmVzdWx0fVxuICAqL1xuICBmdW5jdGlvbiBoaWdobGlnaHRBdXRvKGNvZGUsIGxhbmd1YWdlU3Vic2V0KSB7XG4gICAgbGFuZ3VhZ2VTdWJzZXQgPSBsYW5ndWFnZVN1YnNldCB8fCBvcHRpb25zLmxhbmd1YWdlcyB8fCBPYmplY3Qua2V5cyhsYW5ndWFnZXMpO1xuICAgIGNvbnN0IHBsYWludGV4dCA9IGp1c3RUZXh0SGlnaGxpZ2h0UmVzdWx0KGNvZGUpO1xuXG4gICAgY29uc3QgcmVzdWx0cyA9IGxhbmd1YWdlU3Vic2V0LmZpbHRlcihnZXRMYW5ndWFnZSkuZmlsdGVyKGF1dG9EZXRlY3Rpb24pLm1hcChuYW1lID0+XG4gICAgICBfaGlnaGxpZ2h0KG5hbWUsIGNvZGUsIGZhbHNlKVxuICAgICk7XG4gICAgcmVzdWx0cy51bnNoaWZ0KHBsYWludGV4dCk7IC8vIHBsYWludGV4dCBpcyBhbHdheXMgYW4gb3B0aW9uXG5cbiAgICBjb25zdCBzb3J0ZWQgPSByZXN1bHRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgIC8vIHNvcnQgYmFzZSBvbiByZWxldmFuY2VcbiAgICAgIGlmIChhLnJlbGV2YW5jZSAhPT0gYi5yZWxldmFuY2UpIHJldHVybiBiLnJlbGV2YW5jZSAtIGEucmVsZXZhbmNlO1xuXG4gICAgICAvLyBhbHdheXMgYXdhcmQgdGhlIHRpZSB0byB0aGUgYmFzZSBsYW5ndWFnZVxuICAgICAgLy8gaWUgaWYgQysrIGFuZCBBcmR1aW5vIGFyZSB0aWVkLCBpdCdzIG1vcmUgbGlrZWx5IHRvIGJlIEMrK1xuICAgICAgaWYgKGEubGFuZ3VhZ2UgJiYgYi5sYW5ndWFnZSkge1xuICAgICAgICBpZiAoZ2V0TGFuZ3VhZ2UoYS5sYW5ndWFnZSkuc3VwZXJzZXRPZiA9PT0gYi5sYW5ndWFnZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9IGVsc2UgaWYgKGdldExhbmd1YWdlKGIubGFuZ3VhZ2UpLnN1cGVyc2V0T2YgPT09IGEubGFuZ3VhZ2UpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gb3RoZXJ3aXNlIHNheSB0aGV5IGFyZSBlcXVhbCwgd2hpY2ggaGFzIHRoZSBlZmZlY3Qgb2Ygc29ydGluZyBvblxuICAgICAgLy8gcmVsZXZhbmNlIHdoaWxlIHByZXNlcnZpbmcgdGhlIG9yaWdpbmFsIG9yZGVyaW5nIC0gd2hpY2ggaXMgaG93IHRpZXNcbiAgICAgIC8vIGhhdmUgaGlzdG9yaWNhbGx5IGJlZW4gc2V0dGxlZCwgaWUgdGhlIGxhbmd1YWdlIHRoYXQgY29tZXMgZmlyc3QgYWx3YXlzXG4gICAgICAvLyB3aW5zIGluIHRoZSBjYXNlIG9mIGEgdGllXG4gICAgICByZXR1cm4gMDtcbiAgICB9KTtcblxuICAgIGNvbnN0IFtiZXN0LCBzZWNvbmRCZXN0XSA9IHNvcnRlZDtcblxuICAgIC8qKiBAdHlwZSB7QXV0b0hpZ2hsaWdodFJlc3VsdH0gKi9cbiAgICBjb25zdCByZXN1bHQgPSBiZXN0O1xuICAgIHJlc3VsdC5zZWNvbmRCZXN0ID0gc2Vjb25kQmVzdDtcblxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG5ldyBjbGFzcyBuYW1lIGZvciBibG9jayBnaXZlbiB0aGUgbGFuZ3VhZ2UgbmFtZVxuICAgKlxuICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbY3VycmVudExhbmddXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbcmVzdWx0TGFuZ11cbiAgICovXG4gIGZ1bmN0aW9uIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBjdXJyZW50TGFuZywgcmVzdWx0TGFuZykge1xuICAgIGNvbnN0IGxhbmd1YWdlID0gKGN1cnJlbnRMYW5nICYmIGFsaWFzZXNbY3VycmVudExhbmddKSB8fCByZXN1bHRMYW5nO1xuXG4gICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiaGxqc1wiKTtcbiAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoYGxhbmd1YWdlLSR7bGFuZ3VhZ2V9YCk7XG4gIH1cblxuICAvKipcbiAgICogQXBwbGllcyBoaWdobGlnaHRpbmcgdG8gYSBET00gbm9kZSBjb250YWluaW5nIGNvZGUuXG4gICAqXG4gICAqIEBwYXJhbSB7SGlnaGxpZ2h0ZWRIVE1MRWxlbWVudH0gZWxlbWVudCAtIHRoZSBIVE1MIGVsZW1lbnQgdG8gaGlnaGxpZ2h0XG4gICovXG4gIGZ1bmN0aW9uIGhpZ2hsaWdodEVsZW1lbnQoZWxlbWVudCkge1xuICAgIC8qKiBAdHlwZSBIVE1MRWxlbWVudCAqL1xuICAgIGxldCBub2RlID0gbnVsbDtcbiAgICBjb25zdCBsYW5ndWFnZSA9IGJsb2NrTGFuZ3VhZ2UoZWxlbWVudCk7XG5cbiAgICBpZiAoc2hvdWxkTm90SGlnaGxpZ2h0KGxhbmd1YWdlKSkgcmV0dXJuO1xuXG4gICAgZmlyZShcImJlZm9yZTpoaWdobGlnaHRFbGVtZW50XCIsXG4gICAgICB7IGVsOiBlbGVtZW50LCBsYW5ndWFnZSB9KTtcblxuICAgIGlmIChlbGVtZW50LmRhdGFzZXQuaGlnaGxpZ2h0ZWQpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRWxlbWVudCBwcmV2aW91c2x5IGhpZ2hsaWdodGVkLiBUbyBoaWdobGlnaHQgYWdhaW4sIGZpcnN0IHVuc2V0IGBkYXRhc2V0LmhpZ2hsaWdodGVkYC5cIiwgZWxlbWVudCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gd2Ugc2hvdWxkIGJlIGFsbCB0ZXh0LCBubyBjaGlsZCBub2RlcyAodW5lc2NhcGVkIEhUTUwpIC0gdGhpcyBpcyBwb3NzaWJseVxuICAgIC8vIGFuIEhUTUwgaW5qZWN0aW9uIGF0dGFjayAtIGl0J3MgbGlrZWx5IHRvbyBsYXRlIGlmIHRoaXMgaXMgYWxyZWFkeSBpblxuICAgIC8vIHByb2R1Y3Rpb24gKHRoZSBjb2RlIGhhcyBsaWtlbHkgYWxyZWFkeSBkb25lIGl0cyBkYW1hZ2UgYnkgdGhlIHRpbWVcbiAgICAvLyB3ZSdyZSBzZWVpbmcgaXQpLi4uIGJ1dCB3ZSB5ZWxsIGxvdWRseSBhYm91dCB0aGlzIHNvIHRoYXQgaG9wZWZ1bGx5IGl0J3NcbiAgICAvLyBtb3JlIGxpa2VseSB0byBiZSBjYXVnaHQgaW4gZGV2ZWxvcG1lbnQgYmVmb3JlIG1ha2luZyBpdCB0byBwcm9kdWN0aW9uXG4gICAgaWYgKGVsZW1lbnQuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKCFvcHRpb25zLmlnbm9yZVVuZXNjYXBlZEhUTUwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiT25lIG9mIHlvdXIgY29kZSBibG9ja3MgaW5jbHVkZXMgdW5lc2NhcGVkIEhUTUwuIFRoaXMgaXMgYSBwb3RlbnRpYWxseSBzZXJpb3VzIHNlY3VyaXR5IHJpc2suXCIpO1xuICAgICAgICBjb25zb2xlLndhcm4oXCJodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL3dpa2kvc2VjdXJpdHlcIik7XG4gICAgICAgIGNvbnNvbGUud2FybihcIlRoZSBlbGVtZW50IHdpdGggdW5lc2NhcGVkIEhUTUw6XCIpO1xuICAgICAgICBjb25zb2xlLndhcm4oZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy50aHJvd1VuZXNjYXBlZEhUTUwpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEhUTUxJbmplY3Rpb25FcnJvcihcbiAgICAgICAgICBcIk9uZSBvZiB5b3VyIGNvZGUgYmxvY2tzIGluY2x1ZGVzIHVuZXNjYXBlZCBIVE1MLlwiLFxuICAgICAgICAgIGVsZW1lbnQuaW5uZXJIVE1MXG4gICAgICAgICk7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlID0gZWxlbWVudDtcbiAgICBjb25zdCB0ZXh0ID0gbm9kZS50ZXh0Q29udGVudDtcbiAgICBjb25zdCByZXN1bHQgPSBsYW5ndWFnZSA/IGhpZ2hsaWdodCh0ZXh0LCB7IGxhbmd1YWdlLCBpZ25vcmVJbGxlZ2FsczogdHJ1ZSB9KSA6IGhpZ2hsaWdodEF1dG8odGV4dCk7XG5cbiAgICBlbGVtZW50LmlubmVySFRNTCA9IHJlc3VsdC52YWx1ZTtcbiAgICBlbGVtZW50LmRhdGFzZXQuaGlnaGxpZ2h0ZWQgPSBcInllc1wiO1xuICAgIHVwZGF0ZUNsYXNzTmFtZShlbGVtZW50LCBsYW5ndWFnZSwgcmVzdWx0Lmxhbmd1YWdlKTtcbiAgICBlbGVtZW50LnJlc3VsdCA9IHtcbiAgICAgIGxhbmd1YWdlOiByZXN1bHQubGFuZ3VhZ2UsXG4gICAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2ZXJzaW9uIDExLjBcbiAgICAgIHJlOiByZXN1bHQucmVsZXZhbmNlLFxuICAgICAgcmVsZXZhbmNlOiByZXN1bHQucmVsZXZhbmNlXG4gICAgfTtcbiAgICBpZiAocmVzdWx0LnNlY29uZEJlc3QpIHtcbiAgICAgIGVsZW1lbnQuc2Vjb25kQmVzdCA9IHtcbiAgICAgICAgbGFuZ3VhZ2U6IHJlc3VsdC5zZWNvbmRCZXN0Lmxhbmd1YWdlLFxuICAgICAgICByZWxldmFuY2U6IHJlc3VsdC5zZWNvbmRCZXN0LnJlbGV2YW5jZVxuICAgICAgfTtcbiAgICB9XG5cbiAgICBmaXJlKFwiYWZ0ZXI6aGlnaGxpZ2h0RWxlbWVudFwiLCB7IGVsOiBlbGVtZW50LCByZXN1bHQsIHRleHQgfSk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlcyBoaWdobGlnaHQuanMgZ2xvYmFsIG9wdGlvbnMgd2l0aCB0aGUgcGFzc2VkIG9wdGlvbnNcbiAgICpcbiAgICogQHBhcmFtIHtQYXJ0aWFsPEhMSlNPcHRpb25zPn0gdXNlck9wdGlvbnNcbiAgICovXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZSh1c2VyT3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBpbmhlcml0KG9wdGlvbnMsIHVzZXJPcHRpb25zKTtcbiAgfVxuXG4gIC8vIFRPRE86IHJlbW92ZSB2MTIsIGRlcHJlY2F0ZWRcbiAgY29uc3QgaW5pdEhpZ2hsaWdodGluZyA9ICgpID0+IHtcbiAgICBoaWdobGlnaHRBbGwoKTtcbiAgICBkZXByZWNhdGVkKFwiMTAuNi4wXCIsIFwiaW5pdEhpZ2hsaWdodGluZygpIGRlcHJlY2F0ZWQuICBVc2UgaGlnaGxpZ2h0QWxsKCkgbm93LlwiKTtcbiAgfTtcblxuICAvLyBUT0RPOiByZW1vdmUgdjEyLCBkZXByZWNhdGVkXG4gIGZ1bmN0aW9uIGluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSB7XG4gICAgaGlnaGxpZ2h0QWxsKCk7XG4gICAgZGVwcmVjYXRlZChcIjEwLjYuMFwiLCBcImluaXRIaWdobGlnaHRpbmdPbkxvYWQoKSBkZXByZWNhdGVkLiAgVXNlIGhpZ2hsaWdodEFsbCgpIG5vdy5cIik7XG4gIH1cblxuICBsZXQgd2FudHNIaWdobGlnaHQgPSBmYWxzZTtcblxuICAvKipcbiAgICogYXV0by1oaWdobGlnaHRzIGFsbCBwcmU+Y29kZSBlbGVtZW50cyBvbiB0aGUgcGFnZVxuICAgKi9cbiAgZnVuY3Rpb24gaGlnaGxpZ2h0QWxsKCkge1xuICAgIC8vIGlmIHdlIGFyZSBjYWxsZWQgdG9vIGVhcmx5IGluIHRoZSBsb2FkaW5nIHByb2Nlc3NcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJsb2FkaW5nXCIpIHtcbiAgICAgIHdhbnRzSGlnaGxpZ2h0ID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBibG9ja3MgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKG9wdGlvbnMuY3NzU2VsZWN0b3IpO1xuICAgIGJsb2Nrcy5mb3JFYWNoKGhpZ2hsaWdodEVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gYm9vdCgpIHtcbiAgICAvLyBpZiBhIGhpZ2hsaWdodCB3YXMgcmVxdWVzdGVkIGJlZm9yZSBET00gd2FzIGxvYWRlZCwgZG8gbm93XG4gICAgaWYgKHdhbnRzSGlnaGxpZ2h0KSBoaWdobGlnaHRBbGwoKTtcbiAgfVxuXG4gIC8vIG1ha2Ugc3VyZSB3ZSBhcmUgaW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnRcbiAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBib290LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSBsYW5ndWFnZSBncmFtbWFyIG1vZHVsZVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VOYW1lXG4gICAqIEBwYXJhbSB7TGFuZ3VhZ2VGbn0gbGFuZ3VhZ2VEZWZpbml0aW9uXG4gICAqL1xuICBmdW5jdGlvbiByZWdpc3Rlckxhbmd1YWdlKGxhbmd1YWdlTmFtZSwgbGFuZ3VhZ2VEZWZpbml0aW9uKSB7XG4gICAgbGV0IGxhbmcgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBsYW5nID0gbGFuZ3VhZ2VEZWZpbml0aW9uKGhsanMpO1xuICAgIH0gY2F0Y2ggKGVycm9yJDEpIHtcbiAgICAgIGVycm9yKFwiTGFuZ3VhZ2UgZGVmaW5pdGlvbiBmb3IgJ3t9JyBjb3VsZCBub3QgYmUgcmVnaXN0ZXJlZC5cIi5yZXBsYWNlKFwie31cIiwgbGFuZ3VhZ2VOYW1lKSk7XG4gICAgICAvLyBoYXJkIG9yIHNvZnQgZXJyb3JcbiAgICAgIGlmICghU0FGRV9NT0RFKSB7IHRocm93IGVycm9yJDE7IH0gZWxzZSB7IGVycm9yKGVycm9yJDEpOyB9XG4gICAgICAvLyBsYW5ndWFnZXMgdGhhdCBoYXZlIHNlcmlvdXMgZXJyb3JzIGFyZSByZXBsYWNlZCB3aXRoIGVzc2VudGlhbGx5IGFcbiAgICAgIC8vIFwicGxhaW50ZXh0XCIgc3RhbmQtaW4gc28gdGhhdCB0aGUgY29kZSBibG9ja3Mgd2lsbCBzdGlsbCBnZXQgbm9ybWFsXG4gICAgICAvLyBjc3MgY2xhc3NlcyBhcHBsaWVkIHRvIHRoZW0gLSBhbmQgb25lIGJhZCBsYW5ndWFnZSB3b24ndCBicmVhayB0aGVcbiAgICAgIC8vIGVudGlyZSBoaWdobGlnaHRlclxuICAgICAgbGFuZyA9IFBMQUlOVEVYVF9MQU5HVUFHRTtcbiAgICB9XG4gICAgLy8gZ2l2ZSBpdCBhIHRlbXBvcmFyeSBuYW1lIGlmIGl0IGRvZXNuJ3QgaGF2ZSBvbmUgaW4gdGhlIG1ldGEtZGF0YVxuICAgIGlmICghbGFuZy5uYW1lKSBsYW5nLm5hbWUgPSBsYW5ndWFnZU5hbWU7XG4gICAgbGFuZ3VhZ2VzW2xhbmd1YWdlTmFtZV0gPSBsYW5nO1xuICAgIGxhbmcucmF3RGVmaW5pdGlvbiA9IGxhbmd1YWdlRGVmaW5pdGlvbi5iaW5kKG51bGwsIGhsanMpO1xuXG4gICAgaWYgKGxhbmcuYWxpYXNlcykge1xuICAgICAgcmVnaXN0ZXJBbGlhc2VzKGxhbmcuYWxpYXNlcywgeyBsYW5ndWFnZU5hbWUgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxhbmd1YWdlIGdyYW1tYXIgbW9kdWxlXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYW5ndWFnZU5hbWVcbiAgICovXG4gIGZ1bmN0aW9uIHVucmVnaXN0ZXJMYW5ndWFnZShsYW5ndWFnZU5hbWUpIHtcbiAgICBkZWxldGUgbGFuZ3VhZ2VzW2xhbmd1YWdlTmFtZV07XG4gICAgZm9yIChjb25zdCBhbGlhcyBvZiBPYmplY3Qua2V5cyhhbGlhc2VzKSkge1xuICAgICAgaWYgKGFsaWFzZXNbYWxpYXNdID09PSBsYW5ndWFnZU5hbWUpIHtcbiAgICAgICAgZGVsZXRlIGFsaWFzZXNbYWxpYXNdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcmV0dXJucyB7c3RyaW5nW119IExpc3Qgb2YgbGFuZ3VhZ2UgaW50ZXJuYWwgbmFtZXNcbiAgICovXG4gIGZ1bmN0aW9uIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKGxhbmd1YWdlcyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byByZXRyaWV2ZVxuICAgKiBAcmV0dXJucyB7TGFuZ3VhZ2UgfCB1bmRlZmluZWR9XG4gICAqL1xuICBmdW5jdGlvbiBnZXRMYW5ndWFnZShuYW1lKSB7XG4gICAgbmFtZSA9IChuYW1lIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIHJldHVybiBsYW5ndWFnZXNbbmFtZV0gfHwgbGFuZ3VhZ2VzW2FsaWFzZXNbbmFtZV1dO1xuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfHN0cmluZ1tdfSBhbGlhc0xpc3QgLSBzaW5nbGUgYWxpYXMgb3IgbGlzdCBvZiBhbGlhc2VzXG4gICAqIEBwYXJhbSB7e2xhbmd1YWdlTmFtZTogc3RyaW5nfX0gb3B0c1xuICAgKi9cbiAgZnVuY3Rpb24gcmVnaXN0ZXJBbGlhc2VzKGFsaWFzTGlzdCwgeyBsYW5ndWFnZU5hbWUgfSkge1xuICAgIGlmICh0eXBlb2YgYWxpYXNMaXN0ID09PSAnc3RyaW5nJykge1xuICAgICAgYWxpYXNMaXN0ID0gW2FsaWFzTGlzdF07XG4gICAgfVxuICAgIGFsaWFzTGlzdC5mb3JFYWNoKGFsaWFzID0+IHsgYWxpYXNlc1thbGlhcy50b0xvd2VyQ2FzZSgpXSA9IGxhbmd1YWdlTmFtZTsgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGxhbmd1YWdlIGhhcyBhdXRvLWRldGVjdGlvbiBlbmFibGVkXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gbmFtZSBvZiB0aGUgbGFuZ3VhZ2VcbiAgICovXG4gIGZ1bmN0aW9uIGF1dG9EZXRlY3Rpb24obmFtZSkge1xuICAgIGNvbnN0IGxhbmcgPSBnZXRMYW5ndWFnZShuYW1lKTtcbiAgICByZXR1cm4gbGFuZyAmJiAhbGFuZy5kaXNhYmxlQXV0b2RldGVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGdyYWRlcyB0aGUgb2xkIGhpZ2hsaWdodEJsb2NrIHBsdWdpbnMgdG8gdGhlIG5ld1xuICAgKiBoaWdobGlnaHRFbGVtZW50IEFQSVxuICAgKiBAcGFyYW0ge0hMSlNQbHVnaW59IHBsdWdpblxuICAgKi9cbiAgZnVuY3Rpb24gdXBncmFkZVBsdWdpbkFQSShwbHVnaW4pIHtcbiAgICAvLyBUT0RPOiByZW1vdmUgd2l0aCB2MTJcbiAgICBpZiAocGx1Z2luW1wiYmVmb3JlOmhpZ2hsaWdodEJsb2NrXCJdICYmICFwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0RWxlbWVudFwiXSkge1xuICAgICAgcGx1Z2luW1wiYmVmb3JlOmhpZ2hsaWdodEVsZW1lbnRcIl0gPSAoZGF0YSkgPT4ge1xuICAgICAgICBwbHVnaW5bXCJiZWZvcmU6aGlnaGxpZ2h0QmxvY2tcIl0oXG4gICAgICAgICAgT2JqZWN0LmFzc2lnbih7IGJsb2NrOiBkYXRhLmVsIH0sIGRhdGEpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAocGx1Z2luW1wiYWZ0ZXI6aGlnaGxpZ2h0QmxvY2tcIl0gJiYgIXBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEVsZW1lbnRcIl0pIHtcbiAgICAgIHBsdWdpbltcImFmdGVyOmhpZ2hsaWdodEVsZW1lbnRcIl0gPSAoZGF0YSkgPT4ge1xuICAgICAgICBwbHVnaW5bXCJhZnRlcjpoaWdobGlnaHRCbG9ja1wiXShcbiAgICAgICAgICBPYmplY3QuYXNzaWduKHsgYmxvY2s6IGRhdGEuZWwgfSwgZGF0YSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiBhZGRQbHVnaW4ocGx1Z2luKSB7XG4gICAgdXBncmFkZVBsdWdpbkFQSShwbHVnaW4pO1xuICAgIHBsdWdpbnMucHVzaChwbHVnaW4pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7SExKU1BsdWdpbn0gcGx1Z2luXG4gICAqL1xuICBmdW5jdGlvbiByZW1vdmVQbHVnaW4ocGx1Z2luKSB7XG4gICAgY29uc3QgaW5kZXggPSBwbHVnaW5zLmluZGV4T2YocGx1Z2luKTtcbiAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICBwbHVnaW5zLnNwbGljZShpbmRleCwgMSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSB7UGx1Z2luRXZlbnR9IGV2ZW50XG4gICAqIEBwYXJhbSB7YW55fSBhcmdzXG4gICAqL1xuICBmdW5jdGlvbiBmaXJlKGV2ZW50LCBhcmdzKSB7XG4gICAgY29uc3QgY2IgPSBldmVudDtcbiAgICBwbHVnaW5zLmZvckVhY2goZnVuY3Rpb24ocGx1Z2luKSB7XG4gICAgICBpZiAocGx1Z2luW2NiXSkge1xuICAgICAgICBwbHVnaW5bY2JdKGFyZ3MpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERFUFJFQ0FURURcbiAgICogQHBhcmFtIHtIaWdobGlnaHRlZEhUTUxFbGVtZW50fSBlbFxuICAgKi9cbiAgZnVuY3Rpb24gZGVwcmVjYXRlSGlnaGxpZ2h0QmxvY2soZWwpIHtcbiAgICBkZXByZWNhdGVkKFwiMTAuNy4wXCIsIFwiaGlnaGxpZ2h0QmxvY2sgd2lsbCBiZSByZW1vdmVkIGVudGlyZWx5IGluIHYxMi4wXCIpO1xuICAgIGRlcHJlY2F0ZWQoXCIxMC43LjBcIiwgXCJQbGVhc2UgdXNlIGhpZ2hsaWdodEVsZW1lbnQgbm93LlwiKTtcblxuICAgIHJldHVybiBoaWdobGlnaHRFbGVtZW50KGVsKTtcbiAgfVxuXG4gIC8qIEludGVyZmFjZSBkZWZpbml0aW9uICovXG4gIE9iamVjdC5hc3NpZ24oaGxqcywge1xuICAgIGhpZ2hsaWdodCxcbiAgICBoaWdobGlnaHRBdXRvLFxuICAgIGhpZ2hsaWdodEFsbCxcbiAgICBoaWdobGlnaHRFbGVtZW50LFxuICAgIC8vIFRPRE86IFJlbW92ZSB3aXRoIHYxMiBBUElcbiAgICBoaWdobGlnaHRCbG9jazogZGVwcmVjYXRlSGlnaGxpZ2h0QmxvY2ssXG4gICAgY29uZmlndXJlLFxuICAgIGluaXRIaWdobGlnaHRpbmcsXG4gICAgaW5pdEhpZ2hsaWdodGluZ09uTG9hZCxcbiAgICByZWdpc3Rlckxhbmd1YWdlLFxuICAgIHVucmVnaXN0ZXJMYW5ndWFnZSxcbiAgICBsaXN0TGFuZ3VhZ2VzLFxuICAgIGdldExhbmd1YWdlLFxuICAgIHJlZ2lzdGVyQWxpYXNlcyxcbiAgICBhdXRvRGV0ZWN0aW9uLFxuICAgIGluaGVyaXQsXG4gICAgYWRkUGx1Z2luLFxuICAgIHJlbW92ZVBsdWdpblxuICB9KTtcblxuICBobGpzLmRlYnVnTW9kZSA9IGZ1bmN0aW9uKCkgeyBTQUZFX01PREUgPSBmYWxzZTsgfTtcbiAgaGxqcy5zYWZlTW9kZSA9IGZ1bmN0aW9uKCkgeyBTQUZFX01PREUgPSB0cnVlOyB9O1xuICBobGpzLnZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uO1xuXG4gIGhsanMucmVnZXggPSB7XG4gICAgY29uY2F0OiBjb25jYXQsXG4gICAgbG9va2FoZWFkOiBsb29rYWhlYWQsXG4gICAgZWl0aGVyOiBlaXRoZXIsXG4gICAgb3B0aW9uYWw6IG9wdGlvbmFsLFxuICAgIGFueU51bWJlck9mVGltZXM6IGFueU51bWJlck9mVGltZXNcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBNT0RFUykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAodHlwZW9mIE1PREVTW2tleV0gPT09IFwib2JqZWN0XCIpIHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGRlZXBGcmVlemUoTU9ERVNba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgYWxsIHRoZSBtb2Rlcy9yZWdleGVzIGludG8gb3VyIG1haW4gb2JqZWN0XG4gIE9iamVjdC5hc3NpZ24oaGxqcywgTU9ERVMpO1xuXG4gIHJldHVybiBobGpzO1xufTtcblxuLy8gT3RoZXIgbmFtZXMgZm9yIHRoZSB2YXJpYWJsZSBtYXkgYnJlYWsgYnVpbGQgc2NyaXB0XG5jb25zdCBoaWdobGlnaHQgPSBITEpTKHt9KTtcblxuLy8gcmV0dXJucyBhIG5ldyBpbnN0YW5jZSBvZiB0aGUgaGlnaGxpZ2h0ZXIgdG8gYmUgdXNlZCBmb3IgZXh0ZW5zaW9uc1xuLy8gY2hlY2sgaHR0cHM6Ly9naXRodWIuY29tL3dvb29ybS9sb3dsaWdodC9pc3N1ZXMvNDdcbmhpZ2hsaWdodC5uZXdJbnN0YW5jZSA9ICgpID0+IEhMSlMoe30pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGhpZ2hsaWdodDtcbmhpZ2hsaWdodC5IaWdobGlnaHRKUyA9IGhpZ2hsaWdodDtcbmhpZ2hsaWdodC5kZWZhdWx0ID0gaGlnaGxpZ2h0O1xuIl0sIm5hbWVzIjpbImRlZXBGcmVlemUiLCJvYmoiLCJNYXAiLCJjbGVhciIsImRlbGV0ZSIsInNldCIsIkVycm9yIiwiU2V0IiwiYWRkIiwiT2JqZWN0IiwiZnJlZXplIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsImZvckVhY2giLCJuYW1lIiwicHJvcCIsInR5cGUiLCJpc0Zyb3plbiIsIlJlc3BvbnNlIiwiY29uc3RydWN0b3IiLCJtb2RlIiwiZGF0YSIsInVuZGVmaW5lZCIsImlzTWF0Y2hJZ25vcmVkIiwiaWdub3JlTWF0Y2giLCJlc2NhcGVIVE1MIiwidmFsdWUiLCJyZXBsYWNlIiwiaW5oZXJpdCQxIiwib3JpZ2luYWwiLCJvYmplY3RzIiwicmVzdWx0IiwiY3JlYXRlIiwia2V5IiwiU1BBTl9DTE9TRSIsImVtaXRzV3JhcHBpbmdUYWdzIiwibm9kZSIsInNjb3BlIiwic2NvcGVUb0NTU0NsYXNzIiwicHJlZml4Iiwic3RhcnRzV2l0aCIsImluY2x1ZGVzIiwicGllY2VzIiwic3BsaXQiLCJzaGlmdCIsIm1hcCIsIngiLCJpIiwicmVwZWF0Iiwiam9pbiIsIkhUTUxSZW5kZXJlciIsInBhcnNlVHJlZSIsIm9wdGlvbnMiLCJidWZmZXIiLCJjbGFzc1ByZWZpeCIsIndhbGsiLCJhZGRUZXh0IiwidGV4dCIsIm9wZW5Ob2RlIiwiY2xhc3NOYW1lIiwic3BhbiIsImNsb3NlTm9kZSIsIm5ld05vZGUiLCJvcHRzIiwiY2hpbGRyZW4iLCJhc3NpZ24iLCJUb2tlblRyZWUiLCJyb290Tm9kZSIsInN0YWNrIiwidG9wIiwibGVuZ3RoIiwicm9vdCIsInB1c2giLCJwb3AiLCJjbG9zZUFsbE5vZGVzIiwidG9KU09OIiwiSlNPTiIsInN0cmluZ2lmeSIsImJ1aWxkZXIiLCJfd2FsayIsImNoaWxkIiwiX2NvbGxhcHNlIiwiZXZlcnkiLCJlbCIsIlRva2VuVHJlZUVtaXR0ZXIiLCJzdGFydFNjb3BlIiwiZW5kU2NvcGUiLCJfX2FkZFN1Ymxhbmd1YWdlIiwiZW1pdHRlciIsInRvSFRNTCIsInJlbmRlcmVyIiwiZmluYWxpemUiLCJzb3VyY2UiLCJyZSIsImxvb2thaGVhZCIsImNvbmNhdCIsImFueU51bWJlck9mVGltZXMiLCJvcHRpb25hbCIsImFyZ3MiLCJqb2luZWQiLCJzdHJpcE9wdGlvbnNGcm9tQXJncyIsInNwbGljZSIsImVpdGhlciIsImNhcHR1cmUiLCJjb3VudE1hdGNoR3JvdXBzIiwiUmVnRXhwIiwidG9TdHJpbmciLCJleGVjIiwibGV4ZW1lIiwibWF0Y2giLCJpbmRleCIsIkJBQ0tSRUZfUkUiLCJfcmV3cml0ZUJhY2tyZWZlcmVuY2VzIiwicmVnZXhwcyIsImpvaW5XaXRoIiwibnVtQ2FwdHVyZXMiLCJyZWdleCIsIm9mZnNldCIsIm91dCIsInN1YnN0cmluZyIsIlN0cmluZyIsIk51bWJlciIsIk1BVENIX05PVEhJTkdfUkUiLCJJREVOVF9SRSIsIlVOREVSU0NPUkVfSURFTlRfUkUiLCJOVU1CRVJfUkUiLCJDX05VTUJFUl9SRSIsIkJJTkFSWV9OVU1CRVJfUkUiLCJSRV9TVEFSVEVSU19SRSIsIlNIRUJBTkciLCJiZWdpblNoZWJhbmciLCJiaW5hcnkiLCJiZWdpbiIsImVuZCIsInJlbGV2YW5jZSIsIm0iLCJyZXNwIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkFQT1NfU1RSSU5HX01PREUiLCJpbGxlZ2FsIiwiY29udGFpbnMiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlBIUkFTQUxfV09SRFNfTU9ERSIsIkNPTU1FTlQiLCJtb2RlT3B0aW9ucyIsImV4Y2x1ZGVCZWdpbiIsIkVOR0xJU0hfV09SRCIsIkNfTElORV9DT01NRU5UX01PREUiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkhBU0hfQ09NTUVOVF9NT0RFIiwiTlVNQkVSX01PREUiLCJDX05VTUJFUl9NT0RFIiwiQklOQVJZX05VTUJFUl9NT0RFIiwiUkVHRVhQX01PREUiLCJUSVRMRV9NT0RFIiwiVU5ERVJTQ09SRV9USVRMRV9NT0RFIiwiTUVUSE9EX0dVQVJEIiwiRU5EX1NBTUVfQVNfQkVHSU4iLCJfYmVnaW5NYXRjaCIsIk1PREVTIiwiX19wcm90b19fIiwic2tpcElmSGFzUHJlY2VkaW5nRG90IiwicmVzcG9uc2UiLCJiZWZvcmUiLCJpbnB1dCIsInNjb3BlQ2xhc3NOYW1lIiwiX3BhcmVudCIsImJlZ2luS2V5d29yZHMiLCJwYXJlbnQiLCJfX2JlZm9yZUJlZ2luIiwia2V5d29yZHMiLCJjb21waWxlSWxsZWdhbCIsIkFycmF5IiwiaXNBcnJheSIsImNvbXBpbGVNYXRjaCIsImNvbXBpbGVSZWxldmFuY2UiLCJiZWZvcmVNYXRjaEV4dCIsImJlZm9yZU1hdGNoIiwic3RhcnRzIiwib3JpZ2luYWxNb2RlIiwia2V5cyIsImVuZHNQYXJlbnQiLCJDT01NT05fS0VZV09SRFMiLCJERUZBVUxUX0tFWVdPUkRfU0NPUEUiLCJjb21waWxlS2V5d29yZHMiLCJyYXdLZXl3b3JkcyIsImNhc2VJbnNlbnNpdGl2ZSIsInNjb3BlTmFtZSIsImNvbXBpbGVkS2V5d29yZHMiLCJjb21waWxlTGlzdCIsImtleXdvcmRMaXN0IiwidG9Mb3dlckNhc2UiLCJrZXl3b3JkIiwicGFpciIsInNjb3JlRm9yS2V5d29yZCIsInByb3ZpZGVkU2NvcmUiLCJjb21tb25LZXl3b3JkIiwic2VlbkRlcHJlY2F0aW9ucyIsImVycm9yIiwibWVzc2FnZSIsImNvbnNvbGUiLCJ3YXJuIiwibG9nIiwiZGVwcmVjYXRlZCIsInZlcnNpb24iLCJNdWx0aUNsYXNzRXJyb3IiLCJyZW1hcFNjb3BlTmFtZXMiLCJyZWdleGVzIiwic2NvcGVOYW1lcyIsImVtaXQiLCJwb3NpdGlvbnMiLCJfZW1pdCIsIl9tdWx0aSIsImJlZ2luTXVsdGlDbGFzcyIsInNraXAiLCJyZXR1cm5CZWdpbiIsImJlZ2luU2NvcGUiLCJlbmRNdWx0aUNsYXNzIiwiZXhjbHVkZUVuZCIsInJldHVybkVuZCIsInNjb3BlU3VnYXIiLCJNdWx0aUNsYXNzIiwiX3dyYXAiLCJjb21waWxlTGFuZ3VhZ2UiLCJsYW5ndWFnZSIsImxhbmdSZSIsImdsb2JhbCIsImNhc2VfaW5zZW5zaXRpdmUiLCJ1bmljb2RlUmVnZXgiLCJNdWx0aVJlZ2V4IiwibWF0Y2hJbmRleGVzIiwibWF0Y2hBdCIsInBvc2l0aW9uIiwiYWRkUnVsZSIsImNvbXBpbGUiLCJ0ZXJtaW5hdG9ycyIsIm1hdGNoZXJSZSIsImxhc3RJbmRleCIsInMiLCJmaW5kSW5kZXgiLCJtYXRjaERhdGEiLCJSZXN1bWFibGVNdWx0aVJlZ2V4IiwicnVsZXMiLCJtdWx0aVJlZ2V4ZXMiLCJjb3VudCIsInJlZ2V4SW5kZXgiLCJnZXRNYXRjaGVyIiwibWF0Y2hlciIsInNsaWNlIiwicmVzdW1pbmdTY2FuQXRTYW1lUG9zaXRpb24iLCJjb25zaWRlckFsbCIsIm0yIiwiYnVpbGRNb2RlUmVnZXgiLCJtbSIsInRlcm0iLCJydWxlIiwidGVybWluYXRvckVuZCIsImNvbXBpbGVNb2RlIiwiY21vZGUiLCJpc0NvbXBpbGVkIiwiZXh0IiwiY29tcGlsZXJFeHRlbnNpb25zIiwia2V5d29yZFBhdHRlcm4iLCIkcGF0dGVybiIsImtleXdvcmRQYXR0ZXJuUmUiLCJiZWdpblJlIiwiZW5kc1dpdGhQYXJlbnQiLCJlbmRSZSIsImlsbGVnYWxSZSIsImMiLCJleHBhbmRPckNsb25lTW9kZSIsImNsYXNzTmFtZUFsaWFzZXMiLCJkZXBlbmRlbmN5T25QYXJlbnQiLCJ2YXJpYW50cyIsImNhY2hlZFZhcmlhbnRzIiwidmFyaWFudCIsIkhUTUxJbmplY3Rpb25FcnJvciIsInJlYXNvbiIsImh0bWwiLCJlc2NhcGUiLCJpbmhlcml0IiwiTk9fTUFUQ0giLCJTeW1ib2wiLCJNQVhfS0VZV09SRF9ISVRTIiwiSExKUyIsImhsanMiLCJsYW5ndWFnZXMiLCJhbGlhc2VzIiwicGx1Z2lucyIsIlNBRkVfTU9ERSIsIkxBTkdVQUdFX05PVF9GT1VORCIsIlBMQUlOVEVYVF9MQU5HVUFHRSIsImRpc2FibGVBdXRvZGV0ZWN0IiwiaWdub3JlVW5lc2NhcGVkSFRNTCIsInRocm93VW5lc2NhcGVkSFRNTCIsIm5vSGlnaGxpZ2h0UmUiLCJsYW5ndWFnZURldGVjdFJlIiwiY3NzU2VsZWN0b3IiLCJfX2VtaXR0ZXIiLCJzaG91bGROb3RIaWdobGlnaHQiLCJsYW5ndWFnZU5hbWUiLCJ0ZXN0IiwiYmxvY2tMYW5ndWFnZSIsImJsb2NrIiwiY2xhc3NlcyIsInBhcmVudE5vZGUiLCJnZXRMYW5ndWFnZSIsImZpbmQiLCJfY2xhc3MiLCJoaWdobGlnaHQiLCJjb2RlT3JMYW5ndWFnZU5hbWUiLCJvcHRpb25zT3JDb2RlIiwiaWdub3JlSWxsZWdhbHMiLCJjb2RlIiwiY29udGV4dCIsImZpcmUiLCJfaGlnaGxpZ2h0IiwiY29kZVRvSGlnaGxpZ2h0IiwiY29udGludWF0aW9uIiwia2V5d29yZEhpdHMiLCJrZXl3b3JkRGF0YSIsIm1hdGNoVGV4dCIsInByb2Nlc3NLZXl3b3JkcyIsIm1vZGVCdWZmZXIiLCJidWYiLCJ3b3JkIiwia2luZCIsImtleXdvcmRSZWxldmFuY2UiLCJjc3NDbGFzcyIsImVtaXRLZXl3b3JkIiwicHJvY2Vzc1N1Ykxhbmd1YWdlIiwic3ViTGFuZ3VhZ2UiLCJjb250aW51YXRpb25zIiwiX3RvcCIsImhpZ2hsaWdodEF1dG8iLCJfZW1pdHRlciIsInByb2Nlc3NCdWZmZXIiLCJlbWl0TXVsdGlDbGFzcyIsIm1heCIsImtsYXNzIiwic3RhcnROZXdNb2RlIiwiZW5kT2ZNb2RlIiwibWF0Y2hQbHVzUmVtYWluZGVyIiwibWF0Y2hlZCIsImRvSWdub3JlIiwicmVzdW1lU2NhbkF0U2FtZVBvc2l0aW9uIiwiZG9CZWdpbk1hdGNoIiwibmV3TW9kZSIsImJlZm9yZUNhbGxiYWNrcyIsImNiIiwiZG9FbmRNYXRjaCIsImVuZE1vZGUiLCJvcmlnaW4iLCJwcm9jZXNzQ29udGludWF0aW9ucyIsImxpc3QiLCJjdXJyZW50IiwidW5zaGlmdCIsIml0ZW0iLCJsYXN0TWF0Y2giLCJwcm9jZXNzTGV4ZW1lIiwidGV4dEJlZm9yZU1hdGNoIiwiZXJyIiwiYmFkUnVsZSIsInByb2Nlc3NlZCIsIml0ZXJhdGlvbnMiLCJtZCIsIl9fZW1pdFRva2VucyIsInByb2Nlc3NlZENvdW50IiwiX2lsbGVnYWxCeSIsInJlc3VsdFNvRmFyIiwiZXJyb3JSYWlzZWQiLCJqdXN0VGV4dEhpZ2hsaWdodFJlc3VsdCIsImxhbmd1YWdlU3Vic2V0IiwicGxhaW50ZXh0IiwicmVzdWx0cyIsImZpbHRlciIsImF1dG9EZXRlY3Rpb24iLCJzb3J0ZWQiLCJzb3J0IiwiYSIsImIiLCJzdXBlcnNldE9mIiwiYmVzdCIsInNlY29uZEJlc3QiLCJ1cGRhdGVDbGFzc05hbWUiLCJlbGVtZW50IiwiY3VycmVudExhbmciLCJyZXN1bHRMYW5nIiwiY2xhc3NMaXN0IiwiaGlnaGxpZ2h0RWxlbWVudCIsImRhdGFzZXQiLCJoaWdobGlnaHRlZCIsImlubmVySFRNTCIsInRleHRDb250ZW50IiwiY29uZmlndXJlIiwidXNlck9wdGlvbnMiLCJpbml0SGlnaGxpZ2h0aW5nIiwiaGlnaGxpZ2h0QWxsIiwiaW5pdEhpZ2hsaWdodGluZ09uTG9hZCIsIndhbnRzSGlnaGxpZ2h0IiwiZG9jdW1lbnQiLCJyZWFkeVN0YXRlIiwiYmxvY2tzIiwicXVlcnlTZWxlY3RvckFsbCIsImJvb3QiLCJ3aW5kb3ciLCJhZGRFdmVudExpc3RlbmVyIiwicmVnaXN0ZXJMYW5ndWFnZSIsImxhbmd1YWdlRGVmaW5pdGlvbiIsImxhbmciLCJlcnJvciQxIiwicmF3RGVmaW5pdGlvbiIsImJpbmQiLCJyZWdpc3RlckFsaWFzZXMiLCJ1bnJlZ2lzdGVyTGFuZ3VhZ2UiLCJhbGlhcyIsImxpc3RMYW5ndWFnZXMiLCJhbGlhc0xpc3QiLCJ1cGdyYWRlUGx1Z2luQVBJIiwicGx1Z2luIiwiYWRkUGx1Z2luIiwicmVtb3ZlUGx1Z2luIiwiaW5kZXhPZiIsImV2ZW50IiwiZGVwcmVjYXRlSGlnaGxpZ2h0QmxvY2siLCJoaWdobGlnaHRCbG9jayIsImRlYnVnTW9kZSIsInNhZmVNb2RlIiwidmVyc2lvblN0cmluZyIsIm5ld0luc3RhbmNlIiwibW9kdWxlIiwiZXhwb3J0cyIsIkhpZ2hsaWdodEpTIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/lib/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/core.js":
/*!**********************************************!*\
  !*** ./node_modules/highlight.js/es/core.js ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HighlightJS: () => (/* reexport default export from named module */ _lib_core_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/core.js */ \"(ssr)/./node_modules/highlight.js/lib/core.js\");\n// https://nodejs.org/api/packages.html#packages_writing_dual_packages_while_avoiding_or_minimizing_hazards\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_core_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2NvcmUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsMkdBQTJHO0FBQ2xFO0FBQ2xCO0FBQ3ZCLGlFQUFlQSx5Q0FBV0EsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL2RlZnJhZ21lbnRpbmctaWRlYXMvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2NvcmUuanM/MWUxNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBodHRwczovL25vZGVqcy5vcmcvYXBpL3BhY2thZ2VzLmh0bWwjcGFja2FnZXNfd3JpdGluZ19kdWFsX3BhY2thZ2VzX3doaWxlX2F2b2lkaW5nX29yX21pbmltaXppbmdfaGF6YXJkc1xuaW1wb3J0IEhpZ2hsaWdodEpTIGZyb20gJy4uL2xpYi9jb3JlLmpzJztcbmV4cG9ydCB7IEhpZ2hsaWdodEpTIH07XG5leHBvcnQgZGVmYXVsdCBIaWdobGlnaHRKUztcbiJdLCJuYW1lcyI6WyJIaWdobGlnaHRKUyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/core.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/c.js":
/*!*****************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/c.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ c)\n/* harmony export */ });\n/*\nLanguage: C\nCategory: common, system\nWebsite: https://en.wikipedia.org/wiki/C_(programming_language)\n*/ /** @type LanguageFn */ function c(hljs) {\n    const regex = hljs.regex;\n    // added for historic reasons because `hljs.C_LINE_COMMENT_MODE` does\n    // not include such support nor can we be sure all the grammars depending\n    // on it would desire this behavior\n    const C_LINE_COMMENT_MODE = hljs.COMMENT(\"//\", \"$\", {\n        contains: [\n            {\n                begin: /\\\\\\n/\n            }\n        ]\n    });\n    const DECLTYPE_AUTO_RE = \"decltype\\\\(auto\\\\)\";\n    const NAMESPACE_RE = \"[a-zA-Z_]\\\\w*::\";\n    const TEMPLATE_ARGUMENT_RE = \"<[^<>]+>\";\n    const FUNCTION_TYPE_RE = \"(\" + DECLTYPE_AUTO_RE + \"|\" + regex.optional(NAMESPACE_RE) + \"[a-zA-Z_]\\\\w*\" + regex.optional(TEMPLATE_ARGUMENT_RE) + \")\";\n    const TYPES = {\n        className: \"type\",\n        variants: [\n            {\n                begin: \"\\\\b[a-z\\\\d_]*_t\\\\b\"\n            },\n            {\n                match: /\\batomic_[a-z]{3,6}\\b/\n            }\n        ]\n    };\n    // https://en.cppreference.com/w/cpp/language/escape\n    // \\\\ \\x \\xFF \\u2837 \\u00323747 \\374\n    const CHARACTER_ESCAPES = \"\\\\\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\\\S)\";\n    const STRINGS = {\n        className: \"string\",\n        variants: [\n            {\n                begin: '(u8?|U|L)?\"',\n                end: '\"',\n                illegal: \"\\\\n\",\n                contains: [\n                    hljs.BACKSLASH_ESCAPE\n                ]\n            },\n            {\n                begin: \"(u8?|U|L)?'(\" + CHARACTER_ESCAPES + \"|.)\",\n                end: \"'\",\n                illegal: \".\"\n            },\n            hljs.END_SAME_AS_BEGIN({\n                begin: /(?:u8?|U|L)?R\"([^()\\\\ ]{0,16})\\(/,\n                end: /\\)([^()\\\\ ]{0,16})\"/\n            })\n        ]\n    };\n    const NUMBERS = {\n        className: \"number\",\n        variants: [\n            {\n                begin: \"\\\\b(0b[01']+)\"\n            },\n            {\n                begin: \"(-?)\\\\b([\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)\"\n            },\n            {\n                begin: \"(-?)(\\\\b0[xX][a-fA-F0-9']+|(\\\\b[\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)([eE][-+]?[\\\\d']+)?)\"\n            }\n        ],\n        relevance: 0\n    };\n    const PREPROCESSOR = {\n        className: \"meta\",\n        begin: /#\\s*[a-z]+\\b/,\n        end: /$/,\n        keywords: {\n            keyword: \"if else elif endif define undef warning error line \" + \"pragma _Pragma ifdef ifndef include\"\n        },\n        contains: [\n            {\n                begin: /\\\\\\n/,\n                relevance: 0\n            },\n            hljs.inherit(STRINGS, {\n                className: \"string\"\n            }),\n            {\n                className: \"string\",\n                begin: /<.*?>/\n            },\n            C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE\n        ]\n    };\n    const TITLE_MODE = {\n        className: \"title\",\n        begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE,\n        relevance: 0\n    };\n    const FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + \"\\\\s*\\\\(\";\n    const C_KEYWORDS = [\n        \"asm\",\n        \"auto\",\n        \"break\",\n        \"case\",\n        \"continue\",\n        \"default\",\n        \"do\",\n        \"else\",\n        \"enum\",\n        \"extern\",\n        \"for\",\n        \"fortran\",\n        \"goto\",\n        \"if\",\n        \"inline\",\n        \"register\",\n        \"restrict\",\n        \"return\",\n        \"sizeof\",\n        \"struct\",\n        \"switch\",\n        \"typedef\",\n        \"union\",\n        \"volatile\",\n        \"while\",\n        \"_Alignas\",\n        \"_Alignof\",\n        \"_Atomic\",\n        \"_Generic\",\n        \"_Noreturn\",\n        \"_Static_assert\",\n        \"_Thread_local\",\n        // aliases\n        \"alignas\",\n        \"alignof\",\n        \"noreturn\",\n        \"static_assert\",\n        \"thread_local\",\n        // not a C keyword but is, for all intents and purposes, treated exactly like one.\n        \"_Pragma\"\n    ];\n    const C_TYPES = [\n        \"float\",\n        \"double\",\n        \"signed\",\n        \"unsigned\",\n        \"int\",\n        \"short\",\n        \"long\",\n        \"char\",\n        \"void\",\n        \"_Bool\",\n        \"_Complex\",\n        \"_Imaginary\",\n        \"_Decimal32\",\n        \"_Decimal64\",\n        \"_Decimal128\",\n        // modifiers\n        \"const\",\n        \"static\",\n        // aliases\n        \"complex\",\n        \"bool\",\n        \"imaginary\"\n    ];\n    const KEYWORDS = {\n        keyword: C_KEYWORDS,\n        type: C_TYPES,\n        literal: \"true false NULL\",\n        // TODO: apply hinting work similar to what was done in cpp.js\n        built_in: \"std string wstring cin cout cerr clog stdin stdout stderr stringstream istringstream ostringstream \" + \"auto_ptr deque list queue stack vector map set pair bitset multiset multimap unordered_set \" + \"unordered_map unordered_multiset unordered_multimap priority_queue make_pair array shared_ptr abort terminate abs acos \" + \"asin atan2 atan calloc ceil cosh cos exit exp fabs floor fmod fprintf fputs free frexp \" + \"fscanf future isalnum isalpha iscntrl isdigit isgraph islower isprint ispunct isspace isupper \" + \"isxdigit tolower toupper labs ldexp log10 log malloc realloc memchr memcmp memcpy memset modf pow \" + \"printf putchar puts scanf sinh sin snprintf sprintf sqrt sscanf strcat strchr strcmp \" + \"strcpy strcspn strlen strncat strncmp strncpy strpbrk strrchr strspn strstr tanh tan \" + \"vfprintf vprintf vsprintf endl initializer_list unique_ptr\"\n    };\n    const EXPRESSION_CONTAINS = [\n        PREPROCESSOR,\n        TYPES,\n        C_LINE_COMMENT_MODE,\n        hljs.C_BLOCK_COMMENT_MODE,\n        NUMBERS,\n        STRINGS\n    ];\n    const EXPRESSION_CONTEXT = {\n        // This mode covers expression context where we can't expect a function\n        // definition and shouldn't highlight anything that looks like one:\n        // `return some()`, `else if()`, `(x*sum(1, 2))`\n        variants: [\n            {\n                begin: /=/,\n                end: /;/\n            },\n            {\n                begin: /\\(/,\n                end: /\\)/\n            },\n            {\n                beginKeywords: \"new throw return else\",\n                end: /;/\n            }\n        ],\n        keywords: KEYWORDS,\n        contains: EXPRESSION_CONTAINS.concat([\n            {\n                begin: /\\(/,\n                end: /\\)/,\n                keywords: KEYWORDS,\n                contains: EXPRESSION_CONTAINS.concat([\n                    \"self\"\n                ]),\n                relevance: 0\n            }\n        ]),\n        relevance: 0\n    };\n    const FUNCTION_DECLARATION = {\n        begin: \"(\" + FUNCTION_TYPE_RE + \"[\\\\*&\\\\s]+)+\" + FUNCTION_TITLE,\n        returnBegin: true,\n        end: /[{;=]/,\n        excludeEnd: true,\n        keywords: KEYWORDS,\n        illegal: /[^\\w\\s\\*&:<>.]/,\n        contains: [\n            {\n                begin: DECLTYPE_AUTO_RE,\n                keywords: KEYWORDS,\n                relevance: 0\n            },\n            {\n                begin: FUNCTION_TITLE,\n                returnBegin: true,\n                contains: [\n                    hljs.inherit(TITLE_MODE, {\n                        className: \"title.function\"\n                    })\n                ],\n                relevance: 0\n            },\n            // allow for multiple declarations, e.g.:\n            // extern void f(int), g(char);\n            {\n                relevance: 0,\n                match: /,/\n            },\n            {\n                className: \"params\",\n                begin: /\\(/,\n                end: /\\)/,\n                keywords: KEYWORDS,\n                relevance: 0,\n                contains: [\n                    C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE,\n                    STRINGS,\n                    NUMBERS,\n                    TYPES,\n                    // Count matching parentheses.\n                    {\n                        begin: /\\(/,\n                        end: /\\)/,\n                        keywords: KEYWORDS,\n                        relevance: 0,\n                        contains: [\n                            \"self\",\n                            C_LINE_COMMENT_MODE,\n                            hljs.C_BLOCK_COMMENT_MODE,\n                            STRINGS,\n                            NUMBERS,\n                            TYPES\n                        ]\n                    }\n                ]\n            },\n            TYPES,\n            C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            PREPROCESSOR\n        ]\n    };\n    return {\n        name: \"C\",\n        aliases: [\n            \"h\"\n        ],\n        keywords: KEYWORDS,\n        // Until differentiations are added between `c` and `cpp`, `c` will\n        // not be auto-detected to avoid auto-detect conflicts between C and C++\n        disableAutodetect: true,\n        illegal: \"</\",\n        contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, EXPRESSION_CONTAINS, [\n            PREPROCESSOR,\n            {\n                begin: hljs.IDENT_RE + \"::\",\n                keywords: KEYWORDS\n            },\n            {\n                className: \"class\",\n                beginKeywords: \"enum class struct union\",\n                end: /[{;:<>=]/,\n                contains: [\n                    {\n                        beginKeywords: \"final class struct\"\n                    },\n                    hljs.TITLE_MODE\n                ]\n            }\n        ]),\n        exports: {\n            preprocessor: PREPROCESSOR,\n            strings: STRINGS,\n            keywords: KEYWORDS\n        }\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9jLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQTs7OztBQUlBLEdBRUEscUJBQXFCLEdBQ3JCLFNBQVNBLEVBQUVDLElBQUk7SUFDYixNQUFNQyxRQUFRRCxLQUFLQyxLQUFLO0lBQ3hCLHFFQUFxRTtJQUNyRSx5RUFBeUU7SUFDekUsbUNBQW1DO0lBQ25DLE1BQU1DLHNCQUFzQkYsS0FBS0csT0FBTyxDQUFDLE1BQU0sS0FBSztRQUFFQyxVQUFVO1lBQUU7Z0JBQUVDLE9BQU87WUFBTztTQUFHO0lBQUM7SUFDdEYsTUFBTUMsbUJBQW1CO0lBQ3pCLE1BQU1DLGVBQWU7SUFDckIsTUFBTUMsdUJBQXVCO0lBQzdCLE1BQU1DLG1CQUFtQixNQUNyQkgsbUJBQW1CLE1BQ25CTCxNQUFNUyxRQUFRLENBQUNILGdCQUNmLGtCQUFrQk4sTUFBTVMsUUFBUSxDQUFDRix3QkFDbkM7SUFHRixNQUFNRyxRQUFRO1FBQ1pDLFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUFFUixPQUFPO1lBQXFCO1lBQzlCO2dCQUFFUyxPQUFPO1lBQXdCO1NBQ2xDO0lBRUg7SUFFQSxvREFBb0Q7SUFDcEQsb0NBQW9DO0lBQ3BDLE1BQU1DLG9CQUFvQjtJQUMxQixNQUFNQyxVQUFVO1FBQ2RKLFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUNFUixPQUFPO2dCQUNQWSxLQUFLO2dCQUNMQyxTQUFTO2dCQUNUZCxVQUFVO29CQUFFSixLQUFLbUIsZ0JBQWdCO2lCQUFFO1lBQ3JDO1lBQ0E7Z0JBQ0VkLE9BQU8saUJBQWtCVSxvQkFBb0I7Z0JBQzdDRSxLQUFLO2dCQUNMQyxTQUFTO1lBQ1g7WUFDQWxCLEtBQUtvQixpQkFBaUIsQ0FBQztnQkFDckJmLE9BQU87Z0JBQ1BZLEtBQUs7WUFDUDtTQUNEO0lBQ0g7SUFFQSxNQUFNSSxVQUFVO1FBQ2RULFdBQVc7UUFDWEMsVUFBVTtZQUNSO2dCQUFFUixPQUFPO1lBQWlCO1lB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QUFLO2dCQUNMTyxVQUFVUztnQkFDVlgsV0FBVztnQkFDWGxCLFVBQVU7b0JBQ1JGO29CQUNBRixLQUFLMkIsb0JBQW9CO29CQUN6Qlg7b0JBQ0FLO29CQUNBVjtvQkFDQSw4QkFBOEI7b0JBQzlCO3dCQUNFTixPQUFPO3dCQUNQWSxLQUFLO3dCQUNMTyxVQUFVUzt3QkFDVlgsV0FBVzt3QkFDWGxCLFVBQVU7NEJBQ1I7NEJBQ0FGOzRCQUNBRixLQUFLMkIsb0JBQW9COzRCQUN6Qlg7NEJBQ0FLOzRCQUNBVjt5QkFDRDtvQkFDSDtpQkFDRDtZQUNIO1lBQ0FBO1lBQ0FUO1lBQ0FGLEtBQUsyQixvQkFBb0I7WUFDekJKO1NBQ0Q7SUFDSDtJQUVBLE9BQU87UUFDTHFCLE1BQU07UUFDTkMsU0FBUztZQUFFO1NBQUs7UUFDaEJyQixVQUFVUztRQUNWLG1FQUFtRTtRQUNuRSx3RUFBd0U7UUFDeEVhLG1CQUFtQjtRQUNuQjVCLFNBQVM7UUFDVGQsVUFBVSxFQUFFLENBQUNvQyxNQUFNLENBQ2pCRixvQkFDQUcsc0JBQ0FKLHFCQUNBO1lBQ0VkO1lBQ0E7Z0JBQ0VsQixPQUFPTCxLQUFLNkIsUUFBUSxHQUFHO2dCQUN2QkwsVUFBVVM7WUFDWjtZQUNBO2dCQUNFckIsV0FBVztnQkFDWDJCLGVBQWU7Z0JBQ2Z0QixLQUFLO2dCQUNMYixVQUFVO29CQUNSO3dCQUFFbUMsZUFBZTtvQkFBcUI7b0JBQ3RDdkMsS0FBSzRCLFVBQVU7aUJBQ2hCO1lBQ0g7U0FDRDtRQUNIbUIsU0FBUztZQUNQQyxjQUFjekI7WUFDZDBCLFNBQVNqQztZQUNUUSxVQUFVUztRQUNaO0lBQ0Y7QUFDRjtBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL2RlZnJhZ21lbnRpbmctaWRlYXMvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9jLmpzP2E0NGUiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbkxhbmd1YWdlOiBDXG5DYXRlZ29yeTogY29tbW9uLCBzeXN0ZW1cbldlYnNpdGU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NfKHByb2dyYW1taW5nX2xhbmd1YWdlKVxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGMoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIC8vIGFkZGVkIGZvciBoaXN0b3JpYyByZWFzb25zIGJlY2F1c2UgYGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERWAgZG9lc1xuICAvLyBub3QgaW5jbHVkZSBzdWNoIHN1cHBvcnQgbm9yIGNhbiB3ZSBiZSBzdXJlIGFsbCB0aGUgZ3JhbW1hcnMgZGVwZW5kaW5nXG4gIC8vIG9uIGl0IHdvdWxkIGRlc2lyZSB0aGlzIGJlaGF2aW9yXG4gIGNvbnN0IENfTElORV9DT01NRU5UX01PREUgPSBobGpzLkNPTU1FTlQoJy8vJywgJyQnLCB7IGNvbnRhaW5zOiBbIHsgYmVnaW46IC9cXFxcXFxuLyB9IF0gfSk7XG4gIGNvbnN0IERFQ0xUWVBFX0FVVE9fUkUgPSAnZGVjbHR5cGVcXFxcKGF1dG9cXFxcKSc7XG4gIGNvbnN0IE5BTUVTUEFDRV9SRSA9ICdbYS16QS1aX11cXFxcdyo6Oic7XG4gIGNvbnN0IFRFTVBMQVRFX0FSR1VNRU5UX1JFID0gJzxbXjw+XSs+JztcbiAgY29uc3QgRlVOQ1RJT05fVFlQRV9SRSA9ICcoJ1xuICAgICsgREVDTFRZUEVfQVVUT19SRSArICd8J1xuICAgICsgcmVnZXgub3B0aW9uYWwoTkFNRVNQQUNFX1JFKVxuICAgICsgJ1thLXpBLVpfXVxcXFx3KicgKyByZWdleC5vcHRpb25hbChURU1QTEFURV9BUkdVTUVOVF9SRSlcbiAgKyAnKSc7XG5cblxuICBjb25zdCBUWVBFUyA9IHtcbiAgICBjbGFzc05hbWU6ICd0eXBlJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgeyBiZWdpbjogJ1xcXFxiW2EtelxcXFxkX10qX3RcXFxcYicgfSxcbiAgICAgIHsgbWF0Y2g6IC9cXGJhdG9taWNfW2Etel17Myw2fVxcYi8gfVxuICAgIF1cblxuICB9O1xuXG4gIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9sYW5ndWFnZS9lc2NhcGVcbiAgLy8gXFxcXCBcXHggXFx4RkYgXFx1MjgzNyBcXHUwMDMyMzc0NyBcXDM3NFxuICBjb25zdCBDSEFSQUNURVJfRVNDQVBFUyA9ICdcXFxcXFxcXCh4WzAtOUEtRmEtZl17Mn18dVswLTlBLUZhLWZdezQsOH18WzAtN117M318XFxcXFMpJztcbiAgY29uc3QgU1RSSU5HUyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnKHU4P3xVfEwpP1wiJyxcbiAgICAgICAgZW5kOiAnXCInLFxuICAgICAgICBpbGxlZ2FsOiAnXFxcXG4nLFxuICAgICAgICBjb250YWluczogWyBobGpzLkJBQ0tTTEFTSF9FU0NBUEUgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46ICcodTg/fFV8TCk/XFwnKCcgKyBDSEFSQUNURVJfRVNDQVBFUyArIFwifC4pXCIsXG4gICAgICAgIGVuZDogJ1xcJycsXG4gICAgICAgIGlsbGVnYWw6ICcuJ1xuICAgICAgfSxcbiAgICAgIGhsanMuRU5EX1NBTUVfQVNfQkVHSU4oe1xuICAgICAgICBiZWdpbjogLyg/OnU4P3xVfEwpP1JcIihbXigpXFxcXCBdezAsMTZ9KVxcKC8sXG4gICAgICAgIGVuZDogL1xcKShbXigpXFxcXCBdezAsMTZ9KVwiL1xuICAgICAgfSlcbiAgICBdXG4gIH07XG5cbiAgY29uc3QgTlVNQkVSUyA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAnXFxcXGIoMGJbMDFcXCddKyknIH0sXG4gICAgICB7IGJlZ2luOiAnKC0/KVxcXFxiKFtcXFxcZFxcJ10rKFxcXFwuW1xcXFxkXFwnXSopP3xcXFxcLltcXFxcZFxcJ10rKSgobGx8TEx8bHxMKSh1fFUpP3wodXxVKShsbHxMTHxsfEwpP3xmfEZ8YnxCKScgfSxcbiAgICAgIHsgYmVnaW46ICcoLT8pKFxcXFxiMFt4WF1bYS1mQS1GMC05XFwnXSt8KFxcXFxiW1xcXFxkXFwnXSsoXFxcXC5bXFxcXGRcXCddKik/fFxcXFwuW1xcXFxkXFwnXSspKFtlRV1bLStdP1tcXFxcZFxcJ10rKT8pJyB9XG4gICAgXSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBQUkVQUk9DRVNTT1IgPSB7XG4gICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgYmVnaW46IC8jXFxzKlthLXpdK1xcYi8sXG4gICAgZW5kOiAvJC8sXG4gICAga2V5d29yZHM6IHsga2V5d29yZDpcbiAgICAgICAgJ2lmIGVsc2UgZWxpZiBlbmRpZiBkZWZpbmUgdW5kZWYgd2FybmluZyBlcnJvciBsaW5lICdcbiAgICAgICAgKyAncHJhZ21hIF9QcmFnbWEgaWZkZWYgaWZuZGVmIGluY2x1ZGUnIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXFxcXFxuLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgaGxqcy5pbmhlcml0KFNUUklOR1MsIHsgY2xhc3NOYW1lOiAnc3RyaW5nJyB9KSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgYmVnaW46IC88Lio/Pi9cbiAgICAgIH0sXG4gICAgICBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgIF1cbiAgfTtcblxuICBjb25zdCBUSVRMRV9NT0RFID0ge1xuICAgIGNsYXNzTmFtZTogJ3RpdGxlJyxcbiAgICBiZWdpbjogcmVnZXgub3B0aW9uYWwoTkFNRVNQQUNFX1JFKSArIGhsanMuSURFTlRfUkUsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgRlVOQ1RJT05fVElUTEUgPSByZWdleC5vcHRpb25hbChOQU1FU1BBQ0VfUkUpICsgaGxqcy5JREVOVF9SRSArICdcXFxccypcXFxcKCc7XG5cbiAgY29uc3QgQ19LRVlXT1JEUyA9IFtcbiAgICBcImFzbVwiLFxuICAgIFwiYXV0b1wiLFxuICAgIFwiYnJlYWtcIixcbiAgICBcImNhc2VcIixcbiAgICBcImNvbnRpbnVlXCIsXG4gICAgXCJkZWZhdWx0XCIsXG4gICAgXCJkb1wiLFxuICAgIFwiZWxzZVwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwiZXh0ZXJuXCIsXG4gICAgXCJmb3JcIixcbiAgICBcImZvcnRyYW5cIixcbiAgICBcImdvdG9cIixcbiAgICBcImlmXCIsXG4gICAgXCJpbmxpbmVcIixcbiAgICBcInJlZ2lzdGVyXCIsXG4gICAgXCJyZXN0cmljdFwiLFxuICAgIFwicmV0dXJuXCIsXG4gICAgXCJzaXplb2ZcIixcbiAgICBcInN0cnVjdFwiLFxuICAgIFwic3dpdGNoXCIsXG4gICAgXCJ0eXBlZGVmXCIsXG4gICAgXCJ1bmlvblwiLFxuICAgIFwidm9sYXRpbGVcIixcbiAgICBcIndoaWxlXCIsXG4gICAgXCJfQWxpZ25hc1wiLFxuICAgIFwiX0FsaWdub2ZcIixcbiAgICBcIl9BdG9taWNcIixcbiAgICBcIl9HZW5lcmljXCIsXG4gICAgXCJfTm9yZXR1cm5cIixcbiAgICBcIl9TdGF0aWNfYXNzZXJ0XCIsXG4gICAgXCJfVGhyZWFkX2xvY2FsXCIsXG4gICAgLy8gYWxpYXNlc1xuICAgIFwiYWxpZ25hc1wiLFxuICAgIFwiYWxpZ25vZlwiLFxuICAgIFwibm9yZXR1cm5cIixcbiAgICBcInN0YXRpY19hc3NlcnRcIixcbiAgICBcInRocmVhZF9sb2NhbFwiLFxuICAgIC8vIG5vdCBhIEMga2V5d29yZCBidXQgaXMsIGZvciBhbGwgaW50ZW50cyBhbmQgcHVycG9zZXMsIHRyZWF0ZWQgZXhhY3RseSBsaWtlIG9uZS5cbiAgICBcIl9QcmFnbWFcIlxuICBdO1xuXG4gIGNvbnN0IENfVFlQRVMgPSBbXG4gICAgXCJmbG9hdFwiLFxuICAgIFwiZG91YmxlXCIsXG4gICAgXCJzaWduZWRcIixcbiAgICBcInVuc2lnbmVkXCIsXG4gICAgXCJpbnRcIixcbiAgICBcInNob3J0XCIsXG4gICAgXCJsb25nXCIsXG4gICAgXCJjaGFyXCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJfQm9vbFwiLFxuICAgIFwiX0NvbXBsZXhcIixcbiAgICBcIl9JbWFnaW5hcnlcIixcbiAgICBcIl9EZWNpbWFsMzJcIixcbiAgICBcIl9EZWNpbWFsNjRcIixcbiAgICBcIl9EZWNpbWFsMTI4XCIsXG4gICAgLy8gbW9kaWZpZXJzXG4gICAgXCJjb25zdFwiLFxuICAgIFwic3RhdGljXCIsXG4gICAgLy8gYWxpYXNlc1xuICAgIFwiY29tcGxleFwiLFxuICAgIFwiYm9vbFwiLFxuICAgIFwiaW1hZ2luYXJ5XCJcbiAgXTtcblxuICBjb25zdCBLRVlXT1JEUyA9IHtcbiAgICBrZXl3b3JkOiBDX0tFWVdPUkRTLFxuICAgIHR5cGU6IENfVFlQRVMsXG4gICAgbGl0ZXJhbDogJ3RydWUgZmFsc2UgTlVMTCcsXG4gICAgLy8gVE9ETzogYXBwbHkgaGludGluZyB3b3JrIHNpbWlsYXIgdG8gd2hhdCB3YXMgZG9uZSBpbiBjcHAuanNcbiAgICBidWlsdF9pbjogJ3N0ZCBzdHJpbmcgd3N0cmluZyBjaW4gY291dCBjZXJyIGNsb2cgc3RkaW4gc3Rkb3V0IHN0ZGVyciBzdHJpbmdzdHJlYW0gaXN0cmluZ3N0cmVhbSBvc3RyaW5nc3RyZWFtICdcbiAgICAgICsgJ2F1dG9fcHRyIGRlcXVlIGxpc3QgcXVldWUgc3RhY2sgdmVjdG9yIG1hcCBzZXQgcGFpciBiaXRzZXQgbXVsdGlzZXQgbXVsdGltYXAgdW5vcmRlcmVkX3NldCAnXG4gICAgICArICd1bm9yZGVyZWRfbWFwIHVub3JkZXJlZF9tdWx0aXNldCB1bm9yZGVyZWRfbXVsdGltYXAgcHJpb3JpdHlfcXVldWUgbWFrZV9wYWlyIGFycmF5IHNoYXJlZF9wdHIgYWJvcnQgdGVybWluYXRlIGFicyBhY29zICdcbiAgICAgICsgJ2FzaW4gYXRhbjIgYXRhbiBjYWxsb2MgY2VpbCBjb3NoIGNvcyBleGl0IGV4cCBmYWJzIGZsb29yIGZtb2QgZnByaW50ZiBmcHV0cyBmcmVlIGZyZXhwICdcbiAgICAgICsgJ2ZzY2FuZiBmdXR1cmUgaXNhbG51bSBpc2FscGhhIGlzY250cmwgaXNkaWdpdCBpc2dyYXBoIGlzbG93ZXIgaXNwcmludCBpc3B1bmN0IGlzc3BhY2UgaXN1cHBlciAnXG4gICAgICArICdpc3hkaWdpdCB0b2xvd2VyIHRvdXBwZXIgbGFicyBsZGV4cCBsb2cxMCBsb2cgbWFsbG9jIHJlYWxsb2MgbWVtY2hyIG1lbWNtcCBtZW1jcHkgbWVtc2V0IG1vZGYgcG93ICdcbiAgICAgICsgJ3ByaW50ZiBwdXRjaGFyIHB1dHMgc2NhbmYgc2luaCBzaW4gc25wcmludGYgc3ByaW50ZiBzcXJ0IHNzY2FuZiBzdHJjYXQgc3RyY2hyIHN0cmNtcCAnXG4gICAgICArICdzdHJjcHkgc3RyY3NwbiBzdHJsZW4gc3RybmNhdCBzdHJuY21wIHN0cm5jcHkgc3RycGJyayBzdHJyY2hyIHN0cnNwbiBzdHJzdHIgdGFuaCB0YW4gJ1xuICAgICAgKyAndmZwcmludGYgdnByaW50ZiB2c3ByaW50ZiBlbmRsIGluaXRpYWxpemVyX2xpc3QgdW5pcXVlX3B0cicsXG4gIH07XG5cbiAgY29uc3QgRVhQUkVTU0lPTl9DT05UQUlOUyA9IFtcbiAgICBQUkVQUk9DRVNTT1IsXG4gICAgVFlQRVMsXG4gICAgQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgIE5VTUJFUlMsXG4gICAgU1RSSU5HU1xuICBdO1xuXG4gIGNvbnN0IEVYUFJFU1NJT05fQ09OVEVYVCA9IHtcbiAgICAvLyBUaGlzIG1vZGUgY292ZXJzIGV4cHJlc3Npb24gY29udGV4dCB3aGVyZSB3ZSBjYW4ndCBleHBlY3QgYSBmdW5jdGlvblxuICAgIC8vIGRlZmluaXRpb24gYW5kIHNob3VsZG4ndCBoaWdobGlnaHQgYW55dGhpbmcgdGhhdCBsb29rcyBsaWtlIG9uZTpcbiAgICAvLyBgcmV0dXJuIHNvbWUoKWAsIGBlbHNlIGlmKClgLCBgKHgqc3VtKDEsIDIpKWBcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogLz0vLFxuICAgICAgICBlbmQ6IC87L1xuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICBlbmQ6IC9cXCkvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbktleXdvcmRzOiAnbmV3IHRocm93IHJldHVybiBlbHNlJyxcbiAgICAgICAgZW5kOiAvOy9cbiAgICAgIH1cbiAgICBdLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBjb250YWluczogRVhQUkVTU0lPTl9DT05UQUlOUy5jb25jYXQoW1xuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgY29udGFpbnM6IEVYUFJFU1NJT05fQ09OVEFJTlMuY29uY2F0KFsgJ3NlbGYnIF0pLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH1cbiAgICBdKSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBGVU5DVElPTl9ERUNMQVJBVElPTiA9IHtcbiAgICBiZWdpbjogJygnICsgRlVOQ1RJT05fVFlQRV9SRSArICdbXFxcXComXFxcXHNdKykrJyArIEZVTkNUSU9OX1RJVExFLFxuICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgIGVuZDogL1t7Oz1dLyxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICBpbGxlZ2FsOiAvW15cXHdcXHNcXComOjw+Ll0vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7IC8vIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb25mdXNlZCBhcyB0aGUgZnVuY3Rpb24gdGl0bGVcbiAgICAgICAgYmVnaW46IERFQ0xUWVBFX0FVVE9fUkUsXG4gICAgICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogRlVOQ1RJT05fVElUTEUsXG4gICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICBjb250YWluczogWyBobGpzLmluaGVyaXQoVElUTEVfTU9ERSwgeyBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIiB9KSBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICAvLyBhbGxvdyBmb3IgbXVsdGlwbGUgZGVjbGFyYXRpb25zLCBlLmcuOlxuICAgICAgLy8gZXh0ZXJuIHZvaWQgZihpbnQpLCBnKGNoYXIpO1xuICAgICAge1xuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIG1hdGNoOiAvLC9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIFNUUklOR1MsXG4gICAgICAgICAgTlVNQkVSUyxcbiAgICAgICAgICBUWVBFUyxcbiAgICAgICAgICAvLyBDb3VudCBtYXRjaGluZyBwYXJlbnRoZXNlcy5cbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICBlbmQ6IC9cXCkvLFxuICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgJ3NlbGYnLFxuICAgICAgICAgICAgICBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgICAgICBTVFJJTkdTLFxuICAgICAgICAgICAgICBOVU1CRVJTLFxuICAgICAgICAgICAgICBUWVBFU1xuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIFRZUEVTLFxuICAgICAgQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBQUkVQUk9DRVNTT1JcbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiBcIkNcIixcbiAgICBhbGlhc2VzOiBbICdoJyBdLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyxcbiAgICAvLyBVbnRpbCBkaWZmZXJlbnRpYXRpb25zIGFyZSBhZGRlZCBiZXR3ZWVuIGBjYCBhbmQgYGNwcGAsIGBjYCB3aWxsXG4gICAgLy8gbm90IGJlIGF1dG8tZGV0ZWN0ZWQgdG8gYXZvaWQgYXV0by1kZXRlY3QgY29uZmxpY3RzIGJldHdlZW4gQyBhbmQgQysrXG4gICAgZGlzYWJsZUF1dG9kZXRlY3Q6IHRydWUsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjb250YWluczogW10uY29uY2F0KFxuICAgICAgRVhQUkVTU0lPTl9DT05URVhULFxuICAgICAgRlVOQ1RJT05fREVDTEFSQVRJT04sXG4gICAgICBFWFBSRVNTSU9OX0NPTlRBSU5TLFxuICAgICAgW1xuICAgICAgICBQUkVQUk9DRVNTT1IsXG4gICAgICAgIHtcbiAgICAgICAgICBiZWdpbjogaGxqcy5JREVOVF9SRSArICc6OicsXG4gICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBjbGFzc05hbWU6ICdjbGFzcycsXG4gICAgICAgICAgYmVnaW5LZXl3b3JkczogJ2VudW0gY2xhc3Mgc3RydWN0IHVuaW9uJyxcbiAgICAgICAgICBlbmQ6IC9bezs6PD49XS8sXG4gICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgIHsgYmVnaW5LZXl3b3JkczogXCJmaW5hbCBjbGFzcyBzdHJ1Y3RcIiB9LFxuICAgICAgICAgICAgaGxqcy5USVRMRV9NT0RFXG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdKSxcbiAgICBleHBvcnRzOiB7XG4gICAgICBwcmVwcm9jZXNzb3I6IFBSRVBST0NFU1NPUixcbiAgICAgIHN0cmluZ3M6IFNUUklOR1MsXG4gICAgICBrZXl3b3JkczogS0VZV09SRFNcbiAgICB9XG4gIH07XG59XG5cbmV4cG9ydCB7IGMgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbImMiLCJobGpzIiwicmVnZXgiLCJDX0xJTkVfQ09NTUVOVF9NT0RFIiwiQ09NTUVOVCIsImNvbnRhaW5zIiwiYmVnaW4iLCJERUNMVFlQRV9BVVRPX1JFIiwiTkFNRVNQQUNFX1JFIiwiVEVNUExBVEVfQVJHVU1FTlRfUkUiLCJGVU5DVElPTl9UWVBFX1JFIiwib3B0aW9uYWwiLCJUWVBFUyIsImNsYXNzTmFtZSIsInZhcmlhbnRzIiwibWF0Y2giLCJDSEFSQUNURVJfRVNDQVBFUyIsIlNUUklOR1MiLCJlbmQiLCJpbGxlZ2FsIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkVORF9TQU1FX0FTX0JFR0lOIiwiTlVNQkVSUyIsInJlbGV2YW5jZSIsIlBSRVBST0NFU1NPUiIsImtleXdvcmRzIiwia2V5d29yZCIsImluaGVyaXQiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIlRJVExFX01PREUiLCJJREVOVF9SRSIsIkZVTkNUSU9OX1RJVExFIiwiQ19LRVlXT1JEUyIsIkNfVFlQRVMiLCJLRVlXT1JEUyIsInR5cGUiLCJsaXRlcmFsIiwiYnVpbHRfaW4iLCJFWFBSRVNTSU9OX0NPTlRBSU5TIiwiRVhQUkVTU0lPTl9DT05URVhUIiwiYmVnaW5LZXl3b3JkcyIsImNvbmNhdCIsIkZVTkNUSU9OX0RFQ0xBUkFUSU9OIiwicmV0dXJuQmVnaW4iLCJleGNsdWRlRW5kIiwibmFtZSIsImFsaWFzZXMiLCJkaXNhYmxlQXV0b2RldGVjdCIsImV4cG9ydHMiLCJwcmVwcm9jZXNzb3IiLCJzdHJpbmdzIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/c.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/cpp.js":
/*!*******************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/cpp.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ cpp)\n/* harmony export */ });\n/*\nLanguage: C++\nCategory: common, system\nWebsite: https://isocpp.org\n*/ /** @type LanguageFn */ function cpp(hljs) {\n    const regex = hljs.regex;\n    // added for historic reasons because `hljs.C_LINE_COMMENT_MODE` does\n    // not include such support nor can we be sure all the grammars depending\n    // on it would desire this behavior\n    const C_LINE_COMMENT_MODE = hljs.COMMENT(\"//\", \"$\", {\n        contains: [\n            {\n                begin: /\\\\\\n/\n            }\n        ]\n    });\n    const DECLTYPE_AUTO_RE = \"decltype\\\\(auto\\\\)\";\n    const NAMESPACE_RE = \"[a-zA-Z_]\\\\w*::\";\n    const TEMPLATE_ARGUMENT_RE = \"<[^<>]+>\";\n    const FUNCTION_TYPE_RE = \"(?!struct)(\" + DECLTYPE_AUTO_RE + \"|\" + regex.optional(NAMESPACE_RE) + \"[a-zA-Z_]\\\\w*\" + regex.optional(TEMPLATE_ARGUMENT_RE) + \")\";\n    const CPP_PRIMITIVE_TYPES = {\n        className: \"type\",\n        begin: \"\\\\b[a-z\\\\d_]*_t\\\\b\"\n    };\n    // https://en.cppreference.com/w/cpp/language/escape\n    // \\\\ \\x \\xFF \\u2837 \\u00323747 \\374\n    const CHARACTER_ESCAPES = \"\\\\\\\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4,8}|[0-7]{3}|\\\\S)\";\n    const STRINGS = {\n        className: \"string\",\n        variants: [\n            {\n                begin: '(u8?|U|L)?\"',\n                end: '\"',\n                illegal: \"\\\\n\",\n                contains: [\n                    hljs.BACKSLASH_ESCAPE\n                ]\n            },\n            {\n                begin: \"(u8?|U|L)?'(\" + CHARACTER_ESCAPES + \"|.)\",\n                end: \"'\",\n                illegal: \".\"\n            },\n            hljs.END_SAME_AS_BEGIN({\n                begin: /(?:u8?|U|L)?R\"([^()\\\\ ]{0,16})\\(/,\n                end: /\\)([^()\\\\ ]{0,16})\"/\n            })\n        ]\n    };\n    const NUMBERS = {\n        className: \"number\",\n        variants: [\n            {\n                begin: \"\\\\b(0b[01']+)\"\n            },\n            {\n                begin: \"(-?)\\\\b([\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)((ll|LL|l|L)(u|U)?|(u|U)(ll|LL|l|L)?|f|F|b|B)\"\n            },\n            {\n                begin: \"(-?)(\\\\b0[xX][a-fA-F0-9']+|(\\\\b[\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)([eE][-+]?[\\\\d']+)?)\"\n            }\n        ],\n        relevance: 0\n    };\n    const PREPROCESSOR = {\n        className: \"meta\",\n        begin: /#\\s*[a-z]+\\b/,\n        end: /$/,\n        keywords: {\n            keyword: \"if else elif endif define undef warning error line \" + \"pragma _Pragma ifdef ifndef include\"\n        },\n        contains: [\n            {\n                begin: /\\\\\\n/,\n                relevance: 0\n            },\n            hljs.inherit(STRINGS, {\n                className: \"string\"\n            }),\n            {\n                className: \"string\",\n                begin: /<.*?>/\n            },\n            C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE\n        ]\n    };\n    const TITLE_MODE = {\n        className: \"title\",\n        begin: regex.optional(NAMESPACE_RE) + hljs.IDENT_RE,\n        relevance: 0\n    };\n    const FUNCTION_TITLE = regex.optional(NAMESPACE_RE) + hljs.IDENT_RE + \"\\\\s*\\\\(\";\n    // https://en.cppreference.com/w/cpp/keyword\n    const RESERVED_KEYWORDS = [\n        \"alignas\",\n        \"alignof\",\n        \"and\",\n        \"and_eq\",\n        \"asm\",\n        \"atomic_cancel\",\n        \"atomic_commit\",\n        \"atomic_noexcept\",\n        \"auto\",\n        \"bitand\",\n        \"bitor\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"co_await\",\n        \"co_return\",\n        \"co_yield\",\n        \"compl\",\n        \"concept\",\n        \"const_cast|10\",\n        \"consteval\",\n        \"constexpr\",\n        \"constinit\",\n        \"continue\",\n        \"decltype\",\n        \"default\",\n        \"delete\",\n        \"do\",\n        \"dynamic_cast|10\",\n        \"else\",\n        \"enum\",\n        \"explicit\",\n        \"export\",\n        \"extern\",\n        \"false\",\n        \"final\",\n        \"for\",\n        \"friend\",\n        \"goto\",\n        \"if\",\n        \"import\",\n        \"inline\",\n        \"module\",\n        \"mutable\",\n        \"namespace\",\n        \"new\",\n        \"noexcept\",\n        \"not\",\n        \"not_eq\",\n        \"nullptr\",\n        \"operator\",\n        \"or\",\n        \"or_eq\",\n        \"override\",\n        \"private\",\n        \"protected\",\n        \"public\",\n        \"reflexpr\",\n        \"register\",\n        \"reinterpret_cast|10\",\n        \"requires\",\n        \"return\",\n        \"sizeof\",\n        \"static_assert\",\n        \"static_cast|10\",\n        \"struct\",\n        \"switch\",\n        \"synchronized\",\n        \"template\",\n        \"this\",\n        \"thread_local\",\n        \"throw\",\n        \"transaction_safe\",\n        \"transaction_safe_dynamic\",\n        \"true\",\n        \"try\",\n        \"typedef\",\n        \"typeid\",\n        \"typename\",\n        \"union\",\n        \"using\",\n        \"virtual\",\n        \"volatile\",\n        \"while\",\n        \"xor\",\n        \"xor_eq\"\n    ];\n    // https://en.cppreference.com/w/cpp/keyword\n    const RESERVED_TYPES = [\n        \"bool\",\n        \"char\",\n        \"char16_t\",\n        \"char32_t\",\n        \"char8_t\",\n        \"double\",\n        \"float\",\n        \"int\",\n        \"long\",\n        \"short\",\n        \"void\",\n        \"wchar_t\",\n        \"unsigned\",\n        \"signed\",\n        \"const\",\n        \"static\"\n    ];\n    const TYPE_HINTS = [\n        \"any\",\n        \"auto_ptr\",\n        \"barrier\",\n        \"binary_semaphore\",\n        \"bitset\",\n        \"complex\",\n        \"condition_variable\",\n        \"condition_variable_any\",\n        \"counting_semaphore\",\n        \"deque\",\n        \"false_type\",\n        \"future\",\n        \"imaginary\",\n        \"initializer_list\",\n        \"istringstream\",\n        \"jthread\",\n        \"latch\",\n        \"lock_guard\",\n        \"multimap\",\n        \"multiset\",\n        \"mutex\",\n        \"optional\",\n        \"ostringstream\",\n        \"packaged_task\",\n        \"pair\",\n        \"promise\",\n        \"priority_queue\",\n        \"queue\",\n        \"recursive_mutex\",\n        \"recursive_timed_mutex\",\n        \"scoped_lock\",\n        \"set\",\n        \"shared_future\",\n        \"shared_lock\",\n        \"shared_mutex\",\n        \"shared_timed_mutex\",\n        \"shared_ptr\",\n        \"stack\",\n        \"string_view\",\n        \"stringstream\",\n        \"timed_mutex\",\n        \"thread\",\n        \"true_type\",\n        \"tuple\",\n        \"unique_lock\",\n        \"unique_ptr\",\n        \"unordered_map\",\n        \"unordered_multimap\",\n        \"unordered_multiset\",\n        \"unordered_set\",\n        \"variant\",\n        \"vector\",\n        \"weak_ptr\",\n        \"wstring\",\n        \"wstring_view\"\n    ];\n    const FUNCTION_HINTS = [\n        \"abort\",\n        \"abs\",\n        \"acos\",\n        \"apply\",\n        \"as_const\",\n        \"asin\",\n        \"atan\",\n        \"atan2\",\n        \"calloc\",\n        \"ceil\",\n        \"cerr\",\n        \"cin\",\n        \"clog\",\n        \"cos\",\n        \"cosh\",\n        \"cout\",\n        \"declval\",\n        \"endl\",\n        \"exchange\",\n        \"exit\",\n        \"exp\",\n        \"fabs\",\n        \"floor\",\n        \"fmod\",\n        \"forward\",\n        \"fprintf\",\n        \"fputs\",\n        \"free\",\n        \"frexp\",\n        \"fscanf\",\n        \"future\",\n        \"invoke\",\n        \"isalnum\",\n        \"isalpha\",\n        \"iscntrl\",\n        \"isdigit\",\n        \"isgraph\",\n        \"islower\",\n        \"isprint\",\n        \"ispunct\",\n        \"isspace\",\n        \"isupper\",\n        \"isxdigit\",\n        \"labs\",\n        \"launder\",\n        \"ldexp\",\n        \"log\",\n        \"log10\",\n        \"make_pair\",\n        \"make_shared\",\n        \"make_shared_for_overwrite\",\n        \"make_tuple\",\n        \"make_unique\",\n        \"malloc\",\n        \"memchr\",\n        \"memcmp\",\n        \"memcpy\",\n        \"memset\",\n        \"modf\",\n        \"move\",\n        \"pow\",\n        \"printf\",\n        \"putchar\",\n        \"puts\",\n        \"realloc\",\n        \"scanf\",\n        \"sin\",\n        \"sinh\",\n        \"snprintf\",\n        \"sprintf\",\n        \"sqrt\",\n        \"sscanf\",\n        \"std\",\n        \"stderr\",\n        \"stdin\",\n        \"stdout\",\n        \"strcat\",\n        \"strchr\",\n        \"strcmp\",\n        \"strcpy\",\n        \"strcspn\",\n        \"strlen\",\n        \"strncat\",\n        \"strncmp\",\n        \"strncpy\",\n        \"strpbrk\",\n        \"strrchr\",\n        \"strspn\",\n        \"strstr\",\n        \"swap\",\n        \"tan\",\n        \"tanh\",\n        \"terminate\",\n        \"to_underlying\",\n        \"tolower\",\n        \"toupper\",\n        \"vfprintf\",\n        \"visit\",\n        \"vprintf\",\n        \"vsprintf\"\n    ];\n    const LITERALS = [\n        \"NULL\",\n        \"false\",\n        \"nullopt\",\n        \"nullptr\",\n        \"true\"\n    ];\n    // https://en.cppreference.com/w/cpp/keyword\n    const BUILT_IN = [\n        \"_Pragma\"\n    ];\n    const CPP_KEYWORDS = {\n        type: RESERVED_TYPES,\n        keyword: RESERVED_KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_IN,\n        _type_hints: TYPE_HINTS\n    };\n    const FUNCTION_DISPATCH = {\n        className: \"function.dispatch\",\n        relevance: 0,\n        keywords: {\n            // Only for relevance, not highlighting.\n            _hint: FUNCTION_HINTS\n        },\n        begin: regex.concat(/\\b/, /(?!decltype)/, /(?!if)/, /(?!for)/, /(?!switch)/, /(?!while)/, hljs.IDENT_RE, regex.lookahead(/(<[^<>]+>|)\\s*\\(/))\n    };\n    const EXPRESSION_CONTAINS = [\n        FUNCTION_DISPATCH,\n        PREPROCESSOR,\n        CPP_PRIMITIVE_TYPES,\n        C_LINE_COMMENT_MODE,\n        hljs.C_BLOCK_COMMENT_MODE,\n        NUMBERS,\n        STRINGS\n    ];\n    const EXPRESSION_CONTEXT = {\n        // This mode covers expression context where we can't expect a function\n        // definition and shouldn't highlight anything that looks like one:\n        // `return some()`, `else if()`, `(x*sum(1, 2))`\n        variants: [\n            {\n                begin: /=/,\n                end: /;/\n            },\n            {\n                begin: /\\(/,\n                end: /\\)/\n            },\n            {\n                beginKeywords: \"new throw return else\",\n                end: /;/\n            }\n        ],\n        keywords: CPP_KEYWORDS,\n        contains: EXPRESSION_CONTAINS.concat([\n            {\n                begin: /\\(/,\n                end: /\\)/,\n                keywords: CPP_KEYWORDS,\n                contains: EXPRESSION_CONTAINS.concat([\n                    \"self\"\n                ]),\n                relevance: 0\n            }\n        ]),\n        relevance: 0\n    };\n    const FUNCTION_DECLARATION = {\n        className: \"function\",\n        begin: \"(\" + FUNCTION_TYPE_RE + \"[\\\\*&\\\\s]+)+\" + FUNCTION_TITLE,\n        returnBegin: true,\n        end: /[{;=]/,\n        excludeEnd: true,\n        keywords: CPP_KEYWORDS,\n        illegal: /[^\\w\\s\\*&:<>.]/,\n        contains: [\n            {\n                begin: DECLTYPE_AUTO_RE,\n                keywords: CPP_KEYWORDS,\n                relevance: 0\n            },\n            {\n                begin: FUNCTION_TITLE,\n                returnBegin: true,\n                contains: [\n                    TITLE_MODE\n                ],\n                relevance: 0\n            },\n            // needed because we do not have look-behind on the below rule\n            // to prevent it from grabbing the final : in a :: pair\n            {\n                begin: /::/,\n                relevance: 0\n            },\n            // initializers\n            {\n                begin: /:/,\n                endsWithParent: true,\n                contains: [\n                    STRINGS,\n                    NUMBERS\n                ]\n            },\n            // allow for multiple declarations, e.g.:\n            // extern void f(int), g(char);\n            {\n                relevance: 0,\n                match: /,/\n            },\n            {\n                className: \"params\",\n                begin: /\\(/,\n                end: /\\)/,\n                keywords: CPP_KEYWORDS,\n                relevance: 0,\n                contains: [\n                    C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE,\n                    STRINGS,\n                    NUMBERS,\n                    CPP_PRIMITIVE_TYPES,\n                    // Count matching parentheses.\n                    {\n                        begin: /\\(/,\n                        end: /\\)/,\n                        keywords: CPP_KEYWORDS,\n                        relevance: 0,\n                        contains: [\n                            \"self\",\n                            C_LINE_COMMENT_MODE,\n                            hljs.C_BLOCK_COMMENT_MODE,\n                            STRINGS,\n                            NUMBERS,\n                            CPP_PRIMITIVE_TYPES\n                        ]\n                    }\n                ]\n            },\n            CPP_PRIMITIVE_TYPES,\n            C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            PREPROCESSOR\n        ]\n    };\n    return {\n        name: \"C++\",\n        aliases: [\n            \"cc\",\n            \"c++\",\n            \"h++\",\n            \"hpp\",\n            \"hh\",\n            \"hxx\",\n            \"cxx\"\n        ],\n        keywords: CPP_KEYWORDS,\n        illegal: \"</\",\n        classNameAliases: {\n            \"function.dispatch\": \"built_in\"\n        },\n        contains: [].concat(EXPRESSION_CONTEXT, FUNCTION_DECLARATION, FUNCTION_DISPATCH, EXPRESSION_CONTAINS, [\n            PREPROCESSOR,\n            {\n                begin: \"\\\\b(deque|list|queue|priority_queue|pair|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array|tuple|optional|variant|function)\\\\s*<(?!<)\",\n                end: \">\",\n                keywords: CPP_KEYWORDS,\n                contains: [\n                    \"self\",\n                    CPP_PRIMITIVE_TYPES\n                ]\n            },\n            {\n                begin: hljs.IDENT_RE + \"::\",\n                keywords: CPP_KEYWORDS\n            },\n            {\n                match: [\n                    // extra complexity to deal with `enum class` and `enum struct`\n                    /\\b(?:enum(?:\\s+(?:class|struct))?|class|struct|union)/,\n                    /\\s+/,\n                    /\\w+/\n                ],\n                className: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ])\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9jcHAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7O0FBSUEsR0FFQSxxQkFBcUIsR0FDckIsU0FBU0EsSUFBSUMsSUFBSTtJQUNmLE1BQU1DLFFBQVFELEtBQUtDLEtBQUs7SUFDeEIscUVBQXFFO0lBQ3JFLHlFQUF5RTtJQUN6RSxtQ0FBbUM7SUFDbkMsTUFBTUMsc0JBQXNCRixLQUFLRyxPQUFPLENBQUMsTUFBTSxLQUFLO1FBQUVDLFVBQVU7WUFBRTtnQkFBRUMsT0FBTztZQUFPO1NBQUc7SUFBQztJQUN0RixNQUFNQyxtQkFBbUI7SUFDekIsTUFBTUMsZUFBZTtJQUNyQixNQUFNQyx1QkFBdUI7SUFDN0IsTUFBTUMsbUJBQW1CLGdCQUNyQkgsbUJBQW1CLE1BQ25CTCxNQUFNUyxRQUFRLENBQUNILGdCQUNmLGtCQUFrQk4sTUFBTVMsUUFBUSxDQUFDRix3QkFDbkM7SUFFRixNQUFNRyxzQkFBc0I7UUFDMUJDLFdBQVc7UUFDWFAsT0FBTztJQUNUO0lBRUEsb0RBQW9EO0lBQ3BELG9DQUFvQztJQUNwQyxNQUFNUSxvQkFBb0I7SUFDMUIsTUFBTUMsVUFBVTtRQUNkRixXQUFXO1FBQ1hHLFVBQVU7WUFDUjtnQkFDRVYsT0FBTztnQkFDUFcsS0FBSztnQkFDTEMsU0FBUztnQkFDVGIsVUFBVTtvQkFBRUosS0FBS2tCLGdCQUFnQjtpQkFBRTtZQUNyQztZQUNBO2dCQUNFYixPQUFPLGlCQUFrQlEsb0JBQW9CO2dCQUM3Q0csS0FBSztnQkFDTEMsU0FBUztZQUNYO1lBQ0FqQixLQUFLbUIsaUJBQWlCLENBQUM7Z0JBQ3JCZCxPQUFPO2dCQUNQVyxLQUFLO1lBQ1A7U0FDRDtJQUNIO0lBRUEsTUFBTUksVUFBVTtRQUNkUixXQUFXO1FBQ1hHLFVBQVU7WUFDUjtnQkFBRVYsT0FBTztZQUFpQjtZQUMxQjtnQkFBRUEsT0FBTztZQUEyRjtZQUNwRztnQkFBRUEsT0FBTztZQUEyRjtTQUNyRztRQUNEZ0IsV0FBVztJQUNiO0lBRUEsTUFBTUMsZUFBZTtRQUNuQlYsV0FBVztRQUNYUCxPQUFPO1FBQ1BXLEtBQUs7UUFDTE8sVUFBVTtZQUFFQyxTQUNSLHdEQUNFO1FBQXNDO1FBQzVDcEIsVUFBVTtZQUNSO2dCQUNFQyxPQUFPO2dCQUNQZ0IsV0FBVztZQUNiO1lBQ0FyQixLQUFLeUIsT0FBTyxDQUFDWCxTQUFTO2dCQUFFRixXQUFXO1lBQVM7WUFDNUM7Z0JBQ0VBLFdBQVc7Z0JBQ1hQLE9BQU87WUFDVDtZQUNBSDtZQUNBRixLQUFLMEIsb0JBQW9CO1NBQzFCO0lBQ0g7SUFFQSxNQUFNQyxhQUFhO1FBQ2pCZixXQUFXO1FBQ1hQLE9BQU9KLE1BQU1TLFFBQVEsQ0FBQ0gsZ0JBQWdCUCxLQUFLNEIsUUFBUTtRQUNuRFAsV0FBVztJQUNiO0lBRUEsTUFBTVEsaUJBQWlCNUIsTUFBTVMsUUFBUSxDQUFDSCxnQkFBZ0JQLEtBQUs0QixRQUFRLEdBQUc7SUFFdEUsNENBQTRDO0lBQzVDLE1BQU1FLG9CQUFvQjtRQUN4QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELDRDQUE0QztJQUM1QyxNQUFNQyxpQkFBaUI7UUFDckI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELE1BQU1DLGFBQWE7UUFDakI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUVELE1BQU1DLGlCQUFpQjtRQUNyQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7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QU0sQ0FDakJHLG9CQUNBRSxzQkFDQVAsbUJBQ0FJLHFCQUNBO1lBQ0V2QjtZQUNBO2dCQUNFakIsT0FBTztnQkFDUFcsS0FBSztnQkFDTE8sVUFBVWE7Z0JBQ1ZoQyxVQUFVO29CQUNSO29CQUNBTztpQkFDRDtZQUNIO1lBQ0E7Z0JBQ0VOLE9BQU9MLEtBQUs0QixRQUFRLEdBQUc7Z0JBQ3ZCTCxVQUFVYTtZQUNaO1lBQ0E7Z0JBQ0VnQixPQUFPO29CQUNMLCtEQUErRDtvQkFDL0Q7b0JBQ0E7b0JBQ0E7aUJBQ0Q7Z0JBQ0R4QyxXQUFXO29CQUNULEdBQUc7b0JBQ0gsR0FBRztnQkFDTDtZQUNGO1NBQ0Q7SUFDTDtBQUNGO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVmcmFnbWVudGluZy1pZGVhcy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2NwcC5qcz8yMWVmIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5MYW5ndWFnZTogQysrXG5DYXRlZ29yeTogY29tbW9uLCBzeXN0ZW1cbldlYnNpdGU6IGh0dHBzOi8vaXNvY3BwLm9yZ1xuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGNwcChobGpzKSB7XG4gIGNvbnN0IHJlZ2V4ID0gaGxqcy5yZWdleDtcbiAgLy8gYWRkZWQgZm9yIGhpc3RvcmljIHJlYXNvbnMgYmVjYXVzZSBgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFYCBkb2VzXG4gIC8vIG5vdCBpbmNsdWRlIHN1Y2ggc3VwcG9ydCBub3IgY2FuIHdlIGJlIHN1cmUgYWxsIHRoZSBncmFtbWFycyBkZXBlbmRpbmdcbiAgLy8gb24gaXQgd291bGQgZGVzaXJlIHRoaXMgYmVoYXZpb3JcbiAgY29uc3QgQ19MSU5FX0NPTU1FTlRfTU9ERSA9IGhsanMuQ09NTUVOVCgnLy8nLCAnJCcsIHsgY29udGFpbnM6IFsgeyBiZWdpbjogL1xcXFxcXG4vIH0gXSB9KTtcbiAgY29uc3QgREVDTFRZUEVfQVVUT19SRSA9ICdkZWNsdHlwZVxcXFwoYXV0b1xcXFwpJztcbiAgY29uc3QgTkFNRVNQQUNFX1JFID0gJ1thLXpBLVpfXVxcXFx3Kjo6JztcbiAgY29uc3QgVEVNUExBVEVfQVJHVU1FTlRfUkUgPSAnPFtePD5dKz4nO1xuICBjb25zdCBGVU5DVElPTl9UWVBFX1JFID0gJyg/IXN0cnVjdCkoJ1xuICAgICsgREVDTFRZUEVfQVVUT19SRSArICd8J1xuICAgICsgcmVnZXgub3B0aW9uYWwoTkFNRVNQQUNFX1JFKVxuICAgICsgJ1thLXpBLVpfXVxcXFx3KicgKyByZWdleC5vcHRpb25hbChURU1QTEFURV9BUkdVTUVOVF9SRSlcbiAgKyAnKSc7XG5cbiAgY29uc3QgQ1BQX1BSSU1JVElWRV9UWVBFUyA9IHtcbiAgICBjbGFzc05hbWU6ICd0eXBlJyxcbiAgICBiZWdpbjogJ1xcXFxiW2EtelxcXFxkX10qX3RcXFxcYidcbiAgfTtcblxuICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAvbGFuZ3VhZ2UvZXNjYXBlXG4gIC8vIFxcXFwgXFx4IFxceEZGIFxcdTI4MzcgXFx1MDAzMjM3NDcgXFwzNzRcbiAgY29uc3QgQ0hBUkFDVEVSX0VTQ0FQRVMgPSAnXFxcXFxcXFwoeFswLTlBLUZhLWZdezJ9fHVbMC05QS1GYS1mXXs0LDh9fFswLTddezN9fFxcXFxTKSc7XG4gIGNvbnN0IFNUUklOR1MgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICB2YXJpYW50czogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogJyh1OD98VXxMKT9cIicsXG4gICAgICAgIGVuZDogJ1wiJyxcbiAgICAgICAgaWxsZWdhbDogJ1xcXFxuJyxcbiAgICAgICAgY29udGFpbnM6IFsgaGxqcy5CQUNLU0xBU0hfRVNDQVBFIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAnKHU4P3xVfEwpP1xcJygnICsgQ0hBUkFDVEVSX0VTQ0FQRVMgKyAnfC4pJyxcbiAgICAgICAgZW5kOiAnXFwnJyxcbiAgICAgICAgaWxsZWdhbDogJy4nXG4gICAgICB9LFxuICAgICAgaGxqcy5FTkRfU0FNRV9BU19CRUdJTih7XG4gICAgICAgIGJlZ2luOiAvKD86dTg/fFV8TCk/UlwiKFteKClcXFxcIF17MCwxNn0pXFwoLyxcbiAgICAgICAgZW5kOiAvXFwpKFteKClcXFxcIF17MCwxNn0pXCIvXG4gICAgICB9KVxuICAgIF1cbiAgfTtcblxuICBjb25zdCBOVU1CRVJTID0ge1xuICAgIGNsYXNzTmFtZTogJ251bWJlcicsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHsgYmVnaW46ICdcXFxcYigwYlswMVxcJ10rKScgfSxcbiAgICAgIHsgYmVnaW46ICcoLT8pXFxcXGIoW1xcXFxkXFwnXSsoXFxcXC5bXFxcXGRcXCddKik/fFxcXFwuW1xcXFxkXFwnXSspKChsbHxMTHxsfEwpKHV8VSk/fCh1fFUpKGxsfExMfGx8TCk/fGZ8RnxifEIpJyB9LFxuICAgICAgeyBiZWdpbjogJygtPykoXFxcXGIwW3hYXVthLWZBLUYwLTlcXCddK3woXFxcXGJbXFxcXGRcXCddKyhcXFxcLltcXFxcZFxcJ10qKT98XFxcXC5bXFxcXGRcXCddKykoW2VFXVstK10/W1xcXFxkXFwnXSspPyknIH1cbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IFBSRVBST0NFU1NPUiA9IHtcbiAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICBiZWdpbjogLyNcXHMqW2Etel0rXFxiLyxcbiAgICBlbmQ6IC8kLyxcbiAgICBrZXl3b3JkczogeyBrZXl3b3JkOlxuICAgICAgICAnaWYgZWxzZSBlbGlmIGVuZGlmIGRlZmluZSB1bmRlZiB3YXJuaW5nIGVycm9yIGxpbmUgJ1xuICAgICAgICArICdwcmFnbWEgX1ByYWdtYSBpZmRlZiBpZm5kZWYgaW5jbHVkZScgfSxcbiAgICBjb250YWluczogW1xuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcXFxcXG4vLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBobGpzLmluaGVyaXQoU1RSSU5HUywgeyBjbGFzc05hbWU6ICdzdHJpbmcnIH0pLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICBiZWdpbjogLzwuKj8+L1xuICAgICAgfSxcbiAgICAgIENfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IFRJVExFX01PREUgPSB7XG4gICAgY2xhc3NOYW1lOiAndGl0bGUnLFxuICAgIGJlZ2luOiByZWdleC5vcHRpb25hbChOQU1FU1BBQ0VfUkUpICsgaGxqcy5JREVOVF9SRSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBGVU5DVElPTl9USVRMRSA9IHJlZ2V4Lm9wdGlvbmFsKE5BTUVTUEFDRV9SRSkgKyBobGpzLklERU5UX1JFICsgJ1xcXFxzKlxcXFwoJztcblxuICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAva2V5d29yZFxuICBjb25zdCBSRVNFUlZFRF9LRVlXT1JEUyA9IFtcbiAgICAnYWxpZ25hcycsXG4gICAgJ2FsaWdub2YnLFxuICAgICdhbmQnLFxuICAgICdhbmRfZXEnLFxuICAgICdhc20nLFxuICAgICdhdG9taWNfY2FuY2VsJyxcbiAgICAnYXRvbWljX2NvbW1pdCcsXG4gICAgJ2F0b21pY19ub2V4Y2VwdCcsXG4gICAgJ2F1dG8nLFxuICAgICdiaXRhbmQnLFxuICAgICdiaXRvcicsXG4gICAgJ2JyZWFrJyxcbiAgICAnY2FzZScsXG4gICAgJ2NhdGNoJyxcbiAgICAnY2xhc3MnLFxuICAgICdjb19hd2FpdCcsXG4gICAgJ2NvX3JldHVybicsXG4gICAgJ2NvX3lpZWxkJyxcbiAgICAnY29tcGwnLFxuICAgICdjb25jZXB0JyxcbiAgICAnY29uc3RfY2FzdHwxMCcsXG4gICAgJ2NvbnN0ZXZhbCcsXG4gICAgJ2NvbnN0ZXhwcicsXG4gICAgJ2NvbnN0aW5pdCcsXG4gICAgJ2NvbnRpbnVlJyxcbiAgICAnZGVjbHR5cGUnLFxuICAgICdkZWZhdWx0JyxcbiAgICAnZGVsZXRlJyxcbiAgICAnZG8nLFxuICAgICdkeW5hbWljX2Nhc3R8MTAnLFxuICAgICdlbHNlJyxcbiAgICAnZW51bScsXG4gICAgJ2V4cGxpY2l0JyxcbiAgICAnZXhwb3J0JyxcbiAgICAnZXh0ZXJuJyxcbiAgICAnZmFsc2UnLFxuICAgICdmaW5hbCcsXG4gICAgJ2ZvcicsXG4gICAgJ2ZyaWVuZCcsXG4gICAgJ2dvdG8nLFxuICAgICdpZicsXG4gICAgJ2ltcG9ydCcsXG4gICAgJ2lubGluZScsXG4gICAgJ21vZHVsZScsXG4gICAgJ211dGFibGUnLFxuICAgICduYW1lc3BhY2UnLFxuICAgICduZXcnLFxuICAgICdub2V4Y2VwdCcsXG4gICAgJ25vdCcsXG4gICAgJ25vdF9lcScsXG4gICAgJ251bGxwdHInLFxuICAgICdvcGVyYXRvcicsXG4gICAgJ29yJyxcbiAgICAnb3JfZXEnLFxuICAgICdvdmVycmlkZScsXG4gICAgJ3ByaXZhdGUnLFxuICAgICdwcm90ZWN0ZWQnLFxuICAgICdwdWJsaWMnLFxuICAgICdyZWZsZXhwcicsXG4gICAgJ3JlZ2lzdGVyJyxcbiAgICAncmVpbnRlcnByZXRfY2FzdHwxMCcsXG4gICAgJ3JlcXVpcmVzJyxcbiAgICAncmV0dXJuJyxcbiAgICAnc2l6ZW9mJyxcbiAgICAnc3RhdGljX2Fzc2VydCcsXG4gICAgJ3N0YXRpY19jYXN0fDEwJyxcbiAgICAnc3RydWN0JyxcbiAgICAnc3dpdGNoJyxcbiAgICAnc3luY2hyb25pemVkJyxcbiAgICAndGVtcGxhdGUnLFxuICAgICd0aGlzJyxcbiAgICAndGhyZWFkX2xvY2FsJyxcbiAgICAndGhyb3cnLFxuICAgICd0cmFuc2FjdGlvbl9zYWZlJyxcbiAgICAndHJhbnNhY3Rpb25fc2FmZV9keW5hbWljJyxcbiAgICAndHJ1ZScsXG4gICAgJ3RyeScsXG4gICAgJ3R5cGVkZWYnLFxuICAgICd0eXBlaWQnLFxuICAgICd0eXBlbmFtZScsXG4gICAgJ3VuaW9uJyxcbiAgICAndXNpbmcnLFxuICAgICd2aXJ0dWFsJyxcbiAgICAndm9sYXRpbGUnLFxuICAgICd3aGlsZScsXG4gICAgJ3hvcicsXG4gICAgJ3hvcl9lcSdcbiAgXTtcblxuICAvLyBodHRwczovL2VuLmNwcHJlZmVyZW5jZS5jb20vdy9jcHAva2V5d29yZFxuICBjb25zdCBSRVNFUlZFRF9UWVBFUyA9IFtcbiAgICAnYm9vbCcsXG4gICAgJ2NoYXInLFxuICAgICdjaGFyMTZfdCcsXG4gICAgJ2NoYXIzMl90JyxcbiAgICAnY2hhcjhfdCcsXG4gICAgJ2RvdWJsZScsXG4gICAgJ2Zsb2F0JyxcbiAgICAnaW50JyxcbiAgICAnbG9uZycsXG4gICAgJ3Nob3J0JyxcbiAgICAndm9pZCcsXG4gICAgJ3djaGFyX3QnLFxuICAgICd1bnNpZ25lZCcsXG4gICAgJ3NpZ25lZCcsXG4gICAgJ2NvbnN0JyxcbiAgICAnc3RhdGljJ1xuICBdO1xuXG4gIGNvbnN0IFRZUEVfSElOVFMgPSBbXG4gICAgJ2FueScsXG4gICAgJ2F1dG9fcHRyJyxcbiAgICAnYmFycmllcicsXG4gICAgJ2JpbmFyeV9zZW1hcGhvcmUnLFxuICAgICdiaXRzZXQnLFxuICAgICdjb21wbGV4JyxcbiAgICAnY29uZGl0aW9uX3ZhcmlhYmxlJyxcbiAgICAnY29uZGl0aW9uX3ZhcmlhYmxlX2FueScsXG4gICAgJ2NvdW50aW5nX3NlbWFwaG9yZScsXG4gICAgJ2RlcXVlJyxcbiAgICAnZmFsc2VfdHlwZScsXG4gICAgJ2Z1dHVyZScsXG4gICAgJ2ltYWdpbmFyeScsXG4gICAgJ2luaXRpYWxpemVyX2xpc3QnLFxuICAgICdpc3RyaW5nc3RyZWFtJyxcbiAgICAnanRocmVhZCcsXG4gICAgJ2xhdGNoJyxcbiAgICAnbG9ja19ndWFyZCcsXG4gICAgJ211bHRpbWFwJyxcbiAgICAnbXVsdGlzZXQnLFxuICAgICdtdXRleCcsXG4gICAgJ29wdGlvbmFsJyxcbiAgICAnb3N0cmluZ3N0cmVhbScsXG4gICAgJ3BhY2thZ2VkX3Rhc2snLFxuICAgICdwYWlyJyxcbiAgICAncHJvbWlzZScsXG4gICAgJ3ByaW9yaXR5X3F1ZXVlJyxcbiAgICAncXVldWUnLFxuICAgICdyZWN1cnNpdmVfbXV0ZXgnLFxuICAgICdyZWN1cnNpdmVfdGltZWRfbXV0ZXgnLFxuICAgICdzY29wZWRfbG9jaycsXG4gICAgJ3NldCcsXG4gICAgJ3NoYXJlZF9mdXR1cmUnLFxuICAgICdzaGFyZWRfbG9jaycsXG4gICAgJ3NoYXJlZF9tdXRleCcsXG4gICAgJ3NoYXJlZF90aW1lZF9tdXRleCcsXG4gICAgJ3NoYXJlZF9wdHInLFxuICAgICdzdGFjaycsXG4gICAgJ3N0cmluZ192aWV3JyxcbiAgICAnc3RyaW5nc3RyZWFtJyxcbiAgICAndGltZWRfbXV0ZXgnLFxuICAgICd0aHJlYWQnLFxuICAgICd0cnVlX3R5cGUnLFxuICAgICd0dXBsZScsXG4gICAgJ3VuaXF1ZV9sb2NrJyxcbiAgICAndW5pcXVlX3B0cicsXG4gICAgJ3Vub3JkZXJlZF9tYXAnLFxuICAgICd1bm9yZGVyZWRfbXVsdGltYXAnLFxuICAgICd1bm9yZGVyZWRfbXVsdGlzZXQnLFxuICAgICd1bm9yZGVyZWRfc2V0JyxcbiAgICAndmFyaWFudCcsXG4gICAgJ3ZlY3RvcicsXG4gICAgJ3dlYWtfcHRyJyxcbiAgICAnd3N0cmluZycsXG4gICAgJ3dzdHJpbmdfdmlldydcbiAgXTtcblxuICBjb25zdCBGVU5DVElPTl9ISU5UUyA9IFtcbiAgICAnYWJvcnQnLFxuICAgICdhYnMnLFxuICAgICdhY29zJyxcbiAgICAnYXBwbHknLFxuICAgICdhc19jb25zdCcsXG4gICAgJ2FzaW4nLFxuICAgICdhdGFuJyxcbiAgICAnYXRhbjInLFxuICAgICdjYWxsb2MnLFxuICAgICdjZWlsJyxcbiAgICAnY2VycicsXG4gICAgJ2NpbicsXG4gICAgJ2Nsb2cnLFxuICAgICdjb3MnLFxuICAgICdjb3NoJyxcbiAgICAnY291dCcsXG4gICAgJ2RlY2x2YWwnLFxuICAgICdlbmRsJyxcbiAgICAnZXhjaGFuZ2UnLFxuICAgICdleGl0JyxcbiAgICAnZXhwJyxcbiAgICAnZmFicycsXG4gICAgJ2Zsb29yJyxcbiAgICAnZm1vZCcsXG4gICAgJ2ZvcndhcmQnLFxuICAgICdmcHJpbnRmJyxcbiAgICAnZnB1dHMnLFxuICAgICdmcmVlJyxcbiAgICAnZnJleHAnLFxuICAgICdmc2NhbmYnLFxuICAgICdmdXR1cmUnLFxuICAgICdpbnZva2UnLFxuICAgICdpc2FsbnVtJyxcbiAgICAnaXNhbHBoYScsXG4gICAgJ2lzY250cmwnLFxuICAgICdpc2RpZ2l0JyxcbiAgICAnaXNncmFwaCcsXG4gICAgJ2lzbG93ZXInLFxuICAgICdpc3ByaW50JyxcbiAgICAnaXNwdW5jdCcsXG4gICAgJ2lzc3BhY2UnLFxuICAgICdpc3VwcGVyJyxcbiAgICAnaXN4ZGlnaXQnLFxuICAgICdsYWJzJyxcbiAgICAnbGF1bmRlcicsXG4gICAgJ2xkZXhwJyxcbiAgICAnbG9nJyxcbiAgICAnbG9nMTAnLFxuICAgICdtYWtlX3BhaXInLFxuICAgICdtYWtlX3NoYXJlZCcsXG4gICAgJ21ha2Vfc2hhcmVkX2Zvcl9vdmVyd3JpdGUnLFxuICAgICdtYWtlX3R1cGxlJyxcbiAgICAnbWFrZV91bmlxdWUnLFxuICAgICdtYWxsb2MnLFxuICAgICdtZW1jaHInLFxuICAgICdtZW1jbXAnLFxuICAgICdtZW1jcHknLFxuICAgICdtZW1zZXQnLFxuICAgICdtb2RmJyxcbiAgICAnbW92ZScsXG4gICAgJ3BvdycsXG4gICAgJ3ByaW50ZicsXG4gICAgJ3B1dGNoYXInLFxuICAgICdwdXRzJyxcbiAgICAncmVhbGxvYycsXG4gICAgJ3NjYW5mJyxcbiAgICAnc2luJyxcbiAgICAnc2luaCcsXG4gICAgJ3NucHJpbnRmJyxcbiAgICAnc3ByaW50ZicsXG4gICAgJ3NxcnQnLFxuICAgICdzc2NhbmYnLFxuICAgICdzdGQnLFxuICAgICdzdGRlcnInLFxuICAgICdzdGRpbicsXG4gICAgJ3N0ZG91dCcsXG4gICAgJ3N0cmNhdCcsXG4gICAgJ3N0cmNocicsXG4gICAgJ3N0cmNtcCcsXG4gICAgJ3N0cmNweScsXG4gICAgJ3N0cmNzcG4nLFxuICAgICdzdHJsZW4nLFxuICAgICdzdHJuY2F0JyxcbiAgICAnc3RybmNtcCcsXG4gICAgJ3N0cm5jcHknLFxuICAgICdzdHJwYnJrJyxcbiAgICAnc3RycmNocicsXG4gICAgJ3N0cnNwbicsXG4gICAgJ3N0cnN0cicsXG4gICAgJ3N3YXAnLFxuICAgICd0YW4nLFxuICAgICd0YW5oJyxcbiAgICAndGVybWluYXRlJyxcbiAgICAndG9fdW5kZXJseWluZycsXG4gICAgJ3RvbG93ZXInLFxuICAgICd0b3VwcGVyJyxcbiAgICAndmZwcmludGYnLFxuICAgICd2aXNpdCcsXG4gICAgJ3ZwcmludGYnLFxuICAgICd2c3ByaW50ZidcbiAgXTtcblxuICBjb25zdCBMSVRFUkFMUyA9IFtcbiAgICAnTlVMTCcsXG4gICAgJ2ZhbHNlJyxcbiAgICAnbnVsbG9wdCcsXG4gICAgJ251bGxwdHInLFxuICAgICd0cnVlJ1xuICBdO1xuXG4gIC8vIGh0dHBzOi8vZW4uY3BwcmVmZXJlbmNlLmNvbS93L2NwcC9rZXl3b3JkXG4gIGNvbnN0IEJVSUxUX0lOID0gWyAnX1ByYWdtYScgXTtcblxuICBjb25zdCBDUFBfS0VZV09SRFMgPSB7XG4gICAgdHlwZTogUkVTRVJWRURfVFlQRVMsXG4gICAga2V5d29yZDogUkVTRVJWRURfS0VZV09SRFMsXG4gICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgYnVpbHRfaW46IEJVSUxUX0lOLFxuICAgIF90eXBlX2hpbnRzOiBUWVBFX0hJTlRTXG4gIH07XG5cbiAgY29uc3QgRlVOQ1RJT05fRElTUEFUQ0ggPSB7XG4gICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24uZGlzcGF0Y2gnLFxuICAgIHJlbGV2YW5jZTogMCxcbiAgICBrZXl3b3Jkczoge1xuICAgICAgLy8gT25seSBmb3IgcmVsZXZhbmNlLCBub3QgaGlnaGxpZ2h0aW5nLlxuICAgICAgX2hpbnQ6IEZVTkNUSU9OX0hJTlRTIH0sXG4gICAgYmVnaW46IHJlZ2V4LmNvbmNhdChcbiAgICAgIC9cXGIvLFxuICAgICAgLyg/IWRlY2x0eXBlKS8sXG4gICAgICAvKD8haWYpLyxcbiAgICAgIC8oPyFmb3IpLyxcbiAgICAgIC8oPyFzd2l0Y2gpLyxcbiAgICAgIC8oPyF3aGlsZSkvLFxuICAgICAgaGxqcy5JREVOVF9SRSxcbiAgICAgIHJlZ2V4Lmxvb2thaGVhZCgvKDxbXjw+XSs+fClcXHMqXFwoLykpXG4gIH07XG5cbiAgY29uc3QgRVhQUkVTU0lPTl9DT05UQUlOUyA9IFtcbiAgICBGVU5DVElPTl9ESVNQQVRDSCxcbiAgICBQUkVQUk9DRVNTT1IsXG4gICAgQ1BQX1BSSU1JVElWRV9UWVBFUyxcbiAgICBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgTlVNQkVSUyxcbiAgICBTVFJJTkdTXG4gIF07XG5cbiAgY29uc3QgRVhQUkVTU0lPTl9DT05URVhUID0ge1xuICAgIC8vIFRoaXMgbW9kZSBjb3ZlcnMgZXhwcmVzc2lvbiBjb250ZXh0IHdoZXJlIHdlIGNhbid0IGV4cGVjdCBhIGZ1bmN0aW9uXG4gICAgLy8gZGVmaW5pdGlvbiBhbmQgc2hvdWxkbid0IGhpZ2hsaWdodCBhbnl0aGluZyB0aGF0IGxvb2tzIGxpa2Ugb25lOlxuICAgIC8vIGByZXR1cm4gc29tZSgpYCwgYGVsc2UgaWYoKWAsIGAoeCpzdW0oMSwgMikpYFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPS8sXG4gICAgICAgIGVuZDogLzsvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS9cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICduZXcgdGhyb3cgcmV0dXJuIGVsc2UnLFxuICAgICAgICBlbmQ6IC87L1xuICAgICAgfVxuICAgIF0sXG4gICAga2V5d29yZHM6IENQUF9LRVlXT1JEUyxcbiAgICBjb250YWluczogRVhQUkVTU0lPTl9DT05UQUlOUy5jb25jYXQoW1xuICAgICAge1xuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBFWFBSRVNTSU9OX0NPTlRBSU5TLmNvbmNhdChbICdzZWxmJyBdKSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9XG4gICAgXSksXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgRlVOQ1RJT05fREVDTEFSQVRJT04gPSB7XG4gICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgIGJlZ2luOiAnKCcgKyBGVU5DVElPTl9UWVBFX1JFICsgJ1tcXFxcKiZcXFxcc10rKSsnICsgRlVOQ1RJT05fVElUTEUsXG4gICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgZW5kOiAvW3s7PV0vLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAga2V5d29yZHM6IENQUF9LRVlXT1JEUyxcbiAgICBpbGxlZ2FsOiAvW15cXHdcXHNcXComOjw+Ll0vLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7IC8vIHRvIHByZXZlbnQgaXQgZnJvbSBiZWluZyBjb25mdXNlZCBhcyB0aGUgZnVuY3Rpb24gdGl0bGVcbiAgICAgICAgYmVnaW46IERFQ0xUWVBFX0FVVE9fUkUsXG4gICAgICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IEZVTkNUSU9OX1RJVExFLFxuICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFsgVElUTEVfTU9ERSBdLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICAvLyBuZWVkZWQgYmVjYXVzZSB3ZSBkbyBub3QgaGF2ZSBsb29rLWJlaGluZCBvbiB0aGUgYmVsb3cgcnVsZVxuICAgICAgLy8gdG8gcHJldmVudCBpdCBmcm9tIGdyYWJiaW5nIHRoZSBmaW5hbCA6IGluIGEgOjogcGFpclxuICAgICAge1xuICAgICAgICBiZWdpbjogLzo6LyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgLy8gaW5pdGlhbGl6ZXJzXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvOi8sXG4gICAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFNUUklOR1MsXG4gICAgICAgICAgTlVNQkVSU1xuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgLy8gYWxsb3cgZm9yIG11bHRpcGxlIGRlY2xhcmF0aW9ucywgZS5nLjpcbiAgICAgIC8vIGV4dGVybiB2b2lkIGYoaW50KSwgZyhjaGFyKTtcbiAgICAgIHtcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBtYXRjaDogLywvXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBDX0xJTkVfQ09NTUVOVF9NT0RFLFxuICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgU1RSSU5HUyxcbiAgICAgICAgICBOVU1CRVJTLFxuICAgICAgICAgIENQUF9QUklNSVRJVkVfVFlQRVMsXG4gICAgICAgICAgLy8gQ291bnQgbWF0Y2hpbmcgcGFyZW50aGVzZXMuXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW46IC9cXCgvLFxuICAgICAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICAnc2VsZicsXG4gICAgICAgICAgICAgIENfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICAgICAgICAgIFNUUklOR1MsXG4gICAgICAgICAgICAgIE5VTUJFUlMsXG4gICAgICAgICAgICAgIENQUF9QUklNSVRJVkVfVFlQRVNcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICBDUFBfUFJJTUlUSVZFX1RZUEVTLFxuICAgICAgQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19CTE9DS19DT01NRU5UX01PREUsXG4gICAgICBQUkVQUk9DRVNTT1JcbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQysrJyxcbiAgICBhbGlhc2VzOiBbXG4gICAgICAnY2MnLFxuICAgICAgJ2MrKycsXG4gICAgICAnaCsrJyxcbiAgICAgICdocHAnLFxuICAgICAgJ2hoJyxcbiAgICAgICdoeHgnLFxuICAgICAgJ2N4eCdcbiAgICBdLFxuICAgIGtleXdvcmRzOiBDUFBfS0VZV09SRFMsXG4gICAgaWxsZWdhbDogJzwvJyxcbiAgICBjbGFzc05hbWVBbGlhc2VzOiB7ICdmdW5jdGlvbi5kaXNwYXRjaCc6ICdidWlsdF9pbicgfSxcbiAgICBjb250YWluczogW10uY29uY2F0KFxuICAgICAgRVhQUkVTU0lPTl9DT05URVhULFxuICAgICAgRlVOQ1RJT05fREVDTEFSQVRJT04sXG4gICAgICBGVU5DVElPTl9ESVNQQVRDSCxcbiAgICAgIEVYUFJFU1NJT05fQ09OVEFJTlMsXG4gICAgICBbXG4gICAgICAgIFBSRVBST0NFU1NPUixcbiAgICAgICAgeyAvLyBjb250YWluZXJzOiBpZSwgYHZlY3RvciA8aW50PiByb29tcyAoOSk7YFxuICAgICAgICAgIGJlZ2luOiAnXFxcXGIoZGVxdWV8bGlzdHxxdWV1ZXxwcmlvcml0eV9xdWV1ZXxwYWlyfHN0YWNrfHZlY3RvcnxtYXB8c2V0fGJpdHNldHxtdWx0aXNldHxtdWx0aW1hcHx1bm9yZGVyZWRfbWFwfHVub3JkZXJlZF9zZXR8dW5vcmRlcmVkX211bHRpc2V0fHVub3JkZXJlZF9tdWx0aW1hcHxhcnJheXx0dXBsZXxvcHRpb25hbHx2YXJpYW50fGZ1bmN0aW9uKVxcXFxzKjwoPyE8KScsXG4gICAgICAgICAgZW5kOiAnPicsXG4gICAgICAgICAga2V5d29yZHM6IENQUF9LRVlXT1JEUyxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgJ3NlbGYnLFxuICAgICAgICAgICAgQ1BQX1BSSU1JVElWRV9UWVBFU1xuICAgICAgICAgIF1cbiAgICAgICAgfSxcbiAgICAgICAge1xuICAgICAgICAgIGJlZ2luOiBobGpzLklERU5UX1JFICsgJzo6JyxcbiAgICAgICAgICBrZXl3b3JkczogQ1BQX0tFWVdPUkRTXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICBtYXRjaDogW1xuICAgICAgICAgICAgLy8gZXh0cmEgY29tcGxleGl0eSB0byBkZWFsIHdpdGggYGVudW0gY2xhc3NgIGFuZCBgZW51bSBzdHJ1Y3RgXG4gICAgICAgICAgICAvXFxiKD86ZW51bSg/OlxccysoPzpjbGFzc3xzdHJ1Y3QpKT98Y2xhc3N8c3RydWN0fHVuaW9uKS8sXG4gICAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgICAvXFx3Ky9cbiAgICAgICAgICBdLFxuICAgICAgICAgIGNsYXNzTmFtZToge1xuICAgICAgICAgICAgMTogJ2tleXdvcmQnLFxuICAgICAgICAgICAgMzogJ3RpdGxlLmNsYXNzJ1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgXSlcbiAgfTtcbn1cblxuZXhwb3J0IHsgY3BwIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJjcHAiLCJobGpzIiwicmVnZXgiLCJDX0xJTkVfQ09NTUVOVF9NT0RFIiwiQ09NTUVOVCIsImNvbnRhaW5zIiwiYmVnaW4iLCJERUNMVFlQRV9BVVRPX1JFIiwiTkFNRVNQQUNFX1JFIiwiVEVNUExBVEVfQVJHVU1FTlRfUkUiLCJGVU5DVElPTl9UWVBFX1JFIiwib3B0aW9uYWwiLCJDUFBfUFJJTUlUSVZFX1RZUEVTIiwiY2xhc3NOYW1lIiwiQ0hBUkFDVEVSX0VTQ0FQRVMiLCJTVFJJTkdTIiwidmFyaWFudHMiLCJlbmQiLCJpbGxlZ2FsIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIkVORF9TQU1FX0FTX0JFR0lOIiwiTlVNQkVSUyIsInJlbGV2YW5jZSIsIlBSRVBST0NFU1NPUiIsImtleXdvcmRzIiwia2V5d29yZCIsImluaGVyaXQiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIlRJVExFX01PREUiLCJJREVOVF9SRSIsIkZVTkNUSU9OX1RJVExFIiwiUkVTRVJWRURfS0VZV09SRFMiLCJSRVNFUlZFRF9UWVBFUyIsIlRZUEVfSElOVFMiLCJGVU5DVElPTl9ISU5UUyIsIkxJVEVSQUxTIiwiQlVJTFRfSU4iLCJDUFBfS0VZV09SRFMiLCJ0eXBlIiwibGl0ZXJhbCIsImJ1aWx0X2luIiwiX3R5cGVfaGludHMiLCJGVU5DVElPTl9ESVNQQVRDSCIsIl9oaW50IiwiY29uY2F0IiwibG9va2FoZWFkIiwiRVhQUkVTU0lPTl9DT05UQUlOUyIsIkVYUFJFU1NJT05fQ09OVEVYVCIsImJlZ2luS2V5d29yZHMiLCJGVU5DVElPTl9ERUNMQVJBVElPTiIsInJldHVybkJlZ2luIiwiZXhjbHVkZUVuZCIsImVuZHNXaXRoUGFyZW50IiwibWF0Y2giLCJuYW1lIiwiYWxpYXNlcyIsImNsYXNzTmFtZUFsaWFzZXMiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/cpp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/csharp.js":
/*!**********************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/csharp.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ csharp)\n/* harmony export */ });\n/*\nLanguage: C#\nAuthor: Jason Diamond <jason@diamond.name>\nContributor: Nicolas LLOBERA <nllobera@gmail.com>, Pieter Vantorre <pietervantorre@gmail.com>, David Pine <david.pine@microsoft.com>\nWebsite: https://docs.microsoft.com/dotnet/csharp/\nCategory: common\n*/ /** @type LanguageFn */ function csharp(hljs) {\n    const BUILT_IN_KEYWORDS = [\n        \"bool\",\n        \"byte\",\n        \"char\",\n        \"decimal\",\n        \"delegate\",\n        \"double\",\n        \"dynamic\",\n        \"enum\",\n        \"float\",\n        \"int\",\n        \"long\",\n        \"nint\",\n        \"nuint\",\n        \"object\",\n        \"sbyte\",\n        \"short\",\n        \"string\",\n        \"ulong\",\n        \"uint\",\n        \"ushort\"\n    ];\n    const FUNCTION_MODIFIERS = [\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"static\",\n        \"internal\",\n        \"protected\",\n        \"abstract\",\n        \"async\",\n        \"extern\",\n        \"override\",\n        \"unsafe\",\n        \"virtual\",\n        \"new\",\n        \"sealed\",\n        \"partial\"\n    ];\n    const LITERAL_KEYWORDS = [\n        \"default\",\n        \"false\",\n        \"null\",\n        \"true\"\n    ];\n    const NORMAL_KEYWORDS = [\n        \"abstract\",\n        \"as\",\n        \"base\",\n        \"break\",\n        \"case\",\n        \"catch\",\n        \"class\",\n        \"const\",\n        \"continue\",\n        \"do\",\n        \"else\",\n        \"event\",\n        \"explicit\",\n        \"extern\",\n        \"finally\",\n        \"fixed\",\n        \"for\",\n        \"foreach\",\n        \"goto\",\n        \"if\",\n        \"implicit\",\n        \"in\",\n        \"interface\",\n        \"internal\",\n        \"is\",\n        \"lock\",\n        \"namespace\",\n        \"new\",\n        \"operator\",\n        \"out\",\n        \"override\",\n        \"params\",\n        \"private\",\n        \"protected\",\n        \"public\",\n        \"readonly\",\n        \"record\",\n        \"ref\",\n        \"return\",\n        \"scoped\",\n        \"sealed\",\n        \"sizeof\",\n        \"stackalloc\",\n        \"static\",\n        \"struct\",\n        \"switch\",\n        \"this\",\n        \"throw\",\n        \"try\",\n        \"typeof\",\n        \"unchecked\",\n        \"unsafe\",\n        \"using\",\n        \"virtual\",\n        \"void\",\n        \"volatile\",\n        \"while\"\n    ];\n    const CONTEXTUAL_KEYWORDS = [\n        \"add\",\n        \"alias\",\n        \"and\",\n        \"ascending\",\n        \"async\",\n        \"await\",\n        \"by\",\n        \"descending\",\n        \"equals\",\n        \"from\",\n        \"get\",\n        \"global\",\n        \"group\",\n        \"init\",\n        \"into\",\n        \"join\",\n        \"let\",\n        \"nameof\",\n        \"not\",\n        \"notnull\",\n        \"on\",\n        \"or\",\n        \"orderby\",\n        \"partial\",\n        \"remove\",\n        \"select\",\n        \"set\",\n        \"unmanaged\",\n        \"value|0\",\n        \"var\",\n        \"when\",\n        \"where\",\n        \"with\",\n        \"yield\"\n    ];\n    const KEYWORDS = {\n        keyword: NORMAL_KEYWORDS.concat(CONTEXTUAL_KEYWORDS),\n        built_in: BUILT_IN_KEYWORDS,\n        literal: LITERAL_KEYWORDS\n    };\n    const TITLE_MODE = hljs.inherit(hljs.TITLE_MODE, {\n        begin: \"[a-zA-Z](\\\\.?\\\\w)*\"\n    });\n    const NUMBERS = {\n        className: \"number\",\n        variants: [\n            {\n                begin: \"\\\\b(0b[01']+)\"\n            },\n            {\n                begin: \"(-?)\\\\b([\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)(u|U|l|L|ul|UL|f|F|b|B)\"\n            },\n            {\n                begin: \"(-?)(\\\\b0[xX][a-fA-F0-9']+|(\\\\b[\\\\d']+(\\\\.[\\\\d']*)?|\\\\.[\\\\d']+)([eE][-+]?[\\\\d']+)?)\"\n            }\n        ],\n        relevance: 0\n    };\n    const VERBATIM_STRING = {\n        className: \"string\",\n        begin: '@\"',\n        end: '\"',\n        contains: [\n            {\n                begin: '\"\"'\n            }\n        ]\n    };\n    const VERBATIM_STRING_NO_LF = hljs.inherit(VERBATIM_STRING, {\n        illegal: /\\n/\n    });\n    const SUBST = {\n        className: \"subst\",\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS\n    };\n    const SUBST_NO_LF = hljs.inherit(SUBST, {\n        illegal: /\\n/\n    });\n    const INTERPOLATED_STRING = {\n        className: \"string\",\n        begin: /\\$\"/,\n        end: '\"',\n        illegal: /\\n/,\n        contains: [\n            {\n                begin: /\\{\\{/\n            },\n            {\n                begin: /\\}\\}/\n            },\n            hljs.BACKSLASH_ESCAPE,\n            SUBST_NO_LF\n        ]\n    };\n    const INTERPOLATED_VERBATIM_STRING = {\n        className: \"string\",\n        begin: /\\$@\"/,\n        end: '\"',\n        contains: [\n            {\n                begin: /\\{\\{/\n            },\n            {\n                begin: /\\}\\}/\n            },\n            {\n                begin: '\"\"'\n            },\n            SUBST\n        ]\n    };\n    const INTERPOLATED_VERBATIM_STRING_NO_LF = hljs.inherit(INTERPOLATED_VERBATIM_STRING, {\n        illegal: /\\n/,\n        contains: [\n            {\n                begin: /\\{\\{/\n            },\n            {\n                begin: /\\}\\}/\n            },\n            {\n                begin: '\"\"'\n            },\n            SUBST_NO_LF\n        ]\n    });\n    SUBST.contains = [\n        INTERPOLATED_VERBATIM_STRING,\n        INTERPOLATED_STRING,\n        VERBATIM_STRING,\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        NUMBERS,\n        hljs.C_BLOCK_COMMENT_MODE\n    ];\n    SUBST_NO_LF.contains = [\n        INTERPOLATED_VERBATIM_STRING_NO_LF,\n        INTERPOLATED_STRING,\n        VERBATIM_STRING_NO_LF,\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        NUMBERS,\n        hljs.inherit(hljs.C_BLOCK_COMMENT_MODE, {\n            illegal: /\\n/\n        })\n    ];\n    const STRING = {\n        variants: [\n            INTERPOLATED_VERBATIM_STRING,\n            INTERPOLATED_STRING,\n            VERBATIM_STRING,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE\n        ]\n    };\n    const GENERIC_MODIFIER = {\n        begin: \"<\",\n        end: \">\",\n        contains: [\n            {\n                beginKeywords: \"in out\"\n            },\n            TITLE_MODE\n        ]\n    };\n    const TYPE_IDENT_RE = hljs.IDENT_RE + \"(<\" + hljs.IDENT_RE + \"(\\\\s*,\\\\s*\" + hljs.IDENT_RE + \")*>)?(\\\\[\\\\])?\";\n    const AT_IDENTIFIER = {\n        // prevents expressions like `@class` from incorrect flagging\n        // `class` as a keyword\n        begin: \"@\" + hljs.IDENT_RE,\n        relevance: 0\n    };\n    return {\n        name: \"C#\",\n        aliases: [\n            \"cs\",\n            \"c#\"\n        ],\n        keywords: KEYWORDS,\n        illegal: /::/,\n        contains: [\n            hljs.COMMENT(\"///\", \"$\", {\n                returnBegin: true,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        variants: [\n                            {\n                                begin: \"///\",\n                                relevance: 0\n                            },\n                            {\n                                begin: \"<!--|-->\"\n                            },\n                            {\n                                begin: \"</?\",\n                                end: \">\"\n                            }\n                        ]\n                    }\n                ]\n            }),\n            hljs.C_LINE_COMMENT_MODE,\n            hljs.C_BLOCK_COMMENT_MODE,\n            {\n                className: \"meta\",\n                begin: \"#\",\n                end: \"$\",\n                keywords: {\n                    keyword: \"if else elif endif define undef warning error line region endregion pragma checksum\"\n                }\n            },\n            STRING,\n            NUMBERS,\n            {\n                beginKeywords: \"class interface\",\n                relevance: 0,\n                end: /[{;=]/,\n                illegal: /[^\\s:,]/,\n                contains: [\n                    {\n                        beginKeywords: \"where class\"\n                    },\n                    TITLE_MODE,\n                    GENERIC_MODIFIER,\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            {\n                beginKeywords: \"namespace\",\n                relevance: 0,\n                end: /[{;=]/,\n                illegal: /[^\\s:]/,\n                contains: [\n                    TITLE_MODE,\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            {\n                beginKeywords: \"record\",\n                relevance: 0,\n                end: /[{;=]/,\n                illegal: /[^\\s:]/,\n                contains: [\n                    TITLE_MODE,\n                    GENERIC_MODIFIER,\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            {\n                // [Attributes(\"\")]\n                className: \"meta\",\n                begin: \"^\\\\s*\\\\[(?=[\\\\w])\",\n                excludeBegin: true,\n                end: \"\\\\]\",\n                excludeEnd: true,\n                contains: [\n                    {\n                        className: \"string\",\n                        begin: /\"/,\n                        end: /\"/\n                    }\n                ]\n            },\n            {\n                // Expression keywords prevent 'keyword Name(...)' from being\n                // recognized as a function definition\n                beginKeywords: \"new return throw await else\",\n                relevance: 0\n            },\n            {\n                className: \"function\",\n                begin: \"(\" + TYPE_IDENT_RE + \"\\\\s+)+\" + hljs.IDENT_RE + \"\\\\s*(<[^=]+>\\\\s*)?\\\\(\",\n                returnBegin: true,\n                end: /\\s*[{;=]/,\n                excludeEnd: true,\n                keywords: KEYWORDS,\n                contains: [\n                    // prevents these from being highlighted `title`\n                    {\n                        beginKeywords: FUNCTION_MODIFIERS.join(\" \"),\n                        relevance: 0\n                    },\n                    {\n                        begin: hljs.IDENT_RE + \"\\\\s*(<[^=]+>\\\\s*)?\\\\(\",\n                        returnBegin: true,\n                        contains: [\n                            hljs.TITLE_MODE,\n                            GENERIC_MODIFIER\n                        ],\n                        relevance: 0\n                    },\n                    {\n                        match: /\\(\\)/\n                    },\n                    {\n                        className: \"params\",\n                        begin: /\\(/,\n                        end: /\\)/,\n                        excludeBegin: true,\n                        excludeEnd: true,\n                        keywords: KEYWORDS,\n                        relevance: 0,\n                        contains: [\n                            STRING,\n                            NUMBERS,\n                            hljs.C_BLOCK_COMMENT_MODE\n                        ]\n                    },\n                    hljs.C_LINE_COMMENT_MODE,\n                    hljs.C_BLOCK_COMMENT_MODE\n                ]\n            },\n            AT_IDENTIFIER\n        ]\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9jc2hhcnAuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7QUFNQSxHQUVBLHFCQUFxQixHQUNyQixTQUFTQSxPQUFPQyxJQUFJO0lBQ2xCLE1BQU1DLG9CQUFvQjtRQUN4QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNQyxxQkFBcUI7UUFDekI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO0tBQ0Q7SUFDRCxNQUFNQyxtQkFBbUI7UUFDdkI7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE1BQU1DLGtCQUFrQjtRQUN0QjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7S0FDRDtJQUNELE1BQU1DLHNCQUFzQjtRQUMxQjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNB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O2dCQUNFLDZEQUE2RDtnQkFDN0Qsc0NBQXNDO2dCQUN0Q2dCLGVBQWU7Z0JBQ2ZsQixXQUFXO1lBQ2I7WUFDQTtnQkFDRUYsV0FBVztnQkFDWEYsT0FBTyxNQUFNdUIsZ0JBQWdCLFdBQVdwQyxLQUFLcUMsUUFBUSxHQUFHO2dCQUN4REssYUFBYTtnQkFDYnZCLEtBQUs7Z0JBQ0wwQixZQUFZO2dCQUNackIsVUFBVWxCO2dCQUNWYyxVQUFVO29CQUNSLGdEQUFnRDtvQkFDaEQ7d0JBQ0VlLGVBQWVqQyxtQkFBbUI0QyxJQUFJLENBQUM7d0JBQ3ZDN0IsV0FBVztvQkFDYjtvQkFDQTt3QkFDRUosT0FBT2IsS0FBS3FDLFFBQVEsR0FBRzt3QkFDdkJLLGFBQWE7d0JBQ2J0QixVQUFVOzRCQUNScEIsS0FBS1csVUFBVTs0QkFDZnVCO3lCQUNEO3dCQUNEakIsV0FBVztvQkFDYjtvQkFDQTt3QkFBRThCLE9BQU87b0JBQU87b0JBQ2hCO3dCQUNFaEMsV0FBVzt3QkFDWEYsT0FBTzt3QkFDUE0sS0FBSzt3QkFDTHlCLGNBQWM7d0JBQ2RDLFlBQVk7d0JBQ1pyQixVQUFVbEI7d0JBQ1ZXLFdBQVc7d0JBQ1hHLFVBQVU7NEJBQ1JhOzRCQUNBbkI7NEJBQ0FkLEtBQUtnQyxvQkFBb0I7eUJBQzFCO29CQUNIO29CQUNBaEMsS0FBSzJDLG1CQUFtQjtvQkFDeEIzQyxLQUFLZ0Msb0JBQW9CO2lCQUMxQjtZQUNIO1lBQ0FNO1NBQ0Q7SUFDSDtBQUNGO0FBRTZCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVmcmFnbWVudGluZy1pZGVhcy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2NzaGFycC5qcz9lOTUxIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG5MYW5ndWFnZTogQyNcbkF1dGhvcjogSmFzb24gRGlhbW9uZCA8amFzb25AZGlhbW9uZC5uYW1lPlxuQ29udHJpYnV0b3I6IE5pY29sYXMgTExPQkVSQSA8bmxsb2JlcmFAZ21haWwuY29tPiwgUGlldGVyIFZhbnRvcnJlIDxwaWV0ZXJ2YW50b3JyZUBnbWFpbC5jb20+LCBEYXZpZCBQaW5lIDxkYXZpZC5waW5lQG1pY3Jvc29mdC5jb20+XG5XZWJzaXRlOiBodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9kb3RuZXQvY3NoYXJwL1xuQ2F0ZWdvcnk6IGNvbW1vblxuKi9cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGNzaGFycChobGpzKSB7XG4gIGNvbnN0IEJVSUxUX0lOX0tFWVdPUkRTID0gW1xuICAgICdib29sJyxcbiAgICAnYnl0ZScsXG4gICAgJ2NoYXInLFxuICAgICdkZWNpbWFsJyxcbiAgICAnZGVsZWdhdGUnLFxuICAgICdkb3VibGUnLFxuICAgICdkeW5hbWljJyxcbiAgICAnZW51bScsXG4gICAgJ2Zsb2F0JyxcbiAgICAnaW50JyxcbiAgICAnbG9uZycsXG4gICAgJ25pbnQnLFxuICAgICdudWludCcsXG4gICAgJ29iamVjdCcsXG4gICAgJ3NieXRlJyxcbiAgICAnc2hvcnQnLFxuICAgICdzdHJpbmcnLFxuICAgICd1bG9uZycsXG4gICAgJ3VpbnQnLFxuICAgICd1c2hvcnQnXG4gIF07XG4gIGNvbnN0IEZVTkNUSU9OX01PRElGSUVSUyA9IFtcbiAgICAncHVibGljJyxcbiAgICAncHJpdmF0ZScsXG4gICAgJ3Byb3RlY3RlZCcsXG4gICAgJ3N0YXRpYycsXG4gICAgJ2ludGVybmFsJyxcbiAgICAncHJvdGVjdGVkJyxcbiAgICAnYWJzdHJhY3QnLFxuICAgICdhc3luYycsXG4gICAgJ2V4dGVybicsXG4gICAgJ292ZXJyaWRlJyxcbiAgICAndW5zYWZlJyxcbiAgICAndmlydHVhbCcsXG4gICAgJ25ldycsXG4gICAgJ3NlYWxlZCcsXG4gICAgJ3BhcnRpYWwnXG4gIF07XG4gIGNvbnN0IExJVEVSQUxfS0VZV09SRFMgPSBbXG4gICAgJ2RlZmF1bHQnLFxuICAgICdmYWxzZScsXG4gICAgJ251bGwnLFxuICAgICd0cnVlJ1xuICBdO1xuICBjb25zdCBOT1JNQUxfS0VZV09SRFMgPSBbXG4gICAgJ2Fic3RyYWN0JyxcbiAgICAnYXMnLFxuICAgICdiYXNlJyxcbiAgICAnYnJlYWsnLFxuICAgICdjYXNlJyxcbiAgICAnY2F0Y2gnLFxuICAgICdjbGFzcycsXG4gICAgJ2NvbnN0JyxcbiAgICAnY29udGludWUnLFxuICAgICdkbycsXG4gICAgJ2Vsc2UnLFxuICAgICdldmVudCcsXG4gICAgJ2V4cGxpY2l0JyxcbiAgICAnZXh0ZXJuJyxcbiAgICAnZmluYWxseScsXG4gICAgJ2ZpeGVkJyxcbiAgICAnZm9yJyxcbiAgICAnZm9yZWFjaCcsXG4gICAgJ2dvdG8nLFxuICAgICdpZicsXG4gICAgJ2ltcGxpY2l0JyxcbiAgICAnaW4nLFxuICAgICdpbnRlcmZhY2UnLFxuICAgICdpbnRlcm5hbCcsXG4gICAgJ2lzJyxcbiAgICAnbG9jaycsXG4gICAgJ25hbWVzcGFjZScsXG4gICAgJ25ldycsXG4gICAgJ29wZXJhdG9yJyxcbiAgICAnb3V0JyxcbiAgICAnb3ZlcnJpZGUnLFxuICAgICdwYXJhbXMnLFxuICAgICdwcml2YXRlJyxcbiAgICAncHJvdGVjdGVkJyxcbiAgICAncHVibGljJyxcbiAgICAncmVhZG9ubHknLFxuICAgICdyZWNvcmQnLFxuICAgICdyZWYnLFxuICAgICdyZXR1cm4nLFxuICAgICdzY29wZWQnLFxuICAgICdzZWFsZWQnLFxuICAgICdzaXplb2YnLFxuICAgICdzdGFja2FsbG9jJyxcbiAgICAnc3RhdGljJyxcbiAgICAnc3RydWN0JyxcbiAgICAnc3dpdGNoJyxcbiAgICAndGhpcycsXG4gICAgJ3Rocm93JyxcbiAgICAndHJ5JyxcbiAgICAndHlwZW9mJyxcbiAgICAndW5jaGVja2VkJyxcbiAgICAndW5zYWZlJyxcbiAgICAndXNpbmcnLFxuICAgICd2aXJ0dWFsJyxcbiAgICAndm9pZCcsXG4gICAgJ3ZvbGF0aWxlJyxcbiAgICAnd2hpbGUnXG4gIF07XG4gIGNvbnN0IENPTlRFWFRVQUxfS0VZV09SRFMgPSBbXG4gICAgJ2FkZCcsXG4gICAgJ2FsaWFzJyxcbiAgICAnYW5kJyxcbiAgICAnYXNjZW5kaW5nJyxcbiAgICAnYXN5bmMnLFxuICAgICdhd2FpdCcsXG4gICAgJ2J5JyxcbiAgICAnZGVzY2VuZGluZycsXG4gICAgJ2VxdWFscycsXG4gICAgJ2Zyb20nLFxuICAgICdnZXQnLFxuICAgICdnbG9iYWwnLFxuICAgICdncm91cCcsXG4gICAgJ2luaXQnLFxuICAgICdpbnRvJyxcbiAgICAnam9pbicsXG4gICAgJ2xldCcsXG4gICAgJ25hbWVvZicsXG4gICAgJ25vdCcsXG4gICAgJ25vdG51bGwnLFxuICAgICdvbicsXG4gICAgJ29yJyxcbiAgICAnb3JkZXJieScsXG4gICAgJ3BhcnRpYWwnLFxuICAgICdyZW1vdmUnLFxuICAgICdzZWxlY3QnLFxuICAgICdzZXQnLFxuICAgICd1bm1hbmFnZWQnLFxuICAgICd2YWx1ZXwwJyxcbiAgICAndmFyJyxcbiAgICAnd2hlbicsXG4gICAgJ3doZXJlJyxcbiAgICAnd2l0aCcsXG4gICAgJ3lpZWxkJ1xuICBdO1xuXG4gIGNvbnN0IEtFWVdPUkRTID0ge1xuICAgIGtleXdvcmQ6IE5PUk1BTF9LRVlXT1JEUy5jb25jYXQoQ09OVEVYVFVBTF9LRVlXT1JEUyksXG4gICAgYnVpbHRfaW46IEJVSUxUX0lOX0tFWVdPUkRTLFxuICAgIGxpdGVyYWw6IExJVEVSQUxfS0VZV09SRFNcbiAgfTtcbiAgY29uc3QgVElUTEVfTU9ERSA9IGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHsgYmVnaW46ICdbYS16QS1aXShcXFxcLj9cXFxcdykqJyB9KTtcbiAgY29uc3QgTlVNQkVSUyA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7IGJlZ2luOiAnXFxcXGIoMGJbMDFcXCddKyknIH0sXG4gICAgICB7IGJlZ2luOiAnKC0/KVxcXFxiKFtcXFxcZFxcJ10rKFxcXFwuW1xcXFxkXFwnXSopP3xcXFxcLltcXFxcZFxcJ10rKSh1fFV8bHxMfHVsfFVMfGZ8RnxifEIpJyB9LFxuICAgICAgeyBiZWdpbjogJygtPykoXFxcXGIwW3hYXVthLWZBLUYwLTlcXCddK3woXFxcXGJbXFxcXGRcXCddKyhcXFxcLltcXFxcZFxcJ10qKT98XFxcXC5bXFxcXGRcXCddKykoW2VFXVstK10/W1xcXFxkXFwnXSspPyknIH1cbiAgICBdLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuICBjb25zdCBWRVJCQVRJTV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ0BcIicsXG4gICAgZW5kOiAnXCInLFxuICAgIGNvbnRhaW5zOiBbIHsgYmVnaW46ICdcIlwiJyB9IF1cbiAgfTtcbiAgY29uc3QgVkVSQkFUSU1fU1RSSU5HX05PX0xGID0gaGxqcy5pbmhlcml0KFZFUkJBVElNX1NUUklORywgeyBpbGxlZ2FsOiAvXFxuLyB9KTtcbiAgY29uc3QgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAvXFx7LyxcbiAgICBlbmQ6IC9cXH0vLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEU1xuICB9O1xuICBjb25zdCBTVUJTVF9OT19MRiA9IGhsanMuaW5oZXJpdChTVUJTVCwgeyBpbGxlZ2FsOiAvXFxuLyB9KTtcbiAgY29uc3QgSU5URVJQT0xBVEVEX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXFwkXCIvLFxuICAgIGVuZDogJ1wiJyxcbiAgICBpbGxlZ2FsOiAvXFxuLyxcbiAgICBjb250YWluczogW1xuICAgICAgeyBiZWdpbjogL1xce1xcey8gfSxcbiAgICAgIHsgYmVnaW46IC9cXH1cXH0vIH0sXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVF9OT19MRlxuICAgIF1cbiAgfTtcbiAgY29uc3QgSU5URVJQT0xBVEVEX1ZFUkJBVElNX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAvXFwkQFwiLyxcbiAgICBlbmQ6ICdcIicsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgYmVnaW46IC9cXHtcXHsvIH0sXG4gICAgICB7IGJlZ2luOiAvXFx9XFx9LyB9LFxuICAgICAgeyBiZWdpbjogJ1wiXCInIH0sXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgY29uc3QgSU5URVJQT0xBVEVEX1ZFUkJBVElNX1NUUklOR19OT19MRiA9IGhsanMuaW5oZXJpdChJTlRFUlBPTEFURURfVkVSQkFUSU1fU1RSSU5HLCB7XG4gICAgaWxsZWdhbDogL1xcbi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgYmVnaW46IC9cXHtcXHsvIH0sXG4gICAgICB7IGJlZ2luOiAvXFx9XFx9LyB9LFxuICAgICAgeyBiZWdpbjogJ1wiXCInIH0sXG4gICAgICBTVUJTVF9OT19MRlxuICAgIF1cbiAgfSk7XG4gIFNVQlNULmNvbnRhaW5zID0gW1xuICAgIElOVEVSUE9MQVRFRF9WRVJCQVRJTV9TVFJJTkcsXG4gICAgSU5URVJQT0xBVEVEX1NUUklORyxcbiAgICBWRVJCQVRJTV9TVFJJTkcsXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgTlVNQkVSUyxcbiAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gIF07XG4gIFNVQlNUX05PX0xGLmNvbnRhaW5zID0gW1xuICAgIElOVEVSUE9MQVRFRF9WRVJCQVRJTV9TVFJJTkdfTk9fTEYsXG4gICAgSU5URVJQT0xBVEVEX1NUUklORyxcbiAgICBWRVJCQVRJTV9TVFJJTkdfTk9fTEYsXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgTlVNQkVSUyxcbiAgICBobGpzLmluaGVyaXQoaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSwgeyBpbGxlZ2FsOiAvXFxuLyB9KVxuICBdO1xuICBjb25zdCBTVFJJTkcgPSB7IHZhcmlhbnRzOiBbXG4gICAgSU5URVJQT0xBVEVEX1ZFUkJBVElNX1NUUklORyxcbiAgICBJTlRFUlBPTEFURURfU1RSSU5HLFxuICAgIFZFUkJBVElNX1NUUklORyxcbiAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERVxuICBdIH07XG5cbiAgY29uc3QgR0VORVJJQ19NT0RJRklFUiA9IHtcbiAgICBiZWdpbjogXCI8XCIsXG4gICAgZW5kOiBcIj5cIixcbiAgICBjb250YWluczogW1xuICAgICAgeyBiZWdpbktleXdvcmRzOiBcImluIG91dFwiIH0sXG4gICAgICBUSVRMRV9NT0RFXG4gICAgXVxuICB9O1xuICBjb25zdCBUWVBFX0lERU5UX1JFID0gaGxqcy5JREVOVF9SRSArICcoPCcgKyBobGpzLklERU5UX1JFICsgJyhcXFxccyosXFxcXHMqJyArIGhsanMuSURFTlRfUkUgKyAnKSo+KT8oXFxcXFtcXFxcXSk/JztcbiAgY29uc3QgQVRfSURFTlRJRklFUiA9IHtcbiAgICAvLyBwcmV2ZW50cyBleHByZXNzaW9ucyBsaWtlIGBAY2xhc3NgIGZyb20gaW5jb3JyZWN0IGZsYWdnaW5nXG4gICAgLy8gYGNsYXNzYCBhcyBhIGtleXdvcmRcbiAgICBiZWdpbjogXCJAXCIgKyBobGpzLklERU5UX1JFLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0MjJyxcbiAgICBhbGlhc2VzOiBbXG4gICAgICAnY3MnLFxuICAgICAgJ2MjJ1xuICAgIF0sXG4gICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgIGlsbGVnYWw6IC86Oi8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQ09NTUVOVChcbiAgICAgICAgJy8vLycsXG4gICAgICAgICckJyxcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2RvY3RhZycsXG4gICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYmVnaW46ICcvLy8nLFxuICAgICAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB7IGJlZ2luOiAnPCEtLXwtLT4nIH0sXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgYmVnaW46ICc8Lz8nLFxuICAgICAgICAgICAgICAgICAgZW5kOiAnPidcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICAgICksXG4gICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICAgICAgYmVnaW46ICcjJyxcbiAgICAgICAgZW5kOiAnJCcsXG4gICAgICAgIGtleXdvcmRzOiB7IGtleXdvcmQ6ICdpZiBlbHNlIGVsaWYgZW5kaWYgZGVmaW5lIHVuZGVmIHdhcm5pbmcgZXJyb3IgbGluZSByZWdpb24gZW5kcmVnaW9uIHByYWdtYSBjaGVja3N1bScgfVxuICAgICAgfSxcbiAgICAgIFNUUklORyxcbiAgICAgIE5VTUJFUlMsXG4gICAgICB7XG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdjbGFzcyBpbnRlcmZhY2UnLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGVuZDogL1t7Oz1dLyxcbiAgICAgICAgaWxsZWdhbDogL1teXFxzOixdLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7IGJlZ2luS2V5d29yZHM6IFwid2hlcmUgY2xhc3NcIiB9LFxuICAgICAgICAgIFRJVExFX01PREUsXG4gICAgICAgICAgR0VORVJJQ19NT0RJRklFUixcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbktleXdvcmRzOiAnbmFtZXNwYWNlJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBlbmQ6IC9bezs9XS8sXG4gICAgICAgIGlsbGVnYWw6IC9bXlxcczpdLyxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBUSVRMRV9NT0RFLFxuICAgICAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERSxcbiAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luS2V5d29yZHM6ICdyZWNvcmQnLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGVuZDogL1t7Oz1dLyxcbiAgICAgICAgaWxsZWdhbDogL1teXFxzOl0vLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFRJVExFX01PREUsXG4gICAgICAgICAgR0VORVJJQ19NT0RJRklFUixcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyBbQXR0cmlidXRlcyhcIlwiKV1cbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAnXlxcXFxzKlxcXFxbKD89W1xcXFx3XSknLFxuICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgIGVuZDogJ1xcXFxdJyxcbiAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgICAgICAgICAgYmVnaW46IC9cIi8sXG4gICAgICAgICAgICBlbmQ6IC9cIi9cbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIEV4cHJlc3Npb24ga2V5d29yZHMgcHJldmVudCAna2V5d29yZCBOYW1lKC4uLiknIGZyb20gYmVpbmdcbiAgICAgICAgLy8gcmVjb2duaXplZCBhcyBhIGZ1bmN0aW9uIGRlZmluaXRpb25cbiAgICAgICAgYmVnaW5LZXl3b3JkczogJ25ldyByZXR1cm4gdGhyb3cgYXdhaXQgZWxzZScsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICBiZWdpbjogJygnICsgVFlQRV9JREVOVF9SRSArICdcXFxccyspKycgKyBobGpzLklERU5UX1JFICsgJ1xcXFxzKig8W149XSs+XFxcXHMqKT9cXFxcKCcsXG4gICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICBlbmQ6IC9cXHMqW3s7PV0vLFxuICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICBrZXl3b3JkczogS0VZV09SRFMsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgLy8gcHJldmVudHMgdGhlc2UgZnJvbSBiZWluZyBoaWdobGlnaHRlZCBgdGl0bGVgXG4gICAgICAgICAge1xuICAgICAgICAgICAgYmVnaW5LZXl3b3JkczogRlVOQ1RJT05fTU9ESUZJRVJTLmpvaW4oXCIgXCIpLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogaGxqcy5JREVOVF9SRSArICdcXFxccyooPFtePV0rPlxcXFxzKik/XFxcXCgnLFxuICAgICAgICAgICAgcmV0dXJuQmVnaW46IHRydWUsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICBobGpzLlRJVExFX01PREUsXG4gICAgICAgICAgICAgIEdFTkVSSUNfTU9ESUZJRVJcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgbWF0Y2g6IC9cXChcXCkvIH0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAncGFyYW1zJyxcbiAgICAgICAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgU1RSSU5HLFxuICAgICAgICAgICAgICBOVU1CRVJTLFxuICAgICAgICAgICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFXG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBobGpzLkNfTElORV9DT01NRU5UX01PREUsXG4gICAgICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERVxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAgQVRfSURFTlRJRklFUlxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3NoYXJwIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJjc2hhcnAiLCJobGpzIiwiQlVJTFRfSU5fS0VZV09SRFMiLCJGVU5DVElPTl9NT0RJRklFUlMiLCJMSVRFUkFMX0tFWVdPUkRTIiwiTk9STUFMX0tFWVdPUkRTIiwiQ09OVEVYVFVBTF9LRVlXT1JEUyIsIktFWVdPUkRTIiwia2V5d29yZCIsImNvbmNhdCIsImJ1aWx0X2luIiwibGl0ZXJhbCIsIlRJVExFX01PREUiLCJpbmhlcml0IiwiYmVnaW4iLCJOVU1CRVJTIiwiY2xhc3NOYW1lIiwidmFyaWFudHMiLCJyZWxldmFuY2UiLCJWRVJCQVRJTV9TVFJJTkciLCJlbmQiLCJjb250YWlucyIsIlZFUkJBVElNX1NUUklOR19OT19MRiIsImlsbGVnYWwiLCJTVUJTVCIsImtleXdvcmRzIiwiU1VCU1RfTk9fTEYiLCJJTlRFUlBPTEFURURfU1RSSU5HIiwiQkFDS1NMQVNIX0VTQ0FQRSIsIklOVEVSUE9MQVRFRF9WRVJCQVRJTV9TVFJJTkciLCJJTlRFUlBPTEFURURfVkVSQkFUSU1fU1RSSU5HX05PX0xGIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiQ19CTE9DS19DT01NRU5UX01PREUiLCJTVFJJTkciLCJHRU5FUklDX01PRElGSUVSIiwiYmVnaW5LZXl3b3JkcyIsIlRZUEVfSURFTlRfUkUiLCJJREVOVF9SRSIsIkFUX0lERU5USUZJRVIiLCJuYW1lIiwiYWxpYXNlcyIsIkNPTU1FTlQiLCJyZXR1cm5CZWdpbiIsIkNfTElORV9DT01NRU5UX01PREUiLCJleGNsdWRlQmVnaW4iLCJleGNsdWRlRW5kIiwiam9pbiIsIm1hdGNoIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/csharp.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/css.js":
/*!*******************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/css.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ css)\n/* harmony export */ });\nconst MODES = (hljs)=>{\n    return {\n        IMPORTANT: {\n            scope: \"meta\",\n            begin: \"!important\"\n        },\n        BLOCK_COMMENT: hljs.C_BLOCK_COMMENT_MODE,\n        HEXCOLOR: {\n            scope: \"number\",\n            begin: /#(([0-9a-fA-F]{3,4})|(([0-9a-fA-F]{2}){3,4}))\\b/\n        },\n        FUNCTION_DISPATCH: {\n            className: \"built_in\",\n            begin: /[\\w-]+(?=\\()/\n        },\n        ATTRIBUTE_SELECTOR_MODE: {\n            scope: \"selector-attr\",\n            begin: /\\[/,\n            end: /\\]/,\n            illegal: \"$\",\n            contains: [\n                hljs.APOS_STRING_MODE,\n                hljs.QUOTE_STRING_MODE\n            ]\n        },\n        CSS_NUMBER_MODE: {\n            scope: \"number\",\n            begin: hljs.NUMBER_RE + \"(\" + \"%|em|ex|ch|rem\" + \"|vw|vh|vmin|vmax\" + \"|cm|mm|in|pt|pc|px\" + \"|deg|grad|rad|turn\" + \"|s|ms\" + \"|Hz|kHz\" + \"|dpi|dpcm|dppx\" + \")?\",\n            relevance: 0\n        },\n        CSS_VARIABLE: {\n            className: \"attr\",\n            begin: /--[A-Za-z_][A-Za-z0-9_-]*/\n        }\n    };\n};\nconst TAGS = [\n    \"a\",\n    \"abbr\",\n    \"address\",\n    \"article\",\n    \"aside\",\n    \"audio\",\n    \"b\",\n    \"blockquote\",\n    \"body\",\n    \"button\",\n    \"canvas\",\n    \"caption\",\n    \"cite\",\n    \"code\",\n    \"dd\",\n    \"del\",\n    \"details\",\n    \"dfn\",\n    \"div\",\n    \"dl\",\n    \"dt\",\n    \"em\",\n    \"fieldset\",\n    \"figcaption\",\n    \"figure\",\n    \"footer\",\n    \"form\",\n    \"h1\",\n    \"h2\",\n    \"h3\",\n    \"h4\",\n    \"h5\",\n    \"h6\",\n    \"header\",\n    \"hgroup\",\n    \"html\",\n    \"i\",\n    \"iframe\",\n    \"img\",\n    \"input\",\n    \"ins\",\n    \"kbd\",\n    \"label\",\n    \"legend\",\n    \"li\",\n    \"main\",\n    \"mark\",\n    \"menu\",\n    \"nav\",\n    \"object\",\n    \"ol\",\n    \"p\",\n    \"q\",\n    \"quote\",\n    \"samp\",\n    \"section\",\n    \"span\",\n    \"strong\",\n    \"summary\",\n    \"sup\",\n    \"table\",\n    \"tbody\",\n    \"td\",\n    \"textarea\",\n    \"tfoot\",\n    \"th\",\n    \"thead\",\n    \"time\",\n    \"tr\",\n    \"ul\",\n    \"var\",\n    \"video\"\n];\nconst MEDIA_FEATURES = [\n    \"any-hover\",\n    \"any-pointer\",\n    \"aspect-ratio\",\n    \"color\",\n    \"color-gamut\",\n    \"color-index\",\n    \"device-aspect-ratio\",\n    \"device-height\",\n    \"device-width\",\n    \"display-mode\",\n    \"forced-colors\",\n    \"grid\",\n    \"height\",\n    \"hover\",\n    \"inverted-colors\",\n    \"monochrome\",\n    \"orientation\",\n    \"overflow-block\",\n    \"overflow-inline\",\n    \"pointer\",\n    \"prefers-color-scheme\",\n    \"prefers-contrast\",\n    \"prefers-reduced-motion\",\n    \"prefers-reduced-transparency\",\n    \"resolution\",\n    \"scan\",\n    \"scripting\",\n    \"update\",\n    \"width\",\n    // TODO: find a better solution?\n    \"min-width\",\n    \"max-width\",\n    \"min-height\",\n    \"max-height\"\n];\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-classes\nconst PSEUDO_CLASSES = [\n    \"active\",\n    \"any-link\",\n    \"blank\",\n    \"checked\",\n    \"current\",\n    \"default\",\n    \"defined\",\n    \"dir\",\n    \"disabled\",\n    \"drop\",\n    \"empty\",\n    \"enabled\",\n    \"first\",\n    \"first-child\",\n    \"first-of-type\",\n    \"fullscreen\",\n    \"future\",\n    \"focus\",\n    \"focus-visible\",\n    \"focus-within\",\n    \"has\",\n    \"host\",\n    \"host-context\",\n    \"hover\",\n    \"indeterminate\",\n    \"in-range\",\n    \"invalid\",\n    \"is\",\n    \"lang\",\n    \"last-child\",\n    \"last-of-type\",\n    \"left\",\n    \"link\",\n    \"local-link\",\n    \"not\",\n    \"nth-child\",\n    \"nth-col\",\n    \"nth-last-child\",\n    \"nth-last-col\",\n    \"nth-last-of-type\",\n    \"nth-of-type\",\n    \"only-child\",\n    \"only-of-type\",\n    \"optional\",\n    \"out-of-range\",\n    \"past\",\n    \"placeholder-shown\",\n    \"read-only\",\n    \"read-write\",\n    \"required\",\n    \"right\",\n    \"root\",\n    \"scope\",\n    \"target\",\n    \"target-within\",\n    \"user-invalid\",\n    \"valid\",\n    \"visited\",\n    \"where\" // where()\n];\n// https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\nconst PSEUDO_ELEMENTS = [\n    \"after\",\n    \"backdrop\",\n    \"before\",\n    \"cue\",\n    \"cue-region\",\n    \"first-letter\",\n    \"first-line\",\n    \"grammar-error\",\n    \"marker\",\n    \"part\",\n    \"placeholder\",\n    \"selection\",\n    \"slotted\",\n    \"spelling-error\"\n];\nconst ATTRIBUTES = [\n    \"align-content\",\n    \"align-items\",\n    \"align-self\",\n    \"all\",\n    \"animation\",\n    \"animation-delay\",\n    \"animation-direction\",\n    \"animation-duration\",\n    \"animation-fill-mode\",\n    \"animation-iteration-count\",\n    \"animation-name\",\n    \"animation-play-state\",\n    \"animation-timing-function\",\n    \"backface-visibility\",\n    \"background\",\n    \"background-attachment\",\n    \"background-blend-mode\",\n    \"background-clip\",\n    \"background-color\",\n    \"background-image\",\n    \"background-origin\",\n    \"background-position\",\n    \"background-repeat\",\n    \"background-size\",\n    \"block-size\",\n    \"border\",\n    \"border-block\",\n    \"border-block-color\",\n    \"border-block-end\",\n    \"border-block-end-color\",\n    \"border-block-end-style\",\n    \"border-block-end-width\",\n    \"border-block-start\",\n    \"border-block-start-color\",\n    \"border-block-start-style\",\n    \"border-block-start-width\",\n    \"border-block-style\",\n    \"border-block-width\",\n    \"border-bottom\",\n    \"border-bottom-color\",\n    \"border-bottom-left-radius\",\n    \"border-bottom-right-radius\",\n    \"border-bottom-style\",\n    \"border-bottom-width\",\n    \"border-collapse\",\n    \"border-color\",\n    \"border-image\",\n    \"border-image-outset\",\n    \"border-image-repeat\",\n    \"border-image-slice\",\n    \"border-image-source\",\n    \"border-image-width\",\n    \"border-inline\",\n    \"border-inline-color\",\n    \"border-inline-end\",\n    \"border-inline-end-color\",\n    \"border-inline-end-style\",\n    \"border-inline-end-width\",\n    \"border-inline-start\",\n    \"border-inline-start-color\",\n    \"border-inline-start-style\",\n    \"border-inline-start-width\",\n    \"border-inline-style\",\n    \"border-inline-width\",\n    \"border-left\",\n    \"border-left-color\",\n    \"border-left-style\",\n    \"border-left-width\",\n    \"border-radius\",\n    \"border-right\",\n    \"border-right-color\",\n    \"border-right-style\",\n    \"border-right-width\",\n    \"border-spacing\",\n    \"border-style\",\n    \"border-top\",\n    \"border-top-color\",\n    \"border-top-left-radius\",\n    \"border-top-right-radius\",\n    \"border-top-style\",\n    \"border-top-width\",\n    \"border-width\",\n    \"bottom\",\n    \"box-decoration-break\",\n    \"box-shadow\",\n    \"box-sizing\",\n    \"break-after\",\n    \"break-before\",\n    \"break-inside\",\n    \"caption-side\",\n    \"caret-color\",\n    \"clear\",\n    \"clip\",\n    \"clip-path\",\n    \"clip-rule\",\n    \"color\",\n    \"column-count\",\n    \"column-fill\",\n    \"column-gap\",\n    \"column-rule\",\n    \"column-rule-color\",\n    \"column-rule-style\",\n    \"column-rule-width\",\n    \"column-span\",\n    \"column-width\",\n    \"columns\",\n    \"contain\",\n    \"content\",\n    \"content-visibility\",\n    \"counter-increment\",\n    \"counter-reset\",\n    \"cue\",\n    \"cue-after\",\n    \"cue-before\",\n    \"cursor\",\n    \"direction\",\n    \"display\",\n    \"empty-cells\",\n    \"filter\",\n    \"flex\",\n    \"flex-basis\",\n    \"flex-direction\",\n    \"flex-flow\",\n    \"flex-grow\",\n    \"flex-shrink\",\n    \"flex-wrap\",\n    \"float\",\n    \"flow\",\n    \"font\",\n    \"font-display\",\n    \"font-family\",\n    \"font-feature-settings\",\n    \"font-kerning\",\n    \"font-language-override\",\n    \"font-size\",\n    \"font-size-adjust\",\n    \"font-smoothing\",\n    \"font-stretch\",\n    \"font-style\",\n    \"font-synthesis\",\n    \"font-variant\",\n    \"font-variant-caps\",\n    \"font-variant-east-asian\",\n    \"font-variant-ligatures\",\n    \"font-variant-numeric\",\n    \"font-variant-position\",\n    \"font-variation-settings\",\n    \"font-weight\",\n    \"gap\",\n    \"glyph-orientation-vertical\",\n    \"grid\",\n    \"grid-area\",\n    \"grid-auto-columns\",\n    \"grid-auto-flow\",\n    \"grid-auto-rows\",\n    \"grid-column\",\n    \"grid-column-end\",\n    \"grid-column-start\",\n    \"grid-gap\",\n    \"grid-row\",\n    \"grid-row-end\",\n    \"grid-row-start\",\n    \"grid-template\",\n    \"grid-template-areas\",\n    \"grid-template-columns\",\n    \"grid-template-rows\",\n    \"hanging-punctuation\",\n    \"height\",\n    \"hyphens\",\n    \"icon\",\n    \"image-orientation\",\n    \"image-rendering\",\n    \"image-resolution\",\n    \"ime-mode\",\n    \"inline-size\",\n    \"isolation\",\n    \"justify-content\",\n    \"left\",\n    \"letter-spacing\",\n    \"line-break\",\n    \"line-height\",\n    \"list-style\",\n    \"list-style-image\",\n    \"list-style-position\",\n    \"list-style-type\",\n    \"margin\",\n    \"margin-block\",\n    \"margin-block-end\",\n    \"margin-block-start\",\n    \"margin-bottom\",\n    \"margin-inline\",\n    \"margin-inline-end\",\n    \"margin-inline-start\",\n    \"margin-left\",\n    \"margin-right\",\n    \"margin-top\",\n    \"marks\",\n    \"mask\",\n    \"mask-border\",\n    \"mask-border-mode\",\n    \"mask-border-outset\",\n    \"mask-border-repeat\",\n    \"mask-border-slice\",\n    \"mask-border-source\",\n    \"mask-border-width\",\n    \"mask-clip\",\n    \"mask-composite\",\n    \"mask-image\",\n    \"mask-mode\",\n    \"mask-origin\",\n    \"mask-position\",\n    \"mask-repeat\",\n    \"mask-size\",\n    \"mask-type\",\n    \"max-block-size\",\n    \"max-height\",\n    \"max-inline-size\",\n    \"max-width\",\n    \"min-block-size\",\n    \"min-height\",\n    \"min-inline-size\",\n    \"min-width\",\n    \"mix-blend-mode\",\n    \"nav-down\",\n    \"nav-index\",\n    \"nav-left\",\n    \"nav-right\",\n    \"nav-up\",\n    \"none\",\n    \"normal\",\n    \"object-fit\",\n    \"object-position\",\n    \"opacity\",\n    \"order\",\n    \"orphans\",\n    \"outline\",\n    \"outline-color\",\n    \"outline-offset\",\n    \"outline-style\",\n    \"outline-width\",\n    \"overflow\",\n    \"overflow-wrap\",\n    \"overflow-x\",\n    \"overflow-y\",\n    \"padding\",\n    \"padding-block\",\n    \"padding-block-end\",\n    \"padding-block-start\",\n    \"padding-bottom\",\n    \"padding-inline\",\n    \"padding-inline-end\",\n    \"padding-inline-start\",\n    \"padding-left\",\n    \"padding-right\",\n    \"padding-top\",\n    \"page-break-after\",\n    \"page-break-before\",\n    \"page-break-inside\",\n    \"pause\",\n    \"pause-after\",\n    \"pause-before\",\n    \"perspective\",\n    \"perspective-origin\",\n    \"pointer-events\",\n    \"position\",\n    \"quotes\",\n    \"resize\",\n    \"rest\",\n    \"rest-after\",\n    \"rest-before\",\n    \"right\",\n    \"row-gap\",\n    \"scroll-margin\",\n    \"scroll-margin-block\",\n    \"scroll-margin-block-end\",\n    \"scroll-margin-block-start\",\n    \"scroll-margin-bottom\",\n    \"scroll-margin-inline\",\n    \"scroll-margin-inline-end\",\n    \"scroll-margin-inline-start\",\n    \"scroll-margin-left\",\n    \"scroll-margin-right\",\n    \"scroll-margin-top\",\n    \"scroll-padding\",\n    \"scroll-padding-block\",\n    \"scroll-padding-block-end\",\n    \"scroll-padding-block-start\",\n    \"scroll-padding-bottom\",\n    \"scroll-padding-inline\",\n    \"scroll-padding-inline-end\",\n    \"scroll-padding-inline-start\",\n    \"scroll-padding-left\",\n    \"scroll-padding-right\",\n    \"scroll-padding-top\",\n    \"scroll-snap-align\",\n    \"scroll-snap-stop\",\n    \"scroll-snap-type\",\n    \"scrollbar-color\",\n    \"scrollbar-gutter\",\n    \"scrollbar-width\",\n    \"shape-image-threshold\",\n    \"shape-margin\",\n    \"shape-outside\",\n    \"speak\",\n    \"speak-as\",\n    \"src\",\n    \"tab-size\",\n    \"table-layout\",\n    \"text-align\",\n    \"text-align-all\",\n    \"text-align-last\",\n    \"text-combine-upright\",\n    \"text-decoration\",\n    \"text-decoration-color\",\n    \"text-decoration-line\",\n    \"text-decoration-style\",\n    \"text-emphasis\",\n    \"text-emphasis-color\",\n    \"text-emphasis-position\",\n    \"text-emphasis-style\",\n    \"text-indent\",\n    \"text-justify\",\n    \"text-orientation\",\n    \"text-overflow\",\n    \"text-rendering\",\n    \"text-shadow\",\n    \"text-transform\",\n    \"text-underline-position\",\n    \"top\",\n    \"transform\",\n    \"transform-box\",\n    \"transform-origin\",\n    \"transform-style\",\n    \"transition\",\n    \"transition-delay\",\n    \"transition-duration\",\n    \"transition-property\",\n    \"transition-timing-function\",\n    \"unicode-bidi\",\n    \"vertical-align\",\n    \"visibility\",\n    \"voice-balance\",\n    \"voice-duration\",\n    \"voice-family\",\n    \"voice-pitch\",\n    \"voice-range\",\n    \"voice-rate\",\n    \"voice-stress\",\n    \"voice-volume\",\n    \"white-space\",\n    \"widows\",\n    \"width\",\n    \"will-change\",\n    \"word-break\",\n    \"word-spacing\",\n    \"word-wrap\",\n    \"writing-mode\",\n    \"z-index\"\n].reverse();\n/*\nLanguage: CSS\nCategory: common, css, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/CSS\n*/ /** @type LanguageFn */ function css(hljs) {\n    const regex = hljs.regex;\n    const modes = MODES(hljs);\n    const VENDOR_PREFIX = {\n        begin: /-(webkit|moz|ms|o)-(?=[a-z])/\n    };\n    const AT_MODIFIERS = \"and or not only\";\n    const AT_PROPERTY_RE = /@-?\\w[\\w]*(-\\w+)*/; // @-webkit-keyframes\n    const IDENT_RE = \"[a-zA-Z-][a-zA-Z0-9_-]*\";\n    const STRINGS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE\n    ];\n    return {\n        name: \"CSS\",\n        case_insensitive: true,\n        illegal: /[=|'\\$]/,\n        keywords: {\n            keyframePosition: \"from to\"\n        },\n        classNameAliases: {\n            // for visual continuity with `tag {}` and because we\n            // don't have a great class for this?\n            keyframePosition: \"selector-tag\"\n        },\n        contains: [\n            modes.BLOCK_COMMENT,\n            VENDOR_PREFIX,\n            // to recognize keyframe 40% etc which are outside the scope of our\n            // attribute value mode\n            modes.CSS_NUMBER_MODE,\n            {\n                className: \"selector-id\",\n                begin: /#[A-Za-z0-9_-]+/,\n                relevance: 0\n            },\n            {\n                className: \"selector-class\",\n                begin: \"\\\\.\" + IDENT_RE,\n                relevance: 0\n            },\n            modes.ATTRIBUTE_SELECTOR_MODE,\n            {\n                className: \"selector-pseudo\",\n                variants: [\n                    {\n                        begin: \":(\" + PSEUDO_CLASSES.join(\"|\") + \")\"\n                    },\n                    {\n                        begin: \":(:)?(\" + PSEUDO_ELEMENTS.join(\"|\") + \")\"\n                    }\n                ]\n            },\n            // we may actually need this (12/2020)\n            // { // pseudo-selector params\n            //   begin: /\\(/,\n            //   end: /\\)/,\n            //   contains: [ hljs.CSS_NUMBER_MODE ]\n            // },\n            modes.CSS_VARIABLE,\n            {\n                className: \"attribute\",\n                begin: \"\\\\b(\" + ATTRIBUTES.join(\"|\") + \")\\\\b\"\n            },\n            // attribute values\n            {\n                begin: /:/,\n                end: /[;}{]/,\n                contains: [\n                    modes.BLOCK_COMMENT,\n                    modes.HEXCOLOR,\n                    modes.IMPORTANT,\n                    modes.CSS_NUMBER_MODE,\n                    ...STRINGS,\n                    // needed to highlight these as strings and to avoid issues with\n                    // illegal characters that might be inside urls that would tigger the\n                    // languages illegal stack\n                    {\n                        begin: /(url|data-uri)\\(/,\n                        end: /\\)/,\n                        relevance: 0,\n                        keywords: {\n                            built_in: \"url data-uri\"\n                        },\n                        contains: [\n                            ...STRINGS,\n                            {\n                                className: \"string\",\n                                // any character other than `)` as in `url()` will be the start\n                                // of a string, which ends with `)` (from the parent mode)\n                                begin: /[^)]/,\n                                endsWithParent: true,\n                                excludeEnd: true\n                            }\n                        ]\n                    },\n                    modes.FUNCTION_DISPATCH\n                ]\n            },\n            {\n                begin: regex.lookahead(/@/),\n                end: \"[{;]\",\n                relevance: 0,\n                illegal: /:/,\n                contains: [\n                    {\n                        className: \"keyword\",\n                        begin: AT_PROPERTY_RE\n                    },\n                    {\n                        begin: /\\s/,\n                        endsWithParent: true,\n                        excludeEnd: true,\n                        relevance: 0,\n                        keywords: {\n                            $pattern: /[a-z-]+/,\n                            keyword: AT_MODIFIERS,\n                            attribute: MEDIA_FEATURES.join(\" \")\n                        },\n                        contains: [\n                            {\n                                begin: /[a-z-]+(?=:)/,\n                                className: \"attribute\"\n                            },\n                            ...STRINGS,\n                            modes.CSS_NUMBER_MODE\n                        ]\n                    }\n                ]\n            },\n            {\n                className: \"selector-tag\",\n                begin: \"\\\\b(\" + TAGS.join(\"|\") + \")\\\\b\"\n            }\n        ]\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9jc3MuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE1BQU1BLFFBQVEsQ0FBQ0M7SUFDYixPQUFPO1FBQ0xDLFdBQVc7WUFDVEMsT0FBTztZQUNQQyxPQUFPO1FBQ1Q7UUFDQUMsZUFBZUosS0FBS0ssb0JBQW9CO1FBQ3hDQyxVQUFVO1lBQ1JKLE9BQU87WUFDUEMsT0FBTztRQUNUO1FBQ0FJLG1CQUFtQjtZQUNqQkMsV0FBVztZQUNYTCxPQUFPO1FBQ1Q7UUFDQU0seUJBQXlCO1lBQ3ZCUCxPQUFPO1lBQ1BDLE9BQU87WUFDUE8sS0FBSztZQUNMQyxTQUFTO1lBQ1RDLFVBQVU7Z0JBQ1JaLEtBQUthLGdCQUFnQjtnQkFDckJiLEtBQUtjLGlCQUFpQjthQUN2QjtRQUNIO1FBQ0FDLGlCQUFpQjtZQUNmYixPQUFPO1lBQ1BDLE9BQU9ILEtBQUtnQixTQUFTLEdBQUcsTUFDdEIsbUJBQ0EscUJBQ0EsdUJBQ0EsdUJBQ0EsVUFDQSxZQUNBLG1CQUNBO1lBQ0ZDLFdBQVc7UUFDYjtRQUNBQyxjQUFjO1lBQ1pWLFdBQVc7WUFDWEwsT0FBTztRQUNUO0lBQ0Y7QUFDRjtBQUVBLE1BQU1nQixPQUFPO0lBQ1g7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxNQUFNQyxpQkFBaUI7SUFDckI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLGdDQUFnQztJQUNoQztJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsa0VBQWtFO0FBQ2xFLE1BQU1DLGlCQUFpQjtJQUNyQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLFFBQVEsVUFBVTtDQUNuQjtBQUVELG1FQUFtRTtBQUNuRSxNQUFNQyxrQkFBa0I7SUFDdEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsYUFBYTtJQUNqQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFD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QkFDckUsMEJBQTBCO29CQUMxQjt3QkFDRTdCLE9BQU87d0JBQ1BPLEtBQUs7d0JBQ0xPLFdBQVc7d0JBQ1hrQixVQUFVOzRCQUFFSyxVQUFVO3dCQUFlO3dCQUNyQzVCLFVBQVU7K0JBQ0xvQjs0QkFDSDtnQ0FDRXhCLFdBQVc7Z0NBQ1gsK0RBQStEO2dDQUMvRCwwREFBMEQ7Z0NBQzFETCxPQUFPO2dDQUNQc0MsZ0JBQWdCO2dDQUNoQkMsWUFBWTs0QkFDZDt5QkFDRDtvQkFDSDtvQkFDQWYsTUFBTXBCLGlCQUFpQjtpQkFDeEI7WUFDSDtZQUNBO2dCQUNFSixPQUFPdUIsTUFBTWlCLFNBQVMsQ0FBQztnQkFDdkJqQyxLQUFLO2dCQUNMTyxXQUFXO2dCQUNYTixTQUFTO2dCQUNUQyxVQUFVO29CQUNSO3dCQUNFSixXQUFXO3dCQUNYTCxPQUFPMkI7b0JBQ1Q7b0JBQ0E7d0JBQ0UzQixPQUFPO3dCQUNQc0MsZ0JBQWdCO3dCQUNoQkMsWUFBWTt3QkFDWnpCLFdBQVc7d0JBQ1hrQixVQUFVOzRCQUNSUyxVQUFVOzRCQUNWQyxTQUFTaEI7NEJBQ1RpQixXQUFXMUIsZUFBZW1CLElBQUksQ0FBQzt3QkFDakM7d0JBQ0EzQixVQUFVOzRCQUNSO2dDQUNFVCxPQUFPO2dDQUNQSyxXQUFXOzRCQUNiOytCQUNHd0I7NEJBQ0hMLE1BQU1aLGVBQWU7eUJBQ3RCO29CQUNIO2lCQUNEO1lBQ0g7WUFDQTtnQkFDRVAsV0FBVztnQkFDWEwsT0FBTyxTQUFTZ0IsS0FBS29CLElBQUksQ0FBQyxPQUFPO1lBQ25DO1NBQ0Q7SUFDSDtBQUNGO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVmcmFnbWVudGluZy1pZGVhcy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2Nzcy5qcz8wNWVmIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1PREVTID0gKGhsanMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICBJTVBPUlRBTlQ6IHtcbiAgICAgIHNjb3BlOiAnbWV0YScsXG4gICAgICBiZWdpbjogJyFpbXBvcnRhbnQnXG4gICAgfSxcbiAgICBCTE9DS19DT01NRU5UOiBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgIEhFWENPTE9SOiB7XG4gICAgICBzY29wZTogJ251bWJlcicsXG4gICAgICBiZWdpbjogLyMoKFswLTlhLWZBLUZdezMsNH0pfCgoWzAtOWEtZkEtRl17Mn0pezMsNH0pKVxcYi9cbiAgICB9LFxuICAgIEZVTkNUSU9OX0RJU1BBVENIOiB7XG4gICAgICBjbGFzc05hbWU6IFwiYnVpbHRfaW5cIixcbiAgICAgIGJlZ2luOiAvW1xcdy1dKyg/PVxcKCkvXG4gICAgfSxcbiAgICBBVFRSSUJVVEVfU0VMRUNUT1JfTU9ERToge1xuICAgICAgc2NvcGU6ICdzZWxlY3Rvci1hdHRyJyxcbiAgICAgIGJlZ2luOiAvXFxbLyxcbiAgICAgIGVuZDogL1xcXS8sXG4gICAgICBpbGxlZ2FsOiAnJCcsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkFQT1NfU1RSSU5HX01PREUsXG4gICAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREVcbiAgICAgIF1cbiAgICB9LFxuICAgIENTU19OVU1CRVJfTU9ERToge1xuICAgICAgc2NvcGU6ICdudW1iZXInLFxuICAgICAgYmVnaW46IGhsanMuTlVNQkVSX1JFICsgJygnICtcbiAgICAgICAgJyV8ZW18ZXh8Y2h8cmVtJyArXG4gICAgICAgICd8dnd8dmh8dm1pbnx2bWF4JyArXG4gICAgICAgICd8Y218bW18aW58cHR8cGN8cHgnICtcbiAgICAgICAgJ3xkZWd8Z3JhZHxyYWR8dHVybicgK1xuICAgICAgICAnfHN8bXMnICtcbiAgICAgICAgJ3xIenxrSHonICtcbiAgICAgICAgJ3xkcGl8ZHBjbXxkcHB4JyArXG4gICAgICAgICcpPycsXG4gICAgICByZWxldmFuY2U6IDBcbiAgICB9LFxuICAgIENTU19WQVJJQUJMRToge1xuICAgICAgY2xhc3NOYW1lOiBcImF0dHJcIixcbiAgICAgIGJlZ2luOiAvLS1bQS1aYS16X11bQS1aYS16MC05Xy1dKi9cbiAgICB9XG4gIH07XG59O1xuXG5jb25zdCBUQUdTID0gW1xuICAnYScsXG4gICdhYmJyJyxcbiAgJ2FkZHJlc3MnLFxuICAnYXJ0aWNsZScsXG4gICdhc2lkZScsXG4gICdhdWRpbycsXG4gICdiJyxcbiAgJ2Jsb2NrcXVvdGUnLFxuICAnYm9keScsXG4gICdidXR0b24nLFxuICAnY2FudmFzJyxcbiAgJ2NhcHRpb24nLFxuICAnY2l0ZScsXG4gICdjb2RlJyxcbiAgJ2RkJyxcbiAgJ2RlbCcsXG4gICdkZXRhaWxzJyxcbiAgJ2RmbicsXG4gICdkaXYnLFxuICAnZGwnLFxuICAnZHQnLFxuICAnZW0nLFxuICAnZmllbGRzZXQnLFxuICAnZmlnY2FwdGlvbicsXG4gICdmaWd1cmUnLFxuICAnZm9vdGVyJyxcbiAgJ2Zvcm0nLFxuICAnaDEnLFxuICAnaDInLFxuICAnaDMnLFxuICAnaDQnLFxuICAnaDUnLFxuICAnaDYnLFxuICAnaGVhZGVyJyxcbiAgJ2hncm91cCcsXG4gICdodG1sJyxcbiAgJ2knLFxuICAnaWZyYW1lJyxcbiAgJ2ltZycsXG4gICdpbnB1dCcsXG4gICdpbnMnLFxuICAna2JkJyxcbiAgJ2xhYmVsJyxcbiAgJ2xlZ2VuZCcsXG4gICdsaScsXG4gICdtYWluJyxcbiAgJ21hcmsnLFxuICAnbWVudScsXG4gICduYXYnLFxuICAnb2JqZWN0JyxcbiAgJ29sJyxcbiAgJ3AnLFxuICAncScsXG4gICdxdW90ZScsXG4gICdzYW1wJyxcbiAgJ3NlY3Rpb24nLFxuICAnc3BhbicsXG4gICdzdHJvbmcnLFxuICAnc3VtbWFyeScsXG4gICdzdXAnLFxuICAndGFibGUnLFxuICAndGJvZHknLFxuICAndGQnLFxuICAndGV4dGFyZWEnLFxuICAndGZvb3QnLFxuICAndGgnLFxuICAndGhlYWQnLFxuICAndGltZScsXG4gICd0cicsXG4gICd1bCcsXG4gICd2YXInLFxuICAndmlkZW8nXG5dO1xuXG5jb25zdCBNRURJQV9GRUFUVVJFUyA9IFtcbiAgJ2FueS1ob3ZlcicsXG4gICdhbnktcG9pbnRlcicsXG4gICdhc3BlY3QtcmF0aW8nLFxuICAnY29sb3InLFxuICAnY29sb3ItZ2FtdXQnLFxuICAnY29sb3ItaW5kZXgnLFxuICAnZGV2aWNlLWFzcGVjdC1yYXRpbycsXG4gICdkZXZpY2UtaGVpZ2h0JyxcbiAgJ2RldmljZS13aWR0aCcsXG4gICdkaXNwbGF5LW1vZGUnLFxuICAnZm9yY2VkLWNvbG9ycycsXG4gICdncmlkJyxcbiAgJ2hlaWdodCcsXG4gICdob3ZlcicsXG4gICdpbnZlcnRlZC1jb2xvcnMnLFxuICAnbW9ub2Nocm9tZScsXG4gICdvcmllbnRhdGlvbicsXG4gICdvdmVyZmxvdy1ibG9jaycsXG4gICdvdmVyZmxvdy1pbmxpbmUnLFxuICAncG9pbnRlcicsXG4gICdwcmVmZXJzLWNvbG9yLXNjaGVtZScsXG4gICdwcmVmZXJzLWNvbnRyYXN0JyxcbiAgJ3ByZWZlcnMtcmVkdWNlZC1tb3Rpb24nLFxuICAncHJlZmVycy1yZWR1Y2VkLXRyYW5zcGFyZW5jeScsXG4gICdyZXNvbHV0aW9uJyxcbiAgJ3NjYW4nLFxuICAnc2NyaXB0aW5nJyxcbiAgJ3VwZGF0ZScsXG4gICd3aWR0aCcsXG4gIC8vIFRPRE86IGZpbmQgYSBiZXR0ZXIgc29sdXRpb24/XG4gICdtaW4td2lkdGgnLFxuICAnbWF4LXdpZHRoJyxcbiAgJ21pbi1oZWlnaHQnLFxuICAnbWF4LWhlaWdodCdcbl07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Qc2V1ZG8tY2xhc3Nlc1xuY29uc3QgUFNFVURPX0NMQVNTRVMgPSBbXG4gICdhY3RpdmUnLFxuICAnYW55LWxpbmsnLFxuICAnYmxhbmsnLFxuICAnY2hlY2tlZCcsXG4gICdjdXJyZW50JyxcbiAgJ2RlZmF1bHQnLFxuICAnZGVmaW5lZCcsXG4gICdkaXInLCAvLyBkaXIoKVxuICAnZGlzYWJsZWQnLFxuICAnZHJvcCcsXG4gICdlbXB0eScsXG4gICdlbmFibGVkJyxcbiAgJ2ZpcnN0JyxcbiAgJ2ZpcnN0LWNoaWxkJyxcbiAgJ2ZpcnN0LW9mLXR5cGUnLFxuICAnZnVsbHNjcmVlbicsXG4gICdmdXR1cmUnLFxuICAnZm9jdXMnLFxuICAnZm9jdXMtdmlzaWJsZScsXG4gICdmb2N1cy13aXRoaW4nLFxuICAnaGFzJywgLy8gaGFzKClcbiAgJ2hvc3QnLCAvLyBob3N0IG9yIGhvc3QoKVxuICAnaG9zdC1jb250ZXh0JywgLy8gaG9zdC1jb250ZXh0KClcbiAgJ2hvdmVyJyxcbiAgJ2luZGV0ZXJtaW5hdGUnLFxuICAnaW4tcmFuZ2UnLFxuICAnaW52YWxpZCcsXG4gICdpcycsIC8vIGlzKClcbiAgJ2xhbmcnLCAvLyBsYW5nKClcbiAgJ2xhc3QtY2hpbGQnLFxuICAnbGFzdC1vZi10eXBlJyxcbiAgJ2xlZnQnLFxuICAnbGluaycsXG4gICdsb2NhbC1saW5rJyxcbiAgJ25vdCcsIC8vIG5vdCgpXG4gICdudGgtY2hpbGQnLCAvLyBudGgtY2hpbGQoKVxuICAnbnRoLWNvbCcsIC8vIG50aC1jb2woKVxuICAnbnRoLWxhc3QtY2hpbGQnLCAvLyBudGgtbGFzdC1jaGlsZCgpXG4gICdudGgtbGFzdC1jb2wnLCAvLyBudGgtbGFzdC1jb2woKVxuICAnbnRoLWxhc3Qtb2YtdHlwZScsIC8vbnRoLWxhc3Qtb2YtdHlwZSgpXG4gICdudGgtb2YtdHlwZScsIC8vbnRoLW9mLXR5cGUoKVxuICAnb25seS1jaGlsZCcsXG4gICdvbmx5LW9mLXR5cGUnLFxuICAnb3B0aW9uYWwnLFxuICAnb3V0LW9mLXJhbmdlJyxcbiAgJ3Bhc3QnLFxuICAncGxhY2Vob2xkZXItc2hvd24nLFxuICAncmVhZC1vbmx5JyxcbiAgJ3JlYWQtd3JpdGUnLFxuICAncmVxdWlyZWQnLFxuICAncmlnaHQnLFxuICAncm9vdCcsXG4gICdzY29wZScsXG4gICd0YXJnZXQnLFxuICAndGFyZ2V0LXdpdGhpbicsXG4gICd1c2VyLWludmFsaWQnLFxuICAndmFsaWQnLFxuICAndmlzaXRlZCcsXG4gICd3aGVyZScgLy8gd2hlcmUoKVxuXTtcblxuLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL1BzZXVkby1lbGVtZW50c1xuY29uc3QgUFNFVURPX0VMRU1FTlRTID0gW1xuICAnYWZ0ZXInLFxuICAnYmFja2Ryb3AnLFxuICAnYmVmb3JlJyxcbiAgJ2N1ZScsXG4gICdjdWUtcmVnaW9uJyxcbiAgJ2ZpcnN0LWxldHRlcicsXG4gICdmaXJzdC1saW5lJyxcbiAgJ2dyYW1tYXItZXJyb3InLFxuICAnbWFya2VyJyxcbiAgJ3BhcnQnLFxuICAncGxhY2Vob2xkZXInLFxuICAnc2VsZWN0aW9uJyxcbiAgJ3Nsb3R0ZWQnLFxuICAnc3BlbGxpbmctZXJyb3InXG5dO1xuXG5jb25zdCBBVFRSSUJVVEVTID0gW1xuICAnYWxpZ24tY29udGVudCcsXG4gICdhbGlnbi1pdGVtcycsXG4gICdhbGlnbi1zZWxmJyxcbiAgJ2FsbCcsXG4gICdhbmltYXRpb24nLFxuICAnYW5pbWF0aW9uLWRlbGF5JyxcbiAgJ2FuaW1hdGlvbi1kaXJlY3Rpb24nLFxuICAnYW5pbWF0aW9uLWR1cmF0aW9uJyxcbiAgJ2FuaW1hdGlvbi1maWxsLW1vZGUnLFxuICAnYW5pbWF0aW9uLWl0ZXJhdGlvbi1jb3VudCcsXG4gICdhbmltYXRpb24tbmFtZScsXG4gICdhbmltYXRpb24tcGxheS1zdGF0ZScsXG4gICdhbmltYXRpb24tdGltaW5nLWZ1bmN0aW9uJyxcbiAgJ2JhY2tmYWNlLXZpc2liaWxpdHknLFxuICAnYmFja2dyb3VuZCcsXG4gICdiYWNrZ3JvdW5kLWF0dGFjaG1lbnQnLFxuICAnYmFja2dyb3VuZC1ibGVuZC1tb2RlJyxcbiAgJ2JhY2tncm91bmQtY2xpcCcsXG4gICdiYWNrZ3JvdW5kLWNvbG9yJyxcbiAgJ2JhY2tncm91bmQtaW1hZ2UnLFxuICAnYmFja2dyb3VuZC1vcmlnaW4nLFxuICAnYmFja2dyb3VuZC1wb3NpdGlvbicsXG4gICdiYWNrZ3JvdW5kLXJlcGVhdCcsXG4gICdiYWNrZ3JvdW5kLXNpemUnLFxuICAnYmxvY2stc2l6ZScsXG4gICdib3JkZXInLFxuICAnYm9yZGVyLWJsb2NrJyxcbiAgJ2JvcmRlci1ibG9jay1jb2xvcicsXG4gICdib3JkZXItYmxvY2stZW5kJyxcbiAgJ2JvcmRlci1ibG9jay1lbmQtY29sb3InLFxuICAnYm9yZGVyLWJsb2NrLWVuZC1zdHlsZScsXG4gICdib3JkZXItYmxvY2stZW5kLXdpZHRoJyxcbiAgJ2JvcmRlci1ibG9jay1zdGFydCcsXG4gICdib3JkZXItYmxvY2stc3RhcnQtY29sb3InLFxuICAnYm9yZGVyLWJsb2NrLXN0YXJ0LXN0eWxlJyxcbiAgJ2JvcmRlci1ibG9jay1zdGFydC13aWR0aCcsXG4gICdib3JkZXItYmxvY2stc3R5bGUnLFxuICAnYm9yZGVyLWJsb2NrLXdpZHRoJyxcbiAgJ2JvcmRlci1ib3R0b20nLFxuICAnYm9yZGVyLWJvdHRvbS1jb2xvcicsXG4gICdib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzJyxcbiAgJ2JvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzJyxcbiAgJ2JvcmRlci1ib3R0b20tc3R5bGUnLFxuICAnYm9yZGVyLWJvdHRvbS13aWR0aCcsXG4gICdib3JkZXItY29sbGFwc2UnLFxuICAnYm9yZGVyLWNvbG9yJyxcbiAgJ2JvcmRlci1pbWFnZScsXG4gICdib3JkZXItaW1hZ2Utb3V0c2V0JyxcbiAgJ2JvcmRlci1pbWFnZS1yZXBlYXQnLFxuICAnYm9yZGVyLWltYWdlLXNsaWNlJyxcbiAgJ2JvcmRlci1pbWFnZS1zb3VyY2UnLFxuICAnYm9yZGVyLWltYWdlLXdpZHRoJyxcbiAgJ2JvcmRlci1pbmxpbmUnLFxuICAnYm9yZGVyLWlubGluZS1jb2xvcicsXG4gICdib3JkZXItaW5saW5lLWVuZCcsXG4gICdib3JkZXItaW5saW5lLWVuZC1jb2xvcicsXG4gICdib3JkZXItaW5saW5lLWVuZC1zdHlsZScsXG4gICdib3JkZXItaW5saW5lLWVuZC13aWR0aCcsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0JyxcbiAgJ2JvcmRlci1pbmxpbmUtc3RhcnQtY29sb3InLFxuICAnYm9yZGVyLWlubGluZS1zdGFydC1zdHlsZScsXG4gICdib3JkZXItaW5saW5lLXN0YXJ0LXdpZHRoJyxcbiAgJ2JvcmRlci1pbmxpbmUtc3R5bGUnLFxuICAnYm9yZGVyLWlubGluZS13aWR0aCcsXG4gICdib3JkZXItbGVmdCcsXG4gICdib3JkZXItbGVmdC1jb2xvcicsXG4gICdib3JkZXItbGVmdC1zdHlsZScsXG4gICdib3JkZXItbGVmdC13aWR0aCcsXG4gICdib3JkZXItcmFkaXVzJyxcbiAgJ2JvcmRlci1yaWdodCcsXG4gICdib3JkZXItcmlnaHQtY29sb3InLFxuICAnYm9yZGVyLXJpZ2h0LXN0eWxlJyxcbiAgJ2JvcmRlci1yaWdodC13aWR0aCcsXG4gICdib3JkZXItc3BhY2luZycsXG4gICdib3JkZXItc3R5bGUnLFxuICAnYm9yZGVyLXRvcCcsXG4gICdib3JkZXItdG9wLWNvbG9yJyxcbiAgJ2JvcmRlci10b3AtbGVmdC1yYWRpdXMnLFxuICAnYm9yZGVyLXRvcC1yaWdodC1yYWRpdXMnLFxuICAnYm9yZGVyLXRvcC1zdHlsZScsXG4gICdib3JkZXItdG9wLXdpZHRoJyxcbiAgJ2JvcmRlci13aWR0aCcsXG4gICdib3R0b20nLFxuICAnYm94LWRlY29yYXRpb24tYnJlYWsnLFxuICAnYm94LXNoYWRvdycsXG4gICdib3gtc2l6aW5nJyxcbiAgJ2JyZWFrLWFmdGVyJyxcbiAgJ2JyZWFrLWJlZm9yZScsXG4gICdicmVhay1pbnNpZGUnLFxuICAnY2FwdGlvbi1zaWRlJyxcbiAgJ2NhcmV0LWNvbG9yJyxcbiAgJ2NsZWFyJyxcbiAgJ2NsaXAnLFxuICAnY2xpcC1wYXRoJyxcbiAgJ2NsaXAtcnVsZScsXG4gICdjb2xvcicsXG4gICdjb2x1bW4tY291bnQnLFxuICAnY29sdW1uLWZpbGwnLFxuICAnY29sdW1uLWdhcCcsXG4gICdjb2x1bW4tcnVsZScsXG4gICdjb2x1bW4tcnVsZS1jb2xvcicsXG4gICdjb2x1bW4tcnVsZS1zdHlsZScsXG4gICdjb2x1bW4tcnVsZS13aWR0aCcsXG4gICdjb2x1bW4tc3BhbicsXG4gICdjb2x1bW4td2lkdGgnLFxuICAnY29sdW1ucycsXG4gICdjb250YWluJyxcbiAgJ2NvbnRlbnQnLFxuICAnY29udGVudC12aXNpYmlsaXR5JyxcbiAgJ2NvdW50ZXItaW5jcmVtZW50JyxcbiAgJ2NvdW50ZXItcmVzZXQnLFxuICAnY3VlJyxcbiAgJ2N1ZS1hZnRlcicsXG4gICdjdWUtYmVmb3JlJyxcbiAgJ2N1cnNvcicsXG4gICdkaXJlY3Rpb24nLFxuICAnZGlzcGxheScsXG4gICdlbXB0eS1jZWxscycsXG4gICdmaWx0ZXInLFxuICAnZmxleCcsXG4gICdmbGV4LWJhc2lzJyxcbiAgJ2ZsZXgtZGlyZWN0aW9uJyxcbiAgJ2ZsZXgtZmxvdycsXG4gICdmbGV4LWdyb3cnLFxuICAnZmxleC1zaHJpbmsnLFxuICAnZmxleC13cmFwJyxcbiAgJ2Zsb2F0JyxcbiAgJ2Zsb3cnLFxuICAnZm9udCcsXG4gICdmb250LWRpc3BsYXknLFxuICAnZm9udC1mYW1pbHknLFxuICAnZm9udC1mZWF0dXJlLXNldHRpbmdzJyxcbiAgJ2ZvbnQta2VybmluZycsXG4gICdmb250LWxhbmd1YWdlLW92ZXJyaWRlJyxcbiAgJ2ZvbnQtc2l6ZScsXG4gICdmb250LXNpemUtYWRqdXN0JyxcbiAgJ2ZvbnQtc21vb3RoaW5nJyxcbiAgJ2ZvbnQtc3RyZXRjaCcsXG4gICdmb250LXN0eWxlJyxcbiAgJ2ZvbnQtc3ludGhlc2lzJyxcbiAgJ2ZvbnQtdmFyaWFudCcsXG4gICdmb250LXZhcmlhbnQtY2FwcycsXG4gICdmb250LXZhcmlhbnQtZWFzdC1hc2lhbicsXG4gICdmb250LXZhcmlhbnQtbGlnYXR1cmVzJyxcbiAgJ2ZvbnQtdmFyaWFudC1udW1lcmljJyxcbiAgJ2ZvbnQtdmFyaWFudC1wb3NpdGlvbicsXG4gICdmb250LXZhcmlhdGlvbi1zZXR0aW5ncycsXG4gICdmb250LXdlaWdodCcsXG4gICdnYXAnLFxuICAnZ2x5cGgtb3JpZW50YXRpb24tdmVydGljYWwnLFxuICAnZ3JpZCcsXG4gICdncmlkLWFyZWEnLFxuICAnZ3JpZC1hdXRvLWNvbHVtbnMnLFxuICAnZ3JpZC1hdXRvLWZsb3cnLFxuICAnZ3JpZC1hdXRvLXJvd3MnLFxuICAnZ3JpZC1jb2x1bW4nLFxuICAnZ3JpZC1jb2x1bW4tZW5kJyxcbiAgJ2dyaWQtY29sdW1uLXN0YXJ0JyxcbiAgJ2dyaWQtZ2FwJyxcbiAgJ2dyaWQtcm93JyxcbiAgJ2dyaWQtcm93LWVuZCcsXG4gICdncmlkLXJvdy1zdGFydCcsXG4gICdncmlkLXRlbXBsYXRlJyxcbiAgJ2dyaWQtdGVtcGxhdGUtYXJlYXMnLFxuICAnZ3JpZC10ZW1wbGF0ZS1jb2x1bW5zJyxcbiAgJ2dyaWQtdGVtcGxhdGUtcm93cycsXG4gICdoYW5naW5nLXB1bmN0dWF0aW9uJyxcbiAgJ2hlaWdodCcsXG4gICdoeXBoZW5zJyxcbiAgJ2ljb24nLFxuICAnaW1hZ2Utb3JpZW50YXRpb24nLFxuICAnaW1hZ2UtcmVuZGVyaW5nJyxcbiAgJ2ltYWdlLXJlc29sdXRpb24nLFxuICAnaW1lLW1vZGUnLFxuICAnaW5saW5lLXNpemUnLFxuICAnaXNvbGF0aW9uJyxcbiAgJ2p1c3RpZnktY29udGVudCcsXG4gICdsZWZ0JyxcbiAgJ2xldHRlci1zcGFjaW5nJyxcbiAgJ2xpbmUtYnJlYWsnLFxuICAnbGluZS1oZWlnaHQnLFxuICAnbGlzdC1zdHlsZScsXG4gICdsaXN0LXN0eWxlLWltYWdlJyxcbiAgJ2xpc3Qtc3R5bGUtcG9zaXRpb24nLFxuICAnbGlzdC1zdHlsZS10eXBlJyxcbiAgJ21hcmdpbicsXG4gICdtYXJnaW4tYmxvY2snLFxuICAnbWFyZ2luLWJsb2NrLWVuZCcsXG4gICdtYXJnaW4tYmxvY2stc3RhcnQnLFxuICAnbWFyZ2luLWJvdHRvbScsXG4gICdtYXJnaW4taW5saW5lJyxcbiAgJ21hcmdpbi1pbmxpbmUtZW5kJyxcbiAgJ21hcmdpbi1pbmxpbmUtc3RhcnQnLFxuICAnbWFyZ2luLWxlZnQnLFxuICAnbWFyZ2luLXJpZ2h0JyxcbiAgJ21hcmdpbi10b3AnLFxuICAnbWFya3MnLFxuICAnbWFzaycsXG4gICdtYXNrLWJvcmRlcicsXG4gICdtYXNrLWJvcmRlci1tb2RlJyxcbiAgJ21hc2stYm9yZGVyLW91dHNldCcsXG4gICdtYXNrLWJvcmRlci1yZXBlYXQnLFxuICAnbWFzay1ib3JkZXItc2xpY2UnLFxuICAnbWFzay1ib3JkZXItc291cmNlJyxcbiAgJ21hc2stYm9yZGVyLXdpZHRoJyxcbiAgJ21hc2stY2xpcCcsXG4gICdtYXNrLWNvbXBvc2l0ZScsXG4gICdtYXNrLWltYWdlJyxcbiAgJ21hc2stbW9kZScsXG4gICdtYXNrLW9yaWdpbicsXG4gICdtYXNrLXBvc2l0aW9uJyxcbiAgJ21hc2stcmVwZWF0JyxcbiAgJ21hc2stc2l6ZScsXG4gICdtYXNrLXR5cGUnLFxuICAnbWF4LWJsb2NrLXNpemUnLFxuICAnbWF4LWhlaWdodCcsXG4gICdtYXgtaW5saW5lLXNpemUnLFxuICAnbWF4LXdpZHRoJyxcbiAgJ21pbi1ibG9jay1zaXplJyxcbiAgJ21pbi1oZWlnaHQnLFxuICAnbWluLWlubGluZS1zaXplJyxcbiAgJ21pbi13aWR0aCcsXG4gICdtaXgtYmxlbmQtbW9kZScsXG4gICduYXYtZG93bicsXG4gICduYXYtaW5kZXgnLFxuICAnbmF2LWxlZnQnLFxuICAnbmF2LXJpZ2h0JyxcbiAgJ25hdi11cCcsXG4gICdub25lJyxcbiAgJ25vcm1hbCcsXG4gICdvYmplY3QtZml0JyxcbiAgJ29iamVjdC1wb3NpdGlvbicsXG4gICdvcGFjaXR5JyxcbiAgJ29yZGVyJyxcbiAgJ29ycGhhbnMnLFxuICAnb3V0bGluZScsXG4gICdvdXRsaW5lLWNvbG9yJyxcbiAgJ291dGxpbmUtb2Zmc2V0JyxcbiAgJ291dGxpbmUtc3R5bGUnLFxuICAnb3V0bGluZS13aWR0aCcsXG4gICdvdmVyZmxvdycsXG4gICdvdmVyZmxvdy13cmFwJyxcbiAgJ292ZXJmbG93LXgnLFxuICAnb3ZlcmZsb3cteScsXG4gICdwYWRkaW5nJyxcbiAgJ3BhZGRpbmctYmxvY2snLFxuICAncGFkZGluZy1ibG9jay1lbmQnLFxuICAncGFkZGluZy1ibG9jay1zdGFydCcsXG4gICdwYWRkaW5nLWJvdHRvbScsXG4gICdwYWRkaW5nLWlubGluZScsXG4gICdwYWRkaW5nLWlubGluZS1lbmQnLFxuICAncGFkZGluZy1pbmxpbmUtc3RhcnQnLFxuICAncGFkZGluZy1sZWZ0JyxcbiAgJ3BhZGRpbmctcmlnaHQnLFxuICAncGFkZGluZy10b3AnLFxuICAncGFnZS1icmVhay1hZnRlcicsXG4gICdwYWdlLWJyZWFrLWJlZm9yZScsXG4gICdwYWdlLWJyZWFrLWluc2lkZScsXG4gICdwYXVzZScsXG4gICdwYXVzZS1hZnRlcicsXG4gICdwYXVzZS1iZWZvcmUnLFxuICAncGVyc3BlY3RpdmUnLFxuICAncGVyc3BlY3RpdmUtb3JpZ2luJyxcbiAgJ3BvaW50ZXItZXZlbnRzJyxcbiAgJ3Bvc2l0aW9uJyxcbiAgJ3F1b3RlcycsXG4gICdyZXNpemUnLFxuICAncmVzdCcsXG4gICdyZXN0LWFmdGVyJyxcbiAgJ3Jlc3QtYmVmb3JlJyxcbiAgJ3JpZ2h0JyxcbiAgJ3Jvdy1nYXAnLFxuICAnc2Nyb2xsLW1hcmdpbicsXG4gICdzY3JvbGwtbWFyZ2luLWJsb2NrJyxcbiAgJ3Njcm9sbC1tYXJnaW4tYmxvY2stZW5kJyxcbiAgJ3Njcm9sbC1tYXJnaW4tYmxvY2stc3RhcnQnLFxuICAnc2Nyb2xsLW1hcmdpbi1ib3R0b20nLFxuICAnc2Nyb2xsLW1hcmdpbi1pbmxpbmUnLFxuICAnc2Nyb2xsLW1hcmdpbi1pbmxpbmUtZW5kJyxcbiAgJ3Njcm9sbC1tYXJnaW4taW5saW5lLXN0YXJ0JyxcbiAgJ3Njcm9sbC1tYXJnaW4tbGVmdCcsXG4gICdzY3JvbGwtbWFyZ2luLXJpZ2h0JyxcbiAgJ3Njcm9sbC1tYXJnaW4tdG9wJyxcbiAgJ3Njcm9sbC1wYWRkaW5nJyxcbiAgJ3Njcm9sbC1wYWRkaW5nLWJsb2NrJyxcbiAgJ3Njcm9sbC1wYWRkaW5nLWJsb2NrLWVuZCcsXG4gICdzY3JvbGwtcGFkZGluZy1ibG9jay1zdGFydCcsXG4gICdzY3JvbGwtcGFkZGluZy1ib3R0b20nLFxuICAnc2Nyb2xsLXBhZGRpbmctaW5saW5lJyxcbiAgJ3Njcm9sbC1wYWRkaW5nLWlubGluZS1lbmQnLFxuICAnc2Nyb2xsLXBhZGRpbmctaW5saW5lLXN0YXJ0JyxcbiAgJ3Njcm9sbC1wYWRkaW5nLWxlZnQnLFxuICAnc2Nyb2xsLXBhZGRpbmctcmlnaHQnLFxuICAnc2Nyb2xsLXBhZGRpbmctdG9wJyxcbiAgJ3Njcm9sbC1zbmFwLWFsaWduJyxcbiAgJ3Njcm9sbC1zbmFwLXN0b3AnLFxuICAnc2Nyb2xsLXNuYXAtdHlwZScsXG4gICdzY3JvbGxiYXItY29sb3InLFxuICAnc2Nyb2xsYmFyLWd1dHRlcicsXG4gICdzY3JvbGxiYXItd2lkdGgnLFxuICAnc2hhcGUtaW1hZ2UtdGhyZXNob2xkJyxcbiAgJ3NoYXBlLW1hcmdpbicsXG4gICdzaGFwZS1vdXRzaWRlJyxcbiAgJ3NwZWFrJyxcbiAgJ3NwZWFrLWFzJyxcbiAgJ3NyYycsIC8vIEBmb250LWZhY2VcbiAgJ3RhYi1zaXplJyxcbiAgJ3RhYmxlLWxheW91dCcsXG4gICd0ZXh0LWFsaWduJyxcbiAgJ3RleHQtYWxpZ24tYWxsJyxcbiAgJ3RleHQtYWxpZ24tbGFzdCcsXG4gICd0ZXh0LWNvbWJpbmUtdXByaWdodCcsXG4gICd0ZXh0LWRlY29yYXRpb24nLFxuICAndGV4dC1kZWNvcmF0aW9uLWNvbG9yJyxcbiAgJ3RleHQtZGVjb3JhdGlvbi1saW5lJyxcbiAgJ3RleHQtZGVjb3JhdGlvbi1zdHlsZScsXG4gICd0ZXh0LWVtcGhhc2lzJyxcbiAgJ3RleHQtZW1waGFzaXMtY29sb3InLFxuICAndGV4dC1lbXBoYXNpcy1wb3NpdGlvbicsXG4gICd0ZXh0LWVtcGhhc2lzLXN0eWxlJyxcbiAgJ3RleHQtaW5kZW50JyxcbiAgJ3RleHQtanVzdGlmeScsXG4gICd0ZXh0LW9yaWVudGF0aW9uJyxcbiAgJ3RleHQtb3ZlcmZsb3cnLFxuICAndGV4dC1yZW5kZXJpbmcnLFxuICAndGV4dC1zaGFkb3cnLFxuICAndGV4dC10cmFuc2Zvcm0nLFxuICAndGV4dC11bmRlcmxpbmUtcG9zaXRpb24nLFxuICAndG9wJyxcbiAgJ3RyYW5zZm9ybScsXG4gICd0cmFuc2Zvcm0tYm94JyxcbiAgJ3RyYW5zZm9ybS1vcmlnaW4nLFxuICAndHJhbnNmb3JtLXN0eWxlJyxcbiAgJ3RyYW5zaXRpb24nLFxuICAndHJhbnNpdGlvbi1kZWxheScsXG4gICd0cmFuc2l0aW9uLWR1cmF0aW9uJyxcbiAgJ3RyYW5zaXRpb24tcHJvcGVydHknLFxuICAndHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb24nLFxuICAndW5pY29kZS1iaWRpJyxcbiAgJ3ZlcnRpY2FsLWFsaWduJyxcbiAgJ3Zpc2liaWxpdHknLFxuICAndm9pY2UtYmFsYW5jZScsXG4gICd2b2ljZS1kdXJhdGlvbicsXG4gICd2b2ljZS1mYW1pbHknLFxuICAndm9pY2UtcGl0Y2gnLFxuICAndm9pY2UtcmFuZ2UnLFxuICAndm9pY2UtcmF0ZScsXG4gICd2b2ljZS1zdHJlc3MnLFxuICAndm9pY2Utdm9sdW1lJyxcbiAgJ3doaXRlLXNwYWNlJyxcbiAgJ3dpZG93cycsXG4gICd3aWR0aCcsXG4gICd3aWxsLWNoYW5nZScsXG4gICd3b3JkLWJyZWFrJyxcbiAgJ3dvcmQtc3BhY2luZycsXG4gICd3b3JkLXdyYXAnLFxuICAnd3JpdGluZy1tb2RlJyxcbiAgJ3otaW5kZXgnXG4gIC8vIHJldmVyc2UgbWFrZXMgc3VyZSBsb25nZXIgYXR0cmlidXRlcyBgZm9udC13ZWlnaHRgIGFyZSBtYXRjaGVkIGZ1bGx5XG4gIC8vIGluc3RlYWQgb2YgZ2V0dGluZyBmYWxzZSBwb3NpdGl2ZXMgb24gc2F5IGBmb250YFxuXS5yZXZlcnNlKCk7XG5cbi8qXG5MYW5ndWFnZTogQ1NTXG5DYXRlZ29yeTogY29tbW9uLCBjc3MsIHdlYlxuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTXG4qL1xuXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiBjc3MoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIGNvbnN0IG1vZGVzID0gTU9ERVMoaGxqcyk7XG4gIGNvbnN0IFZFTkRPUl9QUkVGSVggPSB7IGJlZ2luOiAvLSh3ZWJraXR8bW96fG1zfG8pLSg/PVthLXpdKS8gfTtcbiAgY29uc3QgQVRfTU9ESUZJRVJTID0gXCJhbmQgb3Igbm90IG9ubHlcIjtcbiAgY29uc3QgQVRfUFJPUEVSVFlfUkUgPSAvQC0/XFx3W1xcd10qKC1cXHcrKSovOyAvLyBALXdlYmtpdC1rZXlmcmFtZXNcbiAgY29uc3QgSURFTlRfUkUgPSAnW2EtekEtWi1dW2EtekEtWjAtOV8tXSonO1xuICBjb25zdCBTVFJJTkdTID0gW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFXG4gIF07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnQ1NTJyxcbiAgICBjYXNlX2luc2Vuc2l0aXZlOiB0cnVlLFxuICAgIGlsbGVnYWw6IC9bPXwnXFwkXS8sXG4gICAga2V5d29yZHM6IHsga2V5ZnJhbWVQb3NpdGlvbjogXCJmcm9tIHRvXCIgfSxcbiAgICBjbGFzc05hbWVBbGlhc2VzOiB7XG4gICAgICAvLyBmb3IgdmlzdWFsIGNvbnRpbnVpdHkgd2l0aCBgdGFnIHt9YCBhbmQgYmVjYXVzZSB3ZVxuICAgICAgLy8gZG9uJ3QgaGF2ZSBhIGdyZWF0IGNsYXNzIGZvciB0aGlzP1xuICAgICAga2V5ZnJhbWVQb3NpdGlvbjogXCJzZWxlY3Rvci10YWdcIiB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBtb2Rlcy5CTE9DS19DT01NRU5ULFxuICAgICAgVkVORE9SX1BSRUZJWCxcbiAgICAgIC8vIHRvIHJlY29nbml6ZSBrZXlmcmFtZSA0MCUgZXRjIHdoaWNoIGFyZSBvdXRzaWRlIHRoZSBzY29wZSBvZiBvdXJcbiAgICAgIC8vIGF0dHJpYnV0ZSB2YWx1ZSBtb2RlXG4gICAgICBtb2Rlcy5DU1NfTlVNQkVSX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWlkJyxcbiAgICAgICAgYmVnaW46IC8jW0EtWmEtejAtOV8tXSsvLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLWNsYXNzJyxcbiAgICAgICAgYmVnaW46ICdcXFxcLicgKyBJREVOVF9SRSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgbW9kZXMuQVRUUklCVVRFX1NFTEVDVE9SX01PREUsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ3NlbGVjdG9yLXBzZXVkbycsXG4gICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgeyBiZWdpbjogJzooJyArIFBTRVVET19DTEFTU0VTLmpvaW4oJ3wnKSArICcpJyB9LFxuICAgICAgICAgIHsgYmVnaW46ICc6KDopPygnICsgUFNFVURPX0VMRU1FTlRTLmpvaW4oJ3wnKSArICcpJyB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyB3ZSBtYXkgYWN0dWFsbHkgbmVlZCB0aGlzICgxMi8yMDIwKVxuICAgICAgLy8geyAvLyBwc2V1ZG8tc2VsZWN0b3IgcGFyYW1zXG4gICAgICAvLyAgIGJlZ2luOiAvXFwoLyxcbiAgICAgIC8vICAgZW5kOiAvXFwpLyxcbiAgICAgIC8vICAgY29udGFpbnM6IFsgaGxqcy5DU1NfTlVNQkVSX01PREUgXVxuICAgICAgLy8gfSxcbiAgICAgIG1vZGVzLkNTU19WQVJJQUJMRSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cmlidXRlJyxcbiAgICAgICAgYmVnaW46ICdcXFxcYignICsgQVRUUklCVVRFUy5qb2luKCd8JykgKyAnKVxcXFxiJ1xuICAgICAgfSxcbiAgICAgIC8vIGF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgIHtcbiAgICAgICAgYmVnaW46IC86LyxcbiAgICAgICAgZW5kOiAvWzt9e10vLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIG1vZGVzLkJMT0NLX0NPTU1FTlQsXG4gICAgICAgICAgbW9kZXMuSEVYQ09MT1IsXG4gICAgICAgICAgbW9kZXMuSU1QT1JUQU5ULFxuICAgICAgICAgIG1vZGVzLkNTU19OVU1CRVJfTU9ERSxcbiAgICAgICAgICAuLi5TVFJJTkdTLFxuICAgICAgICAgIC8vIG5lZWRlZCB0byBoaWdobGlnaHQgdGhlc2UgYXMgc3RyaW5ncyBhbmQgdG8gYXZvaWQgaXNzdWVzIHdpdGhcbiAgICAgICAgICAvLyBpbGxlZ2FsIGNoYXJhY3RlcnMgdGhhdCBtaWdodCBiZSBpbnNpZGUgdXJscyB0aGF0IHdvdWxkIHRpZ2dlciB0aGVcbiAgICAgICAgICAvLyBsYW5ndWFnZXMgaWxsZWdhbCBzdGFja1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvKHVybHxkYXRhLXVyaSlcXCgvLFxuICAgICAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCwgLy8gZnJvbSBrZXl3b3Jkc1xuICAgICAgICAgICAga2V5d29yZHM6IHsgYnVpbHRfaW46IFwidXJsIGRhdGEtdXJpXCIgfSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIC4uLlNUUklOR1MsXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6IFwic3RyaW5nXCIsXG4gICAgICAgICAgICAgICAgLy8gYW55IGNoYXJhY3RlciBvdGhlciB0aGFuIGApYCBhcyBpbiBgdXJsKClgIHdpbGwgYmUgdGhlIHN0YXJ0XG4gICAgICAgICAgICAgICAgLy8gb2YgYSBzdHJpbmcsIHdoaWNoIGVuZHMgd2l0aCBgKWAgKGZyb20gdGhlIHBhcmVudCBtb2RlKVxuICAgICAgICAgICAgICAgIGJlZ2luOiAvW14pXS8sXG4gICAgICAgICAgICAgICAgZW5kc1dpdGhQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2Rlcy5GVU5DVElPTl9ESVNQQVRDSFxuICAgICAgICBdXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBiZWdpbjogcmVnZXgubG9va2FoZWFkKC9ALyksXG4gICAgICAgIGVuZDogJ1t7O10nLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGlsbGVnYWw6IC86LywgLy8gYnJlYWsgb24gTGVzcyB2YXJpYWJsZXMgQHZhcjogLi4uXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgICAgICAgICBiZWdpbjogQVRfUFJPUEVSVFlfUkVcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvXFxzLyxcbiAgICAgICAgICAgIGVuZHNXaXRoUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICAgIGtleXdvcmRzOiB7XG4gICAgICAgICAgICAgICRwYXR0ZXJuOiAvW2Etei1dKy8sXG4gICAgICAgICAgICAgIGtleXdvcmQ6IEFUX01PRElGSUVSUyxcbiAgICAgICAgICAgICAgYXR0cmlidXRlOiBNRURJQV9GRUFUVVJFUy5qb2luKFwiIFwiKVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogL1thLXotXSsoPz06KS8sXG4gICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBcImF0dHJpYnV0ZVwiXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIC4uLlNUUklOR1MsXG4gICAgICAgICAgICAgIG1vZGVzLkNTU19OVU1CRVJfTU9ERVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnc2VsZWN0b3ItdGFnJyxcbiAgICAgICAgYmVnaW46ICdcXFxcYignICsgVEFHUy5qb2luKCd8JykgKyAnKVxcXFxiJ1xuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IHsgY3NzIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJNT0RFUyIsImhsanMiLCJJTVBPUlRBTlQiLCJzY29wZSIsImJlZ2luIiwiQkxPQ0tfQ09NTUVOVCIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiSEVYQ09MT1IiLCJGVU5DVElPTl9ESVNQQVRDSCIsImNsYXNzTmFtZSIsIkFUVFJJQlVURV9TRUxFQ1RPUl9NT0RFIiwiZW5kIiwiaWxsZWdhbCIsImNvbnRhaW5zIiwiQVBPU19TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiQ1NTX05VTUJFUl9NT0RFIiwiTlVNQkVSX1JFIiwicmVsZXZhbmNlIiwiQ1NTX1ZBUklBQkxFIiwiVEFHUyIsIk1FRElBX0ZFQVRVUkVTIiwiUFNFVURPX0NMQVNTRVMiLCJQU0VVRE9fRUxFTUVOVFMiLCJBVFRSSUJVVEVTIiwicmV2ZXJzZSIsImNzcyIsInJlZ2V4IiwibW9kZXMiLCJWRU5ET1JfUFJFRklYIiwiQVRfTU9ESUZJRVJTIiwiQVRfUFJPUEVSVFlfUkUiLCJJREVOVF9SRSIsIlNUUklOR1MiLCJuYW1lIiwiY2FzZV9pbnNlbnNpdGl2ZSIsImtleXdvcmRzIiwia2V5ZnJhbWVQb3NpdGlvbiIsImNsYXNzTmFtZUFsaWFzZXMiLCJ2YXJpYW50cyIsImpvaW4iLCJidWlsdF9pbiIsImVuZHNXaXRoUGFyZW50IiwiZXhjbHVkZUVuZCIsImxvb2thaGVhZCIsIiRwYXR0ZXJuIiwia2V5d29yZCIsImF0dHJpYnV0ZSIsImRlZmF1bHQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/css.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/javascript.js":
/*!**************************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/javascript.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ javascript)\n/* harmony export */ });\nconst IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    // JS handles these with a special rule\n    // \"get\",\n    // \"set\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n];\nconst LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n    \"NaN\",\n    \"Infinity\"\n];\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nconst TYPES = [\n    // Fundamental objects\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    // numbers and dates\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    // text\n    \"String\",\n    \"RegExp\",\n    // Indexed collections\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    // Keyed collections\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    // Structured data\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    // Control abstraction objects\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    // Reflection\n    \"Reflect\",\n    \"Proxy\",\n    // Internationalization\n    \"Intl\",\n    // WebAssembly\n    \"WebAssembly\"\n];\nconst ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n];\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n];\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"sessionStorage\",\n    \"module\",\n    \"global\" // Node.js\n];\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/ /** @type LanguageFn */ function javascript(hljs) {\n    const regex = hljs.regex;\n    /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */ const hasClosingTag = (match, { after })=>{\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    // to avoid some special cases inside isTrulyOpeningTag\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */ isTrulyOpeningTag: (match, response)=>{\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            if (// HTML should not include another raw `<` inside a tag\n            // nested type?\n            // `<Array<Array<number>>`, etc.\n            nextChar === \"<\" || // the , gives away that this is not HTML\n            // `<T, A extends keyof T, V>`\n            nextChar === \",\") {\n                response.ignoreMatch();\n                return;\n            }\n            // `<something>`\n            // Quite possibly a tag, lets look for a matching closing tag...\n            if (nextChar === \">\") {\n                // if we cannot find a matching closing tag, then we\n                // will ignore it\n                if (!hasClosingTag(match, {\n                    after: afterMatchIndex\n                })) {\n                    response.ignoreMatch();\n                }\n            }\n            // `<blah />` (self-closing)\n            // handled by simpleSelfClosing rule\n            let m;\n            const afterMatch = match.input.substring(afterMatchIndex);\n            // some more template typing stuff\n            //  <T = any>(key?: string) => Modify<\n            if (m = afterMatch.match(/^\\s*=/)) {\n                response.ignoreMatch();\n                return;\n            }\n            // `<From extends string>`\n            // technically this could be HTML, but it smells like a type\n            // NOTE: This is ugh, but added specifically for https://github.com/highlightjs/highlight.js/issues/3276\n            if (m = afterMatch.match(/^\\s+extends\\s+/)) {\n                if (m.index === 0) {\n                    response.ignoreMatch();\n                    // eslint-disable-next-line no-useless-return\n                    return;\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS,\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    // https://tc39.es/ecma262/#sec-literals-numeric-literals\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            // DecimalLiteral\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` + `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            {\n                begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b`\n            },\n            // DecimalBigIntegerLiteral\n            {\n                begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b`\n            },\n            // NonDecimalIntegerLiteral\n            {\n                begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\"\n            },\n            // LegacyOctalIntegerLiteral (does not include underscore separators)\n            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n            {\n                begin: \"\\\\b0[0-7]+n?\\\\b\"\n            }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: [] // defined later\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"css\"\n        }\n    };\n    const GRAPHQL_TEMPLATE = {\n        begin: \"gql`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"graphql\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n        ]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                begin: \"(?=@[A-Za-z]+)\",\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    },\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        excludeEnd: true,\n                        excludeBegin: true,\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    // eat spaces (not newlines) so we can find\n                    // types or variables\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        GRAPHQL_TEMPLATE,\n        TEMPLATE_STRING,\n        // Skip numbers when they are part of a variable name\n        {\n            match: /\\$\\d+/\n        },\n        NUMBER\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        // we need to pair up {} inside our subst to prevent\n        // it from ending too early by matching another }\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\n            \"self\"\n        ].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        // eat recursive parens in sub expressions\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\n                \"self\"\n            ].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    // ES6 classes\n    const CLASS_OR_EXTENDS = {\n        variants: [\n            // class Car extends vehicle\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /\\s+/,\n                    /extends/,\n                    /\\s+/,\n                    regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\",\n                    5: \"keyword\",\n                    7: \"title.class.inherited\"\n                }\n            },\n            // class Car\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ]\n    };\n    const CLASS_REFERENCE = {\n        relevance: 0,\n        match: regex.either(// Hard coded exceptions\n        /\\bJSON/, // Float32Array, OutT\n        /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/, // CSSFactory, CSSFactoryT\n        /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/, // FPs, FPsT\n        /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/),\n        className: \"title.class\",\n        keywords: {\n            _: [\n                // se we still get relevance credit for JS library classes\n                ...TYPES,\n                ...ERROR_TYPES\n            ]\n        }\n    };\n    const USE_STRICT = {\n        label: \"use_strict\",\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n        variants: [\n            {\n                match: [\n                    /function/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /(?=\\s*\\()/\n                ]\n            },\n            // anonymous function\n            {\n                match: [\n                    /function/,\n                    /\\s*(?=\\()/\n                ]\n            }\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        label: \"func.def\",\n        contains: [\n            PARAMS\n        ],\n        illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n        relevance: 0,\n        match: /\\b[A-Z][A-Z_0-9]+\\b/,\n        className: \"variable.constant\"\n    };\n    function noneOf(list) {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n        match: regex.concat(/\\b/, noneOf([\n            ...BUILT_IN_GLOBALS,\n            \"super\",\n            \"import\"\n        ]), IDENT_RE$1, regex.lookahead(/\\(/)),\n        className: \"title.function\",\n        relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n        begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),\n        end: IDENT_RE$1,\n        excludeBegin: true,\n        keywords: \"prototype\",\n        className: \"property\",\n        relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n        match: [\n            /get|set/,\n            /\\s+/,\n            IDENT_RE$1,\n            /(?=\\()/\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            {\n                begin: /\\(\\)/\n            },\n            PARAMS\n        ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)|\" + hljs.UNDERSCORE_IDENT_RE + \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n        match: [\n            /const|var|let/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s*/,\n            /=\\s*/,\n            /(async\\s*)?/,\n            regex.lookahead(FUNC_LEAD_IN_RE)\n        ],\n        keywords: \"async\",\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            PARAMS\n        ]\n    };\n    return {\n        name: \"JavaScript\",\n        aliases: [\n            \"js\",\n            \"jsx\",\n            \"mjs\",\n            \"cjs\"\n        ],\n        keywords: KEYWORDS$1,\n        // this will be extended by TypeScript\n        exports: {\n            PARAMS_CONTAINS,\n            CLASS_REFERENCE\n        },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            USE_STRICT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            GRAPHQL_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            // Skip numbers when they are part of a variable name\n            {\n                match: /\\$\\d+/\n            },\n            NUMBER,\n            CLASS_REFERENCE,\n            {\n                className: \"attr\",\n                begin: IDENT_RE$1 + regex.lookahead(\":\"),\n                relevance: 0\n            },\n            FUNCTION_VARIABLE,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                relevance: 0,\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        // we have to count the parens to make sure we actually have the\n                        // correct bounding ( ) before the =>.  There could be any number of\n                        // sub-expressions inside also surrounded by parens.\n                        begin: FUNC_LEAD_IN_RE,\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                    {\n                        variants: [\n                            {\n                                begin: FRAGMENT.begin,\n                                end: FRAGMENT.end\n                            },\n                            {\n                                match: XML_SELF_CLOSING\n                            },\n                            {\n                                begin: XML_TAG.begin,\n                                // we carefully check the opening tag to see if it truly\n                                // is a tag and not a false positive\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\n                                    \"self\"\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            FUNCTION_DEFINITION,\n            {\n                // prevent this from getting swallowed up by function\n                // since they appear \"function like\"\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                // we have to count the parens to make sure we actually have the correct\n                // bounding ( ).  There could be any number of sub-expressions inside\n                // also surrounded by parens.\n                begin: \"\\\\b(?!function)\" + hljs.UNDERSCORE_IDENT_RE + \"\\\\(\" + // first parens\n                \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1,\n                        className: \"title.function\"\n                    })\n                ]\n            },\n            // catch ... so it won't trigger the property rule below\n            {\n                match: /\\.\\.\\./,\n                relevance: 0\n            },\n            PROPERTY_ACCESS,\n            // hack: prevents detection of keywords in some circumstances\n            // .keyword()\n            // $keyword = x\n            {\n                match: \"\\\\$\" + IDENT_RE$1,\n                relevance: 0\n            },\n            {\n                match: [\n                    /\\bconstructor(?=\\s*\\()/\n                ],\n                className: {\n                    1: \"title.function\"\n                },\n                contains: [\n                    PARAMS\n                ]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            GETTER_OR_SETTER,\n            {\n                match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n            }\n        ]\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy9qYXZhc2NyaXB0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSx1Q0FBdUM7SUFDdkMsU0FBUztJQUNULFNBQVM7SUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFDRCxNQUFNQyxXQUFXO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxtRkFBbUY7QUFDbkYsTUFBTUMsUUFBUTtJQUNaLHNCQUFzQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLG9CQUFvQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE9BQU87SUFDUDtJQUNBO0lBQ0Esc0JBQXNCO0lBQ3RCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLG9CQUFvQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLGtCQUFrQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsOEJBQThCO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsYUFBYTtJQUNiO0lBQ0E7SUFDQSx1QkFBdUI7SUFDdkI7SUFDQSxjQUFjO0lBQ2Q7Q0FDRDtBQUVELE1BQU1DLGNBQWM7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsbUJBQW1CO0lBQ3ZCO0lBQ0E7SUFDQTtJQUNBO0lBRUE7SUFDQTtJQUVBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFD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TztnQkFDUGtDLFdBQVc7WUFDYjtZQUNBd0M7WUFDQSw2REFBNkQ7WUFDN0QsYUFBYTtZQUNiLGVBQWU7WUFDZjtnQkFDRTFFLE9BQU8sUUFBUU87Z0JBQ2YyQixXQUFXO1lBQ2I7WUFDQTtnQkFDRWxDLE9BQU87b0JBQUU7aUJBQTBCO2dCQUNuQ2dDLFdBQVc7b0JBQUUsR0FBRztnQkFBaUI7Z0JBQ2pDSyxVQUFVO29CQUFFcUI7aUJBQVE7WUFDdEI7WUFDQWM7WUFDQUo7WUFDQVQ7WUFDQWdCO1lBQ0E7Z0JBQ0UzRSxPQUFPLFNBQVMsc0ZBQXNGO1lBQ3hHO1NBQ0Q7SUFDSDtBQUNGO0FBRWlDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGVmcmFnbWVudGluZy1pZGVhcy8uL25vZGVfbW9kdWxlcy9oaWdobGlnaHQuanMvZXMvbGFuZ3VhZ2VzL2phdmFzY3JpcHQuanM/Y2MxOSJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBJREVOVF9SRSA9ICdbQS1aYS16JF9dWzAtOUEtWmEteiRfXSonO1xuY29uc3QgS0VZV09SRFMgPSBbXG4gIFwiYXNcIiwgLy8gZm9yIGV4cG9ydHNcbiAgXCJpblwiLFxuICBcIm9mXCIsXG4gIFwiaWZcIixcbiAgXCJmb3JcIixcbiAgXCJ3aGlsZVwiLFxuICBcImZpbmFsbHlcIixcbiAgXCJ2YXJcIixcbiAgXCJuZXdcIixcbiAgXCJmdW5jdGlvblwiLFxuICBcImRvXCIsXG4gIFwicmV0dXJuXCIsXG4gIFwidm9pZFwiLFxuICBcImVsc2VcIixcbiAgXCJicmVha1wiLFxuICBcImNhdGNoXCIsXG4gIFwiaW5zdGFuY2VvZlwiLFxuICBcIndpdGhcIixcbiAgXCJ0aHJvd1wiLFxuICBcImNhc2VcIixcbiAgXCJkZWZhdWx0XCIsXG4gIFwidHJ5XCIsXG4gIFwic3dpdGNoXCIsXG4gIFwiY29udGludWVcIixcbiAgXCJ0eXBlb2ZcIixcbiAgXCJkZWxldGVcIixcbiAgXCJsZXRcIixcbiAgXCJ5aWVsZFwiLFxuICBcImNvbnN0XCIsXG4gIFwiY2xhc3NcIixcbiAgLy8gSlMgaGFuZGxlcyB0aGVzZSB3aXRoIGEgc3BlY2lhbCBydWxlXG4gIC8vIFwiZ2V0XCIsXG4gIC8vIFwic2V0XCIsXG4gIFwiZGVidWdnZXJcIixcbiAgXCJhc3luY1wiLFxuICBcImF3YWl0XCIsXG4gIFwic3RhdGljXCIsXG4gIFwiaW1wb3J0XCIsXG4gIFwiZnJvbVwiLFxuICBcImV4cG9ydFwiLFxuICBcImV4dGVuZHNcIlxuXTtcbmNvbnN0IExJVEVSQUxTID0gW1xuICBcInRydWVcIixcbiAgXCJmYWxzZVwiLFxuICBcIm51bGxcIixcbiAgXCJ1bmRlZmluZWRcIixcbiAgXCJOYU5cIixcbiAgXCJJbmZpbml0eVwiXG5dO1xuXG4vLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0c1xuY29uc3QgVFlQRVMgPSBbXG4gIC8vIEZ1bmRhbWVudGFsIG9iamVjdHNcbiAgXCJPYmplY3RcIixcbiAgXCJGdW5jdGlvblwiLFxuICBcIkJvb2xlYW5cIixcbiAgXCJTeW1ib2xcIixcbiAgLy8gbnVtYmVycyBhbmQgZGF0ZXNcbiAgXCJNYXRoXCIsXG4gIFwiRGF0ZVwiLFxuICBcIk51bWJlclwiLFxuICBcIkJpZ0ludFwiLFxuICAvLyB0ZXh0XG4gIFwiU3RyaW5nXCIsXG4gIFwiUmVnRXhwXCIsXG4gIC8vIEluZGV4ZWQgY29sbGVjdGlvbnNcbiAgXCJBcnJheVwiLFxuICBcIkZsb2F0MzJBcnJheVwiLFxuICBcIkZsb2F0NjRBcnJheVwiLFxuICBcIkludDhBcnJheVwiLFxuICBcIlVpbnQ4QXJyYXlcIixcbiAgXCJVaW50OENsYW1wZWRBcnJheVwiLFxuICBcIkludDE2QXJyYXlcIixcbiAgXCJJbnQzMkFycmF5XCIsXG4gIFwiVWludDE2QXJyYXlcIixcbiAgXCJVaW50MzJBcnJheVwiLFxuICBcIkJpZ0ludDY0QXJyYXlcIixcbiAgXCJCaWdVaW50NjRBcnJheVwiLFxuICAvLyBLZXllZCBjb2xsZWN0aW9uc1xuICBcIlNldFwiLFxuICBcIk1hcFwiLFxuICBcIldlYWtTZXRcIixcbiAgXCJXZWFrTWFwXCIsXG4gIC8vIFN0cnVjdHVyZWQgZGF0YVxuICBcIkFycmF5QnVmZmVyXCIsXG4gIFwiU2hhcmVkQXJyYXlCdWZmZXJcIixcbiAgXCJBdG9taWNzXCIsXG4gIFwiRGF0YVZpZXdcIixcbiAgXCJKU09OXCIsXG4gIC8vIENvbnRyb2wgYWJzdHJhY3Rpb24gb2JqZWN0c1xuICBcIlByb21pc2VcIixcbiAgXCJHZW5lcmF0b3JcIixcbiAgXCJHZW5lcmF0b3JGdW5jdGlvblwiLFxuICBcIkFzeW5jRnVuY3Rpb25cIixcbiAgLy8gUmVmbGVjdGlvblxuICBcIlJlZmxlY3RcIixcbiAgXCJQcm94eVwiLFxuICAvLyBJbnRlcm5hdGlvbmFsaXphdGlvblxuICBcIkludGxcIixcbiAgLy8gV2ViQXNzZW1ibHlcbiAgXCJXZWJBc3NlbWJseVwiXG5dO1xuXG5jb25zdCBFUlJPUl9UWVBFUyA9IFtcbiAgXCJFcnJvclwiLFxuICBcIkV2YWxFcnJvclwiLFxuICBcIkludGVybmFsRXJyb3JcIixcbiAgXCJSYW5nZUVycm9yXCIsXG4gIFwiUmVmZXJlbmNlRXJyb3JcIixcbiAgXCJTeW50YXhFcnJvclwiLFxuICBcIlR5cGVFcnJvclwiLFxuICBcIlVSSUVycm9yXCJcbl07XG5cbmNvbnN0IEJVSUxUX0lOX0dMT0JBTFMgPSBbXG4gIFwic2V0SW50ZXJ2YWxcIixcbiAgXCJzZXRUaW1lb3V0XCIsXG4gIFwiY2xlYXJJbnRlcnZhbFwiLFxuICBcImNsZWFyVGltZW91dFwiLFxuXG4gIFwicmVxdWlyZVwiLFxuICBcImV4cG9ydHNcIixcblxuICBcImV2YWxcIixcbiAgXCJpc0Zpbml0ZVwiLFxuICBcImlzTmFOXCIsXG4gIFwicGFyc2VGbG9hdFwiLFxuICBcInBhcnNlSW50XCIsXG4gIFwiZGVjb2RlVVJJXCIsXG4gIFwiZGVjb2RlVVJJQ29tcG9uZW50XCIsXG4gIFwiZW5jb2RlVVJJXCIsXG4gIFwiZW5jb2RlVVJJQ29tcG9uZW50XCIsXG4gIFwiZXNjYXBlXCIsXG4gIFwidW5lc2NhcGVcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fVkFSSUFCTEVTID0gW1xuICBcImFyZ3VtZW50c1wiLFxuICBcInRoaXNcIixcbiAgXCJzdXBlclwiLFxuICBcImNvbnNvbGVcIixcbiAgXCJ3aW5kb3dcIixcbiAgXCJkb2N1bWVudFwiLFxuICBcImxvY2FsU3RvcmFnZVwiLFxuICBcInNlc3Npb25TdG9yYWdlXCIsXG4gIFwibW9kdWxlXCIsXG4gIFwiZ2xvYmFsXCIgLy8gTm9kZS5qc1xuXTtcblxuY29uc3QgQlVJTFRfSU5TID0gW10uY29uY2F0KFxuICBCVUlMVF9JTl9HTE9CQUxTLFxuICBUWVBFUyxcbiAgRVJST1JfVFlQRVNcbik7XG5cbi8qXG5MYW5ndWFnZTogSmF2YVNjcmlwdFxuRGVzY3JpcHRpb246IEphdmFTY3JpcHQgKEpTKSBpcyBhIGxpZ2h0d2VpZ2h0LCBpbnRlcnByZXRlZCwgb3IganVzdC1pbi10aW1lIGNvbXBpbGVkIHByb2dyYW1taW5nIGxhbmd1YWdlIHdpdGggZmlyc3QtY2xhc3MgZnVuY3Rpb25zLlxuQ2F0ZWdvcnk6IGNvbW1vbiwgc2NyaXB0aW5nLCB3ZWJcbldlYnNpdGU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHRcbiovXG5cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIGphdmFzY3JpcHQoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIC8qKlxuICAgKiBUYWtlcyBhIHN0cmluZyBsaWtlIFwiPEJvb2dlclwiIGFuZCBjaGVja3MgdG8gc2VlXG4gICAqIGlmIHdlIGNhbiBmaW5kIGEgbWF0Y2hpbmcgXCI8L0Jvb2dlclwiIGxhdGVyIGluIHRoZVxuICAgKiBjb250ZW50LlxuICAgKiBAcGFyYW0ge1JlZ0V4cE1hdGNoQXJyYXl9IG1hdGNoXG4gICAqIEBwYXJhbSB7e2FmdGVyOm51bWJlcn19IHBhcmFtMVxuICAgKi9cbiAgY29uc3QgaGFzQ2xvc2luZ1RhZyA9IChtYXRjaCwgeyBhZnRlciB9KSA9PiB7XG4gICAgY29uc3QgdGFnID0gXCI8L1wiICsgbWF0Y2hbMF0uc2xpY2UoMSk7XG4gICAgY29uc3QgcG9zID0gbWF0Y2guaW5wdXQuaW5kZXhPZih0YWcsIGFmdGVyKTtcbiAgICByZXR1cm4gcG9zICE9PSAtMTtcbiAgfTtcblxuICBjb25zdCBJREVOVF9SRSQxID0gSURFTlRfUkU7XG4gIGNvbnN0IEZSQUdNRU5UID0ge1xuICAgIGJlZ2luOiAnPD4nLFxuICAgIGVuZDogJzwvPidcbiAgfTtcbiAgLy8gdG8gYXZvaWQgc29tZSBzcGVjaWFsIGNhc2VzIGluc2lkZSBpc1RydWx5T3BlbmluZ1RhZ1xuICBjb25zdCBYTUxfU0VMRl9DTE9TSU5HID0gLzxbQS1aYS16MC05XFxcXC5fOi1dK1xccypcXC8+LztcbiAgY29uc3QgWE1MX1RBRyA9IHtcbiAgICBiZWdpbjogLzxbQS1aYS16MC05XFxcXC5fOi1dKy8sXG4gICAgZW5kOiAvXFwvW0EtWmEtejAtOVxcXFwuXzotXSs+fFxcLz4vLFxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICAgKiBAcGFyYW0ge0NhbGxiYWNrUmVzcG9uc2V9IHJlc3BvbnNlXG4gICAgICovXG4gICAgaXNUcnVseU9wZW5pbmdUYWc6IChtYXRjaCwgcmVzcG9uc2UpID0+IHtcbiAgICAgIGNvbnN0IGFmdGVyTWF0Y2hJbmRleCA9IG1hdGNoWzBdLmxlbmd0aCArIG1hdGNoLmluZGV4O1xuICAgICAgY29uc3QgbmV4dENoYXIgPSBtYXRjaC5pbnB1dFthZnRlck1hdGNoSW5kZXhdO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBIVE1MIHNob3VsZCBub3QgaW5jbHVkZSBhbm90aGVyIHJhdyBgPGAgaW5zaWRlIGEgdGFnXG4gICAgICAgIC8vIG5lc3RlZCB0eXBlP1xuICAgICAgICAvLyBgPEFycmF5PEFycmF5PG51bWJlcj4+YCwgZXRjLlxuICAgICAgICBuZXh0Q2hhciA9PT0gXCI8XCIgfHxcbiAgICAgICAgLy8gdGhlICwgZ2l2ZXMgYXdheSB0aGF0IHRoaXMgaXMgbm90IEhUTUxcbiAgICAgICAgLy8gYDxULCBBIGV4dGVuZHMga2V5b2YgVCwgVj5gXG4gICAgICAgIG5leHRDaGFyID09PSBcIixcIlxuICAgICAgICApIHtcbiAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBgPHNvbWV0aGluZz5gXG4gICAgICAvLyBRdWl0ZSBwb3NzaWJseSBhIHRhZywgbGV0cyBsb29rIGZvciBhIG1hdGNoaW5nIGNsb3NpbmcgdGFnLi4uXG4gICAgICBpZiAobmV4dENoYXIgPT09IFwiPlwiKSB7XG4gICAgICAgIC8vIGlmIHdlIGNhbm5vdCBmaW5kIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcsIHRoZW4gd2VcbiAgICAgICAgLy8gd2lsbCBpZ25vcmUgaXRcbiAgICAgICAgaWYgKCFoYXNDbG9zaW5nVGFnKG1hdGNoLCB7IGFmdGVyOiBhZnRlck1hdGNoSW5kZXggfSkpIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGA8YmxhaCAvPmAgKHNlbGYtY2xvc2luZylcbiAgICAgIC8vIGhhbmRsZWQgYnkgc2ltcGxlU2VsZkNsb3NpbmcgcnVsZVxuXG4gICAgICBsZXQgbTtcbiAgICAgIGNvbnN0IGFmdGVyTWF0Y2ggPSBtYXRjaC5pbnB1dC5zdWJzdHJpbmcoYWZ0ZXJNYXRjaEluZGV4KTtcblxuICAgICAgLy8gc29tZSBtb3JlIHRlbXBsYXRlIHR5cGluZyBzdHVmZlxuICAgICAgLy8gIDxUID0gYW55PihrZXk/OiBzdHJpbmcpID0+IE1vZGlmeTxcbiAgICAgIGlmICgobSA9IGFmdGVyTWF0Y2gubWF0Y2goL15cXHMqPS8pKSkge1xuICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGA8RnJvbSBleHRlbmRzIHN0cmluZz5gXG4gICAgICAvLyB0ZWNobmljYWxseSB0aGlzIGNvdWxkIGJlIEhUTUwsIGJ1dCBpdCBzbWVsbHMgbGlrZSBhIHR5cGVcbiAgICAgIC8vIE5PVEU6IFRoaXMgaXMgdWdoLCBidXQgYWRkZWQgc3BlY2lmaWNhbGx5IGZvciBodHRwczovL2dpdGh1Yi5jb20vaGlnaGxpZ2h0anMvaGlnaGxpZ2h0LmpzL2lzc3Vlcy8zMjc2XG4gICAgICBpZiAoKG0gPSBhZnRlck1hdGNoLm1hdGNoKC9eXFxzK2V4dGVuZHNcXHMrLykpKSB7XG4gICAgICAgIGlmIChtLmluZGV4ID09PSAwKSB7XG4gICAgICAgICAgcmVzcG9uc2UuaWdub3JlTWF0Y2goKTtcbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdXNlbGVzcy1yZXR1cm5cbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIGNvbnN0IEtFWVdPUkRTJDEgPSB7XG4gICAgJHBhdHRlcm46IElERU5UX1JFLFxuICAgIGtleXdvcmQ6IEtFWVdPUkRTLFxuICAgIGxpdGVyYWw6IExJVEVSQUxTLFxuICAgIGJ1aWx0X2luOiBCVUlMVF9JTlMsXG4gICAgXCJ2YXJpYWJsZS5sYW5ndWFnZVwiOiBCVUlMVF9JTl9WQVJJQUJMRVNcbiAgfTtcblxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWxpdGVyYWxzLW51bWVyaWMtbGl0ZXJhbHNcbiAgY29uc3QgZGVjaW1hbERpZ2l0cyA9ICdbMC05XShfP1swLTldKSonO1xuICBjb25zdCBmcmFjID0gYFxcXFwuKCR7ZGVjaW1hbERpZ2l0c30pYDtcbiAgLy8gRGVjaW1hbEludGVnZXJMaXRlcmFsLCBpbmNsdWRpbmcgQW5uZXggQiBOb25PY3RhbERlY2ltYWxJbnRlZ2VyTGl0ZXJhbFxuICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkZGl0aW9uYWwtc3ludGF4LW51bWVyaWMtbGl0ZXJhbHNcbiAgY29uc3QgZGVjaW1hbEludGVnZXIgPSBgMHxbMS05XShfP1swLTldKSp8MFswLTddKls4OV1bMC05XSpgO1xuICBjb25zdCBOVU1CRVIgPSB7XG4gICAgY2xhc3NOYW1lOiAnbnVtYmVyJyxcbiAgICB2YXJpYW50czogW1xuICAgICAgLy8gRGVjaW1hbExpdGVyYWxcbiAgICAgIHsgYmVnaW46IGAoXFxcXGIoJHtkZWNpbWFsSW50ZWdlcn0pKCgke2ZyYWN9KXxcXFxcLik/fCgke2ZyYWN9KSlgICtcbiAgICAgICAgYFtlRV1bKy1dPygke2RlY2ltYWxEaWdpdHN9KVxcXFxiYCB9LFxuICAgICAgeyBiZWdpbjogYFxcXFxiKCR7ZGVjaW1hbEludGVnZXJ9KVxcXFxiKCgke2ZyYWN9KVxcXFxifFxcXFwuKT98KCR7ZnJhY30pXFxcXGJgIH0sXG5cbiAgICAgIC8vIERlY2ltYWxCaWdJbnRlZ2VyTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogYFxcXFxiKDB8WzEtOV0oXz9bMC05XSkqKW5cXFxcYmAgfSxcblxuICAgICAgLy8gTm9uRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFt4WF1bMC05YS1mQS1GXShfP1swLTlhLWZBLUZdKSpuP1xcXFxiXCIgfSxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW2JCXVswLTFdKF8/WzAtMV0pKm4/XFxcXGJcIiB9LFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbb09dWzAtN10oXz9bMC03XSkqbj9cXFxcYlwiIH0sXG5cbiAgICAgIC8vIExlZ2FjeU9jdGFsSW50ZWdlckxpdGVyYWwgKGRvZXMgbm90IGluY2x1ZGUgdW5kZXJzY29yZSBzZXBhcmF0b3JzKVxuICAgICAgLy8gaHR0cHM6Ly90YzM5LmVzL2VjbWEyNjIvI3NlYy1hZGRpdGlvbmFsLXN5bnRheC1udW1lcmljLWxpdGVyYWxzXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFswLTddK24/XFxcXGJcIiB9LFxuICAgIF0sXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgU1VCU1QgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3Vic3QnLFxuICAgIGJlZ2luOiAnXFxcXCRcXFxceycsXG4gICAgZW5kOiAnXFxcXH0nLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBbXSAvLyBkZWZpbmVkIGxhdGVyXG4gIH07XG4gIGNvbnN0IEhUTUxfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdodG1sYCcsXG4gICAgZW5kOiAnJyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZDogJ2AnLFxuICAgICAgcmV0dXJuRW5kOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgU1VCU1RcbiAgICAgIF0sXG4gICAgICBzdWJMYW5ndWFnZTogJ3htbCdcbiAgICB9XG4gIH07XG4gIGNvbnN0IENTU19URU1QTEFURSA9IHtcbiAgICBiZWdpbjogJ2Nzc2AnLFxuICAgIGVuZDogJycsXG4gICAgc3RhcnRzOiB7XG4gICAgICBlbmQ6ICdgJyxcbiAgICAgIHJldHVybkVuZDogZmFsc2UsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICAgIFNVQlNUXG4gICAgICBdLFxuICAgICAgc3ViTGFuZ3VhZ2U6ICdjc3MnXG4gICAgfVxuICB9O1xuICBjb25zdCBHUkFQSFFMX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnZ3FsYCcsXG4gICAgZW5kOiAnJyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZDogJ2AnLFxuICAgICAgcmV0dXJuRW5kOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgU1VCU1RcbiAgICAgIF0sXG4gICAgICBzdWJMYW5ndWFnZTogJ2dyYXBocWwnXG4gICAgfVxuICB9O1xuICBjb25zdCBURU1QTEFURV9TVFJJTkcgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICBiZWdpbjogJ2AnLFxuICAgIGVuZDogJ2AnLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLkJBQ0tTTEFTSF9FU0NBUEUsXG4gICAgICBTVUJTVFxuICAgIF1cbiAgfTtcbiAgY29uc3QgSlNET0NfQ09NTUVOVCA9IGhsanMuQ09NTUVOVChcbiAgICAvXFwvXFwqXFwqKD8hXFwvKS8sXG4gICAgJ1xcXFwqLycsXG4gICAge1xuICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAge1xuICAgICAgICAgIGJlZ2luOiAnKD89QFtBLVphLXpdKyknLFxuICAgICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICdkb2N0YWcnLFxuICAgICAgICAgICAgICBiZWdpbjogJ0BbQS1aYS16XSsnXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjbGFzc05hbWU6ICd0eXBlJyxcbiAgICAgICAgICAgICAgYmVnaW46ICdcXFxceycsXG4gICAgICAgICAgICAgIGVuZDogJ1xcXFx9JyxcbiAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3ZhcmlhYmxlJyxcbiAgICAgICAgICAgICAgYmVnaW46IElERU5UX1JFJDEgKyAnKD89XFxcXHMqKC0pfCQpJyxcbiAgICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZSxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gZWF0IHNwYWNlcyAobm90IG5ld2xpbmVzKSBzbyB3ZSBjYW4gZmluZFxuICAgICAgICAgICAgLy8gdHlwZXMgb3IgdmFyaWFibGVzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGJlZ2luOiAvKD89W15cXG5dKVxccy8sXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgXVxuICAgIH1cbiAgKTtcbiAgY29uc3QgQ09NTUVOVCA9IHtcbiAgICBjbGFzc05hbWU6IFwiY29tbWVudFwiLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICBKU0RPQ19DT01NRU5ULFxuICAgICAgaGxqcy5DX0JMT0NLX0NPTU1FTlRfTU9ERSxcbiAgICAgIGhsanMuQ19MSU5FX0NPTU1FTlRfTU9ERVxuICAgIF1cbiAgfTtcbiAgY29uc3QgU1VCU1RfSU5URVJOQUxTID0gW1xuICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICBobGpzLlFVT1RFX1NUUklOR19NT0RFLFxuICAgIEhUTUxfVEVNUExBVEUsXG4gICAgQ1NTX1RFTVBMQVRFLFxuICAgIEdSQVBIUUxfVEVNUExBVEUsXG4gICAgVEVNUExBVEVfU1RSSU5HLFxuICAgIC8vIFNraXAgbnVtYmVycyB3aGVuIHRoZXkgYXJlIHBhcnQgb2YgYSB2YXJpYWJsZSBuYW1lXG4gICAgeyBtYXRjaDogL1xcJFxcZCsvIH0sXG4gICAgTlVNQkVSLFxuICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWw6XG4gICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMyODhcbiAgICAvLyBobGpzLlJFR0VYUF9NT0RFXG4gIF07XG4gIFNVQlNULmNvbnRhaW5zID0gU1VCU1RfSU5URVJOQUxTXG4gICAgLmNvbmNhdCh7XG4gICAgICAvLyB3ZSBuZWVkIHRvIHBhaXIgdXAge30gaW5zaWRlIG91ciBzdWJzdCB0byBwcmV2ZW50XG4gICAgICAvLyBpdCBmcm9tIGVuZGluZyB0b28gZWFybHkgYnkgbWF0Y2hpbmcgYW5vdGhlciB9XG4gICAgICBiZWdpbjogL1xcey8sXG4gICAgICBlbmQ6IC9cXH0vLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1xuICAgICAgICBcInNlbGZcIlxuICAgICAgXS5jb25jYXQoU1VCU1RfSU5URVJOQUxTKVxuICAgIH0pO1xuICBjb25zdCBTVUJTVF9BTkRfQ09NTUVOVFMgPSBbXS5jb25jYXQoQ09NTUVOVCwgU1VCU1QuY29udGFpbnMpO1xuICBjb25zdCBQQVJBTVNfQ09OVEFJTlMgPSBTVUJTVF9BTkRfQ09NTUVOVFMuY29uY2F0KFtcbiAgICAvLyBlYXQgcmVjdXJzaXZlIHBhcmVucyBpbiBzdWIgZXhwcmVzc2lvbnNcbiAgICB7XG4gICAgICBiZWdpbjogL1xcKC8sXG4gICAgICBlbmQ6IC9cXCkvLFxuICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICBjb250YWluczogW1wic2VsZlwiXS5jb25jYXQoU1VCU1RfQU5EX0NPTU1FTlRTKVxuICAgIH1cbiAgXSk7XG4gIGNvbnN0IFBBUkFNUyA9IHtcbiAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgIGJlZ2luOiAvXFwoLyxcbiAgICBlbmQ6IC9cXCkvLFxuICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgfTtcblxuICAvLyBFUzYgY2xhc3Nlc1xuICBjb25zdCBDTEFTU19PUl9FWFRFTkRTID0ge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICAvLyBjbGFzcyBDYXIgZXh0ZW5kcyB2ZWhpY2xlXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2NsYXNzLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUkMSxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgL2V4dGVuZHMvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICByZWdleC5jb25jYXQoSURFTlRfUkUkMSwgXCIoXCIsIHJlZ2V4LmNvbmNhdCgvXFwuLywgSURFTlRfUkUkMSksIFwiKSpcIilcbiAgICAgICAgXSxcbiAgICAgICAgc2NvcGU6IHtcbiAgICAgICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgICAgICAzOiBcInRpdGxlLmNsYXNzXCIsXG4gICAgICAgICAgNTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgNzogXCJ0aXRsZS5jbGFzcy5pbmhlcml0ZWRcIlxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLy8gY2xhc3MgQ2FyXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2NsYXNzLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUkMVxuICAgICAgICBdLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgICAgIDM6IFwidGl0bGUuY2xhc3NcIlxuICAgICAgICB9XG4gICAgICB9LFxuXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IENMQVNTX1JFRkVSRU5DRSA9IHtcbiAgICByZWxldmFuY2U6IDAsXG4gICAgbWF0Y2g6XG4gICAgcmVnZXguZWl0aGVyKFxuICAgICAgLy8gSGFyZCBjb2RlZCBleGNlcHRpb25zXG4gICAgICAvXFxiSlNPTi8sXG4gICAgICAvLyBGbG9hdDMyQXJyYXksIE91dFRcbiAgICAgIC9cXGJbQS1aXVthLXpdKyhbQS1aXVthLXpdKnxcXGQpKi8sXG4gICAgICAvLyBDU1NGYWN0b3J5LCBDU1NGYWN0b3J5VFxuICAgICAgL1xcYltBLVpdezIsfShbQS1aXVthLXpdK3xcXGQpKyhbQS1aXVthLXpdKikqLyxcbiAgICAgIC8vIEZQcywgRlBzVFxuICAgICAgL1xcYltBLVpdezIsfVthLXpdKyhbQS1aXVthLXpdK3xcXGQpKihbQS1aXVthLXpdKikqLyxcbiAgICAgIC8vIFBcbiAgICAgIC8vIHNpbmdsZSBsZXR0ZXJzIGFyZSBub3QgaGlnaGxpZ2h0ZWRcbiAgICAgIC8vIEJMQUhcbiAgICAgIC8vIHRoaXMgd2lsbCBiZSBmbGFnZ2VkIGFzIGEgVVBQRVJfQ0FTRV9DT05TVEFOVCBpbnN0ZWFkXG4gICAgKSxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuY2xhc3NcIixcbiAgICBrZXl3b3Jkczoge1xuICAgICAgXzogW1xuICAgICAgICAvLyBzZSB3ZSBzdGlsbCBnZXQgcmVsZXZhbmNlIGNyZWRpdCBmb3IgSlMgbGlicmFyeSBjbGFzc2VzXG4gICAgICAgIC4uLlRZUEVTLFxuICAgICAgICAuLi5FUlJPUl9UWVBFU1xuICAgICAgXVxuICAgIH1cbiAgfTtcblxuICBjb25zdCBVU0VfU1RSSUNUID0ge1xuICAgIGxhYmVsOiBcInVzZV9zdHJpY3RcIixcbiAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICByZWxldmFuY2U6IDEwLFxuICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSAoc3RyaWN0fGFzbSlbJ1wiXS9cbiAgfTtcblxuICBjb25zdCBGVU5DVElPTl9ERUZJTklUSU9OID0ge1xuICAgIHZhcmlhbnRzOiBbXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiBbXG4gICAgICAgICAgL2Z1bmN0aW9uLyxcbiAgICAgICAgICAvXFxzKy8sXG4gICAgICAgICAgSURFTlRfUkUkMSxcbiAgICAgICAgICAvKD89XFxzKlxcKCkvXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBhbm9ueW1vdXMgZnVuY3Rpb25cbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMqKD89XFwoKS9cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgbGFiZWw6IFwiZnVuYy5kZWZcIixcbiAgICBjb250YWluczogWyBQQVJBTVMgXSxcbiAgICBpbGxlZ2FsOiAvJS9cbiAgfTtcblxuICBjb25zdCBVUFBFUl9DQVNFX0NPTlNUQU5UID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDogL1xcYltBLVpdW0EtWl8wLTldK1xcYi8sXG4gICAgY2xhc3NOYW1lOiBcInZhcmlhYmxlLmNvbnN0YW50XCJcbiAgfTtcblxuICBmdW5jdGlvbiBub25lT2YobGlzdCkge1xuICAgIHJldHVybiByZWdleC5jb25jYXQoXCIoPyFcIiwgbGlzdC5qb2luKFwifFwiKSwgXCIpXCIpO1xuICB9XG5cbiAgY29uc3QgRlVOQ1RJT05fQ0FMTCA9IHtcbiAgICBtYXRjaDogcmVnZXguY29uY2F0KFxuICAgICAgL1xcYi8sXG4gICAgICBub25lT2YoW1xuICAgICAgICAuLi5CVUlMVF9JTl9HTE9CQUxTLFxuICAgICAgICBcInN1cGVyXCIsXG4gICAgICAgIFwiaW1wb3J0XCJcbiAgICAgIF0pLFxuICAgICAgSURFTlRfUkUkMSwgcmVnZXgubG9va2FoZWFkKC9cXCgvKSksXG4gICAgY2xhc3NOYW1lOiBcInRpdGxlLmZ1bmN0aW9uXCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgUFJPUEVSVFlfQUNDRVNTID0ge1xuICAgIGJlZ2luOiByZWdleC5jb25jYXQoL1xcLi8sIHJlZ2V4Lmxvb2thaGVhZChcbiAgICAgIHJlZ2V4LmNvbmNhdChJREVOVF9SRSQxLCAvKD8hWzAtOUEtWmEteiRfKF0pLylcbiAgICApKSxcbiAgICBlbmQ6IElERU5UX1JFJDEsXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGtleXdvcmRzOiBcInByb3RvdHlwZVwiLFxuICAgIGNsYXNzTmFtZTogXCJwcm9wZXJ0eVwiLFxuICAgIHJlbGV2YW5jZTogMFxuICB9O1xuXG4gIGNvbnN0IEdFVFRFUl9PUl9TRVRURVIgPSB7XG4gICAgbWF0Y2g6IFtcbiAgICAgIC9nZXR8c2V0LyxcbiAgICAgIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsXG4gICAgICAvKD89XFwoKS9cbiAgICBdLFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAzOiBcInRpdGxlLmZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7IC8vIGVhdCB0byBhdm9pZCBlbXB0eSBwYXJhbXNcbiAgICAgICAgYmVnaW46IC9cXChcXCkvXG4gICAgICB9LFxuICAgICAgUEFSQU1TXG4gICAgXVxuICB9O1xuXG4gIGNvbnN0IEZVTkNfTEVBRF9JTl9SRSA9ICcoXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKihcXFxcKCcgK1xuICAgICdbXigpXSonICtcbiAgICAnXFxcXClbXigpXSopKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpfCcgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgKyAnKVxcXFxzKj0+JztcblxuICBjb25zdCBGVU5DVElPTl9WQVJJQUJMRSA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2NvbnN0fHZhcnxsZXQvLCAvXFxzKy8sXG4gICAgICBJREVOVF9SRSQxLCAvXFxzKi8sXG4gICAgICAvPVxccyovLFxuICAgICAgLyhhc3luY1xccyopPy8sIC8vIGFzeW5jIGlzIG9wdGlvbmFsXG4gICAgICByZWdleC5sb29rYWhlYWQoRlVOQ19MRUFEX0lOX1JFKVxuICAgIF0sXG4gICAga2V5d29yZHM6IFwiYXN5bmNcIixcbiAgICBjbGFzc05hbWU6IHtcbiAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgfSxcbiAgICBjb250YWluczogW1xuICAgICAgUEFSQU1TXG4gICAgXVxuICB9O1xuXG4gIHJldHVybiB7XG4gICAgbmFtZTogJ0phdmFTY3JpcHQnLFxuICAgIGFsaWFzZXM6IFsnanMnLCAnanN4JywgJ21qcycsICdjanMnXSxcbiAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAvLyB0aGlzIHdpbGwgYmUgZXh0ZW5kZWQgYnkgVHlwZVNjcmlwdFxuICAgIGV4cG9ydHM6IHsgUEFSQU1TX0NPTlRBSU5TLCBDTEFTU19SRUZFUkVOQ0UgfSxcbiAgICBpbGxlZ2FsOiAvIyg/IVskX0Etel0pLyxcbiAgICBjb250YWluczogW1xuICAgICAgaGxqcy5TSEVCQU5HKHtcbiAgICAgICAgbGFiZWw6IFwic2hlYmFuZ1wiLFxuICAgICAgICBiaW5hcnk6IFwibm9kZVwiLFxuICAgICAgICByZWxldmFuY2U6IDVcbiAgICAgIH0pLFxuICAgICAgVVNFX1NUUklDVCxcbiAgICAgIGhsanMuQVBPU19TVFJJTkdfTU9ERSxcbiAgICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgICBIVE1MX1RFTVBMQVRFLFxuICAgICAgQ1NTX1RFTVBMQVRFLFxuICAgICAgR1JBUEhRTF9URU1QTEFURSxcbiAgICAgIFRFTVBMQVRFX1NUUklORyxcbiAgICAgIENPTU1FTlQsXG4gICAgICAvLyBTa2lwIG51bWJlcnMgd2hlbiB0aGV5IGFyZSBwYXJ0IG9mIGEgdmFyaWFibGUgbmFtZVxuICAgICAgeyBtYXRjaDogL1xcJFxcZCsvIH0sXG4gICAgICBOVU1CRVIsXG4gICAgICBDTEFTU19SRUZFUkVOQ0UsXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArIHJlZ2V4Lmxvb2thaGVhZCgnOicpLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9WQVJJQUJMRSxcbiAgICAgIHsgLy8gXCJ2YWx1ZVwiIGNvbnRhaW5lclxuICAgICAgICBiZWdpbjogJygnICsgaGxqcy5SRV9TVEFSVEVSU19SRSArICd8XFxcXGIoY2FzZXxyZXR1cm58dGhyb3cpXFxcXGIpXFxcXHMqJyxcbiAgICAgICAga2V5d29yZHM6ICdyZXR1cm4gdGhyb3cgY2FzZScsXG4gICAgICAgIHJlbGV2YW5jZTogMCxcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBDT01NRU5ULFxuICAgICAgICAgIGhsanMuUkVHRVhQX01PREUsXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnZnVuY3Rpb24nLFxuICAgICAgICAgICAgLy8gd2UgaGF2ZSB0byBjb3VudCB0aGUgcGFyZW5zIHRvIG1ha2Ugc3VyZSB3ZSBhY3R1YWxseSBoYXZlIHRoZVxuICAgICAgICAgICAgLy8gY29ycmVjdCBib3VuZGluZyAoICkgYmVmb3JlIHRoZSA9Pi4gIFRoZXJlIGNvdWxkIGJlIGFueSBudW1iZXIgb2ZcbiAgICAgICAgICAgIC8vIHN1Yi1leHByZXNzaW9ucyBpbnNpZGUgYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgICAgIGJlZ2luOiBGVU5DX0xFQURfSU5fUkUsXG4gICAgICAgICAgICByZXR1cm5CZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgIGVuZDogJ1xcXFxzKj0+JyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBjbGFzc05hbWU6ICdwYXJhbXMnLFxuICAgICAgICAgICAgICAgIHZhcmlhbnRzOiBbXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUsXG4gICAgICAgICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgY2xhc3NOYW1lOiBudWxsLFxuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKFxccypcXCkvLFxuICAgICAgICAgICAgICAgICAgICBza2lwOiB0cnVlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBiZWdpbjogL1xcKC8sXG4gICAgICAgICAgICAgICAgICAgIGVuZDogL1xcKS8sXG4gICAgICAgICAgICAgICAgICAgIGV4Y2x1ZGVCZWdpbjogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUVuZDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBQQVJBTVNfQ09OVEFJTlNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gY291bGQgYmUgYSBjb21tYSBkZWxpbWl0ZWQgbGlzdCBvZiBwYXJhbXMgdG8gYSBmdW5jdGlvbiBjYWxsXG4gICAgICAgICAgICBiZWdpbjogLywvLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtYXRjaDogL1xccysvLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7IC8vIEpTWFxuICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgeyBiZWdpbjogRlJBR01FTlQuYmVnaW4sIGVuZDogRlJBR01FTlQuZW5kIH0sXG4gICAgICAgICAgICAgIHsgbWF0Y2g6IFhNTF9TRUxGX0NMT1NJTkcgfSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGJlZ2luOiBYTUxfVEFHLmJlZ2luLFxuICAgICAgICAgICAgICAgIC8vIHdlIGNhcmVmdWxseSBjaGVjayB0aGUgb3BlbmluZyB0YWcgdG8gc2VlIGlmIGl0IHRydWx5XG4gICAgICAgICAgICAgICAgLy8gaXMgYSB0YWcgYW5kIG5vdCBhIGZhbHNlIHBvc2l0aXZlXG4gICAgICAgICAgICAgICAgJ29uOmJlZ2luJzogWE1MX1RBRy5pc1RydWx5T3BlbmluZ1RhZyxcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzdWJMYW5ndWFnZTogJ3htbCcsXG4gICAgICAgICAgICBjb250YWluczogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgZW5kOiBYTUxfVEFHLmVuZCxcbiAgICAgICAgICAgICAgICBza2lwOiB0cnVlLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbJ3NlbGYnXVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX0RFRklOSVRJT04sXG4gICAgICB7XG4gICAgICAgIC8vIHByZXZlbnQgdGhpcyBmcm9tIGdldHRpbmcgc3dhbGxvd2VkIHVwIGJ5IGZ1bmN0aW9uXG4gICAgICAgIC8vIHNpbmNlIHRoZXkgYXBwZWFyIFwiZnVuY3Rpb24gbGlrZVwiXG4gICAgICAgIGJlZ2luS2V5d29yZHM6IFwid2hpbGUgaWYgc3dpdGNoIGNhdGNoIGZvclwiXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICAvLyB3ZSBoYXZlIHRvIGNvdW50IHRoZSBwYXJlbnMgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgdGhlIGNvcnJlY3RcbiAgICAgICAgLy8gYm91bmRpbmcgKCApLiAgVGhlcmUgY291bGQgYmUgYW55IG51bWJlciBvZiBzdWItZXhwcmVzc2lvbnMgaW5zaWRlXG4gICAgICAgIC8vIGFsc28gc3Vycm91bmRlZCBieSBwYXJlbnMuXG4gICAgICAgIGJlZ2luOiAnXFxcXGIoPyFmdW5jdGlvbiknICsgaGxqcy5VTkRFUlNDT1JFX0lERU5UX1JFICtcbiAgICAgICAgICAnXFxcXCgnICsgLy8gZmlyc3QgcGFyZW5zXG4gICAgICAgICAgJ1teKCldKihcXFxcKCcgK1xuICAgICAgICAgICAgJ1teKCldKihcXFxcKCcgK1xuICAgICAgICAgICAgICAnW14oKV0qJyArXG4gICAgICAgICAgICAnXFxcXClbXigpXSopKicgK1xuICAgICAgICAgICdcXFxcKVteKCldKikqJyArXG4gICAgICAgICAgJ1xcXFwpXFxcXHMqXFxcXHsnLCAvLyBlbmQgcGFyZW5zXG4gICAgICAgIHJldHVybkJlZ2luOnRydWUsXG4gICAgICAgIGxhYmVsOiBcImZ1bmMuZGVmXCIsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgUEFSQU1TLFxuICAgICAgICAgIGhsanMuaW5oZXJpdChobGpzLlRJVExFX01PREUsIHsgYmVnaW46IElERU5UX1JFJDEsIGNsYXNzTmFtZTogXCJ0aXRsZS5mdW5jdGlvblwiIH0pXG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBjYXRjaCAuLi4gc28gaXQgd29uJ3QgdHJpZ2dlciB0aGUgcHJvcGVydHkgcnVsZSBiZWxvd1xuICAgICAge1xuICAgICAgICBtYXRjaDogL1xcLlxcLlxcLi8sXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIFBST1BFUlRZX0FDQ0VTUyxcbiAgICAgIC8vIGhhY2s6IHByZXZlbnRzIGRldGVjdGlvbiBvZiBrZXl3b3JkcyBpbiBzb21lIGNpcmN1bXN0YW5jZXNcbiAgICAgIC8vIC5rZXl3b3JkKClcbiAgICAgIC8vICRrZXl3b3JkID0geFxuICAgICAge1xuICAgICAgICBtYXRjaDogJ1xcXFwkJyArIElERU5UX1JFJDEsXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFsgL1xcYmNvbnN0cnVjdG9yKD89XFxzKlxcKCkvIF0sXG4gICAgICAgIGNsYXNzTmFtZTogeyAxOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSxcbiAgICAgICAgY29udGFpbnM6IFsgUEFSQU1TIF1cbiAgICAgIH0sXG4gICAgICBGVU5DVElPTl9DQUxMLFxuICAgICAgVVBQRVJfQ0FTRV9DT05TVEFOVCxcbiAgICAgIENMQVNTX09SX0VYVEVORFMsXG4gICAgICBHRVRURVJfT1JfU0VUVEVSLFxuICAgICAge1xuICAgICAgICBtYXRjaDogL1xcJFsoLl0vIC8vIHJlbGV2YW5jZSBib29zdGVyIGZvciBhIHBhdHRlcm4gY29tbW9uIHRvIEpTIGxpYnM6IGAkKHNvbWV0aGluZylgIGFuZCBgJC5zb21ldGhpbmdgXG4gICAgICB9XG4gICAgXVxuICB9O1xufVxuXG5leHBvcnQgeyBqYXZhc2NyaXB0IGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJJREVOVF9SRSIsIktFWVdPUkRTIiwiTElURVJBTFMiLCJUWVBFUyIsIkVSUk9SX1RZUEVTIiwiQlVJTFRfSU5fR0xPQkFMUyIsIkJVSUxUX0lOX1ZBUklBQkxFUyIsIkJVSUxUX0lOUyIsImNvbmNhdCIsImphdmFzY3JpcHQiLCJobGpzIiwicmVnZXgiLCJoYXNDbG9zaW5nVGFnIiwibWF0Y2giLCJhZnRlciIsInRhZyIsInNsaWNlIiwicG9zIiwiaW5wdXQiLCJpbmRleE9mIiwiSURFTlRfUkUkMSIsIkZSQUdNRU5UIiwiYmVnaW4iLCJlbmQiLCJYTUxfU0VMRl9DTE9TSU5HIiwiWE1MX1RBRyIsImlzVHJ1bHlPcGVuaW5nVGFnIiwicmVzcG9uc2UiLCJhZnRlck1hdGNoSW5kZXgiLCJsZW5ndGgiLCJpbmRleCIsIm5leHRDaGFyIiwiaWdub3JlTWF0Y2giLCJtIiwiYWZ0ZXJNYXRjaCIsInN1YnN0cmluZyIsIktFWVdPUkRTJDEiLCIkcGF0dGVybiIsImtleXdvcmQiLCJsaXRlcmFsIiwiYnVpbHRfaW4iLCJkZWNpbWFsRGlnaXRzIiwiZnJhYyIsImRlY2ltYWxJbnRlZ2VyIiwiTlVNQkVSIiwiY2xhc3NOYW1lIiwidmFyaWFudHMiLCJyZWxldmFuY2UiLCJTVUJTVCIsImtleXdvcmRzIiwiY29udGFpbnMiLCJIVE1MX1RFTVBMQVRFIiwic3RhcnRzIiwicmV0dXJuRW5kIiwiQkFDS1NMQVNIX0VTQ0FQRSIsInN1Ykxhbmd1YWdlIiwiQ1NTX1RFTVBMQVRFIiwiR1JBUEhRTF9URU1QTEFURSIsIlRFTVBMQVRFX1NUUklORyIsIkpTRE9DX0NPTU1FTlQiLCJDT01NRU5UIiwiZXhjbHVkZUVuZCIsImV4Y2x1ZGVCZWdpbiIsImVuZHNQYXJlbnQiLCJDX0JMT0NLX0NPTU1FTlRfTU9ERSIsIkNfTElORV9DT01NRU5UX01PREUiLCJTVUJTVF9JTlRFUk5BTFMiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfU1RSSU5HX01PREUiLCJTVUJTVF9BTkRfQ09NTUVOVFMiLCJQQVJBTVNfQ09OVEFJTlMiLCJQQVJBTVMiLCJDTEFTU19PUl9FWFRFTkRTIiwic2NvcGUiLCJDTEFTU19SRUZFUkVOQ0UiLCJlaXRoZXIiLCJfIiwiVVNFX1NUUklDVCIsImxhYmVsIiwiRlVOQ1RJT05fREVGSU5JVElPTiIsImlsbGVnYWwiLCJVUFBFUl9DQVNFX0NPTlNUQU5UIiwibm9uZU9mIiwibGlzdCIsImpvaW4iLCJGVU5DVElPTl9DQUxMIiwibG9va2FoZWFkIiwiUFJPUEVSVFlfQUNDRVNTIiwiR0VUVEVSX09SX1NFVFRFUiIsIkZVTkNfTEVBRF9JTl9SRSIsIlVOREVSU0NPUkVfSURFTlRfUkUiLCJGVU5DVElPTl9WQVJJQUJMRSIsIm5hbWUiLCJhbGlhc2VzIiwiZXhwb3J0cyIsIlNIRUJBTkciLCJiaW5hcnkiLCJSRV9TVEFSVEVSU19SRSIsIlJFR0VYUF9NT0RFIiwicmV0dXJuQmVnaW4iLCJza2lwIiwiYmVnaW5LZXl3b3JkcyIsImluaGVyaXQiLCJUSVRMRV9NT0RFIiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/javascript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/typescript.js":
/*!**************************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/typescript.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ typescript)\n/* harmony export */ });\nconst IDENT_RE = \"[A-Za-z$_][0-9A-Za-z$_]*\";\nconst KEYWORDS = [\n    \"as\",\n    \"in\",\n    \"of\",\n    \"if\",\n    \"for\",\n    \"while\",\n    \"finally\",\n    \"var\",\n    \"new\",\n    \"function\",\n    \"do\",\n    \"return\",\n    \"void\",\n    \"else\",\n    \"break\",\n    \"catch\",\n    \"instanceof\",\n    \"with\",\n    \"throw\",\n    \"case\",\n    \"default\",\n    \"try\",\n    \"switch\",\n    \"continue\",\n    \"typeof\",\n    \"delete\",\n    \"let\",\n    \"yield\",\n    \"const\",\n    \"class\",\n    // JS handles these with a special rule\n    // \"get\",\n    // \"set\",\n    \"debugger\",\n    \"async\",\n    \"await\",\n    \"static\",\n    \"import\",\n    \"from\",\n    \"export\",\n    \"extends\"\n];\nconst LITERALS = [\n    \"true\",\n    \"false\",\n    \"null\",\n    \"undefined\",\n    \"NaN\",\n    \"Infinity\"\n];\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects\nconst TYPES = [\n    // Fundamental objects\n    \"Object\",\n    \"Function\",\n    \"Boolean\",\n    \"Symbol\",\n    // numbers and dates\n    \"Math\",\n    \"Date\",\n    \"Number\",\n    \"BigInt\",\n    // text\n    \"String\",\n    \"RegExp\",\n    // Indexed collections\n    \"Array\",\n    \"Float32Array\",\n    \"Float64Array\",\n    \"Int8Array\",\n    \"Uint8Array\",\n    \"Uint8ClampedArray\",\n    \"Int16Array\",\n    \"Int32Array\",\n    \"Uint16Array\",\n    \"Uint32Array\",\n    \"BigInt64Array\",\n    \"BigUint64Array\",\n    // Keyed collections\n    \"Set\",\n    \"Map\",\n    \"WeakSet\",\n    \"WeakMap\",\n    // Structured data\n    \"ArrayBuffer\",\n    \"SharedArrayBuffer\",\n    \"Atomics\",\n    \"DataView\",\n    \"JSON\",\n    // Control abstraction objects\n    \"Promise\",\n    \"Generator\",\n    \"GeneratorFunction\",\n    \"AsyncFunction\",\n    // Reflection\n    \"Reflect\",\n    \"Proxy\",\n    // Internationalization\n    \"Intl\",\n    // WebAssembly\n    \"WebAssembly\"\n];\nconst ERROR_TYPES = [\n    \"Error\",\n    \"EvalError\",\n    \"InternalError\",\n    \"RangeError\",\n    \"ReferenceError\",\n    \"SyntaxError\",\n    \"TypeError\",\n    \"URIError\"\n];\nconst BUILT_IN_GLOBALS = [\n    \"setInterval\",\n    \"setTimeout\",\n    \"clearInterval\",\n    \"clearTimeout\",\n    \"require\",\n    \"exports\",\n    \"eval\",\n    \"isFinite\",\n    \"isNaN\",\n    \"parseFloat\",\n    \"parseInt\",\n    \"decodeURI\",\n    \"decodeURIComponent\",\n    \"encodeURI\",\n    \"encodeURIComponent\",\n    \"escape\",\n    \"unescape\"\n];\nconst BUILT_IN_VARIABLES = [\n    \"arguments\",\n    \"this\",\n    \"super\",\n    \"console\",\n    \"window\",\n    \"document\",\n    \"localStorage\",\n    \"sessionStorage\",\n    \"module\",\n    \"global\" // Node.js\n];\nconst BUILT_INS = [].concat(BUILT_IN_GLOBALS, TYPES, ERROR_TYPES);\n/*\nLanguage: JavaScript\nDescription: JavaScript (JS) is a lightweight, interpreted, or just-in-time compiled programming language with first-class functions.\nCategory: common, scripting, web\nWebsite: https://developer.mozilla.org/en-US/docs/Web/JavaScript\n*/ /** @type LanguageFn */ function javascript(hljs) {\n    const regex = hljs.regex;\n    /**\n   * Takes a string like \"<Booger\" and checks to see\n   * if we can find a matching \"</Booger\" later in the\n   * content.\n   * @param {RegExpMatchArray} match\n   * @param {{after:number}} param1\n   */ const hasClosingTag = (match, { after })=>{\n        const tag = \"</\" + match[0].slice(1);\n        const pos = match.input.indexOf(tag, after);\n        return pos !== -1;\n    };\n    const IDENT_RE$1 = IDENT_RE;\n    const FRAGMENT = {\n        begin: \"<>\",\n        end: \"</>\"\n    };\n    // to avoid some special cases inside isTrulyOpeningTag\n    const XML_SELF_CLOSING = /<[A-Za-z0-9\\\\._:-]+\\s*\\/>/;\n    const XML_TAG = {\n        begin: /<[A-Za-z0-9\\\\._:-]+/,\n        end: /\\/[A-Za-z0-9\\\\._:-]+>|\\/>/,\n        /**\n     * @param {RegExpMatchArray} match\n     * @param {CallbackResponse} response\n     */ isTrulyOpeningTag: (match, response)=>{\n            const afterMatchIndex = match[0].length + match.index;\n            const nextChar = match.input[afterMatchIndex];\n            if (// HTML should not include another raw `<` inside a tag\n            // nested type?\n            // `<Array<Array<number>>`, etc.\n            nextChar === \"<\" || // the , gives away that this is not HTML\n            // `<T, A extends keyof T, V>`\n            nextChar === \",\") {\n                response.ignoreMatch();\n                return;\n            }\n            // `<something>`\n            // Quite possibly a tag, lets look for a matching closing tag...\n            if (nextChar === \">\") {\n                // if we cannot find a matching closing tag, then we\n                // will ignore it\n                if (!hasClosingTag(match, {\n                    after: afterMatchIndex\n                })) {\n                    response.ignoreMatch();\n                }\n            }\n            // `<blah />` (self-closing)\n            // handled by simpleSelfClosing rule\n            let m;\n            const afterMatch = match.input.substring(afterMatchIndex);\n            // some more template typing stuff\n            //  <T = any>(key?: string) => Modify<\n            if (m = afterMatch.match(/^\\s*=/)) {\n                response.ignoreMatch();\n                return;\n            }\n            // `<From extends string>`\n            // technically this could be HTML, but it smells like a type\n            // NOTE: This is ugh, but added specifically for https://github.com/highlightjs/highlight.js/issues/3276\n            if (m = afterMatch.match(/^\\s+extends\\s+/)) {\n                if (m.index === 0) {\n                    response.ignoreMatch();\n                    // eslint-disable-next-line no-useless-return\n                    return;\n                }\n            }\n        }\n    };\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS,\n        literal: LITERALS,\n        built_in: BUILT_INS,\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    // https://tc39.es/ecma262/#sec-literals-numeric-literals\n    const decimalDigits = \"[0-9](_?[0-9])*\";\n    const frac = `\\\\.(${decimalDigits})`;\n    // DecimalIntegerLiteral, including Annex B NonOctalDecimalIntegerLiteral\n    // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n    const decimalInteger = `0|[1-9](_?[0-9])*|0[0-7]*[89][0-9]*`;\n    const NUMBER = {\n        className: \"number\",\n        variants: [\n            // DecimalLiteral\n            {\n                begin: `(\\\\b(${decimalInteger})((${frac})|\\\\.)?|(${frac}))` + `[eE][+-]?(${decimalDigits})\\\\b`\n            },\n            {\n                begin: `\\\\b(${decimalInteger})\\\\b((${frac})\\\\b|\\\\.)?|(${frac})\\\\b`\n            },\n            // DecimalBigIntegerLiteral\n            {\n                begin: `\\\\b(0|[1-9](_?[0-9])*)n\\\\b`\n            },\n            // NonDecimalIntegerLiteral\n            {\n                begin: \"\\\\b0[xX][0-9a-fA-F](_?[0-9a-fA-F])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[bB][0-1](_?[0-1])*n?\\\\b\"\n            },\n            {\n                begin: \"\\\\b0[oO][0-7](_?[0-7])*n?\\\\b\"\n            },\n            // LegacyOctalIntegerLiteral (does not include underscore separators)\n            // https://tc39.es/ecma262/#sec-additional-syntax-numeric-literals\n            {\n                begin: \"\\\\b0[0-7]+n?\\\\b\"\n            }\n        ],\n        relevance: 0\n    };\n    const SUBST = {\n        className: \"subst\",\n        begin: \"\\\\$\\\\{\",\n        end: \"\\\\}\",\n        keywords: KEYWORDS$1,\n        contains: [] // defined later\n    };\n    const HTML_TEMPLATE = {\n        begin: \"html`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"xml\"\n        }\n    };\n    const CSS_TEMPLATE = {\n        begin: \"css`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"css\"\n        }\n    };\n    const GRAPHQL_TEMPLATE = {\n        begin: \"gql`\",\n        end: \"\",\n        starts: {\n            end: \"`\",\n            returnEnd: false,\n            contains: [\n                hljs.BACKSLASH_ESCAPE,\n                SUBST\n            ],\n            subLanguage: \"graphql\"\n        }\n    };\n    const TEMPLATE_STRING = {\n        className: \"string\",\n        begin: \"`\",\n        end: \"`\",\n        contains: [\n            hljs.BACKSLASH_ESCAPE,\n            SUBST\n        ]\n    };\n    const JSDOC_COMMENT = hljs.COMMENT(/\\/\\*\\*(?!\\/)/, \"\\\\*/\", {\n        relevance: 0,\n        contains: [\n            {\n                begin: \"(?=@[A-Za-z]+)\",\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"doctag\",\n                        begin: \"@[A-Za-z]+\"\n                    },\n                    {\n                        className: \"type\",\n                        begin: \"\\\\{\",\n                        end: \"\\\\}\",\n                        excludeEnd: true,\n                        excludeBegin: true,\n                        relevance: 0\n                    },\n                    {\n                        className: \"variable\",\n                        begin: IDENT_RE$1 + \"(?=\\\\s*(-)|$)\",\n                        endsParent: true,\n                        relevance: 0\n                    },\n                    // eat spaces (not newlines) so we can find\n                    // types or variables\n                    {\n                        begin: /(?=[^\\n])\\s/,\n                        relevance: 0\n                    }\n                ]\n            }\n        ]\n    });\n    const COMMENT = {\n        className: \"comment\",\n        variants: [\n            JSDOC_COMMENT,\n            hljs.C_BLOCK_COMMENT_MODE,\n            hljs.C_LINE_COMMENT_MODE\n        ]\n    };\n    const SUBST_INTERNALS = [\n        hljs.APOS_STRING_MODE,\n        hljs.QUOTE_STRING_MODE,\n        HTML_TEMPLATE,\n        CSS_TEMPLATE,\n        GRAPHQL_TEMPLATE,\n        TEMPLATE_STRING,\n        // Skip numbers when they are part of a variable name\n        {\n            match: /\\$\\d+/\n        },\n        NUMBER\n    ];\n    SUBST.contains = SUBST_INTERNALS.concat({\n        // we need to pair up {} inside our subst to prevent\n        // it from ending too early by matching another }\n        begin: /\\{/,\n        end: /\\}/,\n        keywords: KEYWORDS$1,\n        contains: [\n            \"self\"\n        ].concat(SUBST_INTERNALS)\n    });\n    const SUBST_AND_COMMENTS = [].concat(COMMENT, SUBST.contains);\n    const PARAMS_CONTAINS = SUBST_AND_COMMENTS.concat([\n        // eat recursive parens in sub expressions\n        {\n            begin: /\\(/,\n            end: /\\)/,\n            keywords: KEYWORDS$1,\n            contains: [\n                \"self\"\n            ].concat(SUBST_AND_COMMENTS)\n        }\n    ]);\n    const PARAMS = {\n        className: \"params\",\n        begin: /\\(/,\n        end: /\\)/,\n        excludeBegin: true,\n        excludeEnd: true,\n        keywords: KEYWORDS$1,\n        contains: PARAMS_CONTAINS\n    };\n    // ES6 classes\n    const CLASS_OR_EXTENDS = {\n        variants: [\n            // class Car extends vehicle\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /\\s+/,\n                    /extends/,\n                    /\\s+/,\n                    regex.concat(IDENT_RE$1, \"(\", regex.concat(/\\./, IDENT_RE$1), \")*\")\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\",\n                    5: \"keyword\",\n                    7: \"title.class.inherited\"\n                }\n            },\n            // class Car\n            {\n                match: [\n                    /class/,\n                    /\\s+/,\n                    IDENT_RE$1\n                ],\n                scope: {\n                    1: \"keyword\",\n                    3: \"title.class\"\n                }\n            }\n        ]\n    };\n    const CLASS_REFERENCE = {\n        relevance: 0,\n        match: regex.either(// Hard coded exceptions\n        /\\bJSON/, // Float32Array, OutT\n        /\\b[A-Z][a-z]+([A-Z][a-z]*|\\d)*/, // CSSFactory, CSSFactoryT\n        /\\b[A-Z]{2,}([A-Z][a-z]+|\\d)+([A-Z][a-z]*)*/, // FPs, FPsT\n        /\\b[A-Z]{2,}[a-z]+([A-Z][a-z]+|\\d)*([A-Z][a-z]*)*/),\n        className: \"title.class\",\n        keywords: {\n            _: [\n                // se we still get relevance credit for JS library classes\n                ...TYPES,\n                ...ERROR_TYPES\n            ]\n        }\n    };\n    const USE_STRICT = {\n        label: \"use_strict\",\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use (strict|asm)['\"]/\n    };\n    const FUNCTION_DEFINITION = {\n        variants: [\n            {\n                match: [\n                    /function/,\n                    /\\s+/,\n                    IDENT_RE$1,\n                    /(?=\\s*\\()/\n                ]\n            },\n            // anonymous function\n            {\n                match: [\n                    /function/,\n                    /\\s*(?=\\()/\n                ]\n            }\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        label: \"func.def\",\n        contains: [\n            PARAMS\n        ],\n        illegal: /%/\n    };\n    const UPPER_CASE_CONSTANT = {\n        relevance: 0,\n        match: /\\b[A-Z][A-Z_0-9]+\\b/,\n        className: \"variable.constant\"\n    };\n    function noneOf(list) {\n        return regex.concat(\"(?!\", list.join(\"|\"), \")\");\n    }\n    const FUNCTION_CALL = {\n        match: regex.concat(/\\b/, noneOf([\n            ...BUILT_IN_GLOBALS,\n            \"super\",\n            \"import\"\n        ]), IDENT_RE$1, regex.lookahead(/\\(/)),\n        className: \"title.function\",\n        relevance: 0\n    };\n    const PROPERTY_ACCESS = {\n        begin: regex.concat(/\\./, regex.lookahead(regex.concat(IDENT_RE$1, /(?![0-9A-Za-z$_(])/))),\n        end: IDENT_RE$1,\n        excludeBegin: true,\n        keywords: \"prototype\",\n        className: \"property\",\n        relevance: 0\n    };\n    const GETTER_OR_SETTER = {\n        match: [\n            /get|set/,\n            /\\s+/,\n            IDENT_RE$1,\n            /(?=\\()/\n        ],\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            {\n                begin: /\\(\\)/\n            },\n            PARAMS\n        ]\n    };\n    const FUNC_LEAD_IN_RE = \"(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)|\" + hljs.UNDERSCORE_IDENT_RE + \")\\\\s*=>\";\n    const FUNCTION_VARIABLE = {\n        match: [\n            /const|var|let/,\n            /\\s+/,\n            IDENT_RE$1,\n            /\\s*/,\n            /=\\s*/,\n            /(async\\s*)?/,\n            regex.lookahead(FUNC_LEAD_IN_RE)\n        ],\n        keywords: \"async\",\n        className: {\n            1: \"keyword\",\n            3: \"title.function\"\n        },\n        contains: [\n            PARAMS\n        ]\n    };\n    return {\n        name: \"JavaScript\",\n        aliases: [\n            \"js\",\n            \"jsx\",\n            \"mjs\",\n            \"cjs\"\n        ],\n        keywords: KEYWORDS$1,\n        // this will be extended by TypeScript\n        exports: {\n            PARAMS_CONTAINS,\n            CLASS_REFERENCE\n        },\n        illegal: /#(?![$_A-z])/,\n        contains: [\n            hljs.SHEBANG({\n                label: \"shebang\",\n                binary: \"node\",\n                relevance: 5\n            }),\n            USE_STRICT,\n            hljs.APOS_STRING_MODE,\n            hljs.QUOTE_STRING_MODE,\n            HTML_TEMPLATE,\n            CSS_TEMPLATE,\n            GRAPHQL_TEMPLATE,\n            TEMPLATE_STRING,\n            COMMENT,\n            // Skip numbers when they are part of a variable name\n            {\n                match: /\\$\\d+/\n            },\n            NUMBER,\n            CLASS_REFERENCE,\n            {\n                className: \"attr\",\n                begin: IDENT_RE$1 + regex.lookahead(\":\"),\n                relevance: 0\n            },\n            FUNCTION_VARIABLE,\n            {\n                begin: \"(\" + hljs.RE_STARTERS_RE + \"|\\\\b(case|return|throw)\\\\b)\\\\s*\",\n                keywords: \"return throw case\",\n                relevance: 0,\n                contains: [\n                    COMMENT,\n                    hljs.REGEXP_MODE,\n                    {\n                        className: \"function\",\n                        // we have to count the parens to make sure we actually have the\n                        // correct bounding ( ) before the =>.  There could be any number of\n                        // sub-expressions inside also surrounded by parens.\n                        begin: FUNC_LEAD_IN_RE,\n                        returnBegin: true,\n                        end: \"\\\\s*=>\",\n                        contains: [\n                            {\n                                className: \"params\",\n                                variants: [\n                                    {\n                                        begin: hljs.UNDERSCORE_IDENT_RE,\n                                        relevance: 0\n                                    },\n                                    {\n                                        className: null,\n                                        begin: /\\(\\s*\\)/,\n                                        skip: true\n                                    },\n                                    {\n                                        begin: /\\(/,\n                                        end: /\\)/,\n                                        excludeBegin: true,\n                                        excludeEnd: true,\n                                        keywords: KEYWORDS$1,\n                                        contains: PARAMS_CONTAINS\n                                    }\n                                ]\n                            }\n                        ]\n                    },\n                    {\n                        begin: /,/,\n                        relevance: 0\n                    },\n                    {\n                        match: /\\s+/,\n                        relevance: 0\n                    },\n                    {\n                        variants: [\n                            {\n                                begin: FRAGMENT.begin,\n                                end: FRAGMENT.end\n                            },\n                            {\n                                match: XML_SELF_CLOSING\n                            },\n                            {\n                                begin: XML_TAG.begin,\n                                // we carefully check the opening tag to see if it truly\n                                // is a tag and not a false positive\n                                \"on:begin\": XML_TAG.isTrulyOpeningTag,\n                                end: XML_TAG.end\n                            }\n                        ],\n                        subLanguage: \"xml\",\n                        contains: [\n                            {\n                                begin: XML_TAG.begin,\n                                end: XML_TAG.end,\n                                skip: true,\n                                contains: [\n                                    \"self\"\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            FUNCTION_DEFINITION,\n            {\n                // prevent this from getting swallowed up by function\n                // since they appear \"function like\"\n                beginKeywords: \"while if switch catch for\"\n            },\n            {\n                // we have to count the parens to make sure we actually have the correct\n                // bounding ( ).  There could be any number of sub-expressions inside\n                // also surrounded by parens.\n                begin: \"\\\\b(?!function)\" + hljs.UNDERSCORE_IDENT_RE + \"\\\\(\" + // first parens\n                \"[^()]*(\\\\(\" + \"[^()]*(\\\\(\" + \"[^()]*\" + \"\\\\)[^()]*)*\" + \"\\\\)[^()]*)*\" + \"\\\\)\\\\s*\\\\{\",\n                returnBegin: true,\n                label: \"func.def\",\n                contains: [\n                    PARAMS,\n                    hljs.inherit(hljs.TITLE_MODE, {\n                        begin: IDENT_RE$1,\n                        className: \"title.function\"\n                    })\n                ]\n            },\n            // catch ... so it won't trigger the property rule below\n            {\n                match: /\\.\\.\\./,\n                relevance: 0\n            },\n            PROPERTY_ACCESS,\n            // hack: prevents detection of keywords in some circumstances\n            // .keyword()\n            // $keyword = x\n            {\n                match: \"\\\\$\" + IDENT_RE$1,\n                relevance: 0\n            },\n            {\n                match: [\n                    /\\bconstructor(?=\\s*\\()/\n                ],\n                className: {\n                    1: \"title.function\"\n                },\n                contains: [\n                    PARAMS\n                ]\n            },\n            FUNCTION_CALL,\n            UPPER_CASE_CONSTANT,\n            CLASS_OR_EXTENDS,\n            GETTER_OR_SETTER,\n            {\n                match: /\\$[(.]/ // relevance booster for a pattern common to JS libs: `$(something)` and `$.something`\n            }\n        ]\n    };\n}\n/*\nLanguage: TypeScript\nAuthor: Panu Horsmalahti <panu.horsmalahti@iki.fi>\nContributors: Ike Ku <dempfi@yahoo.com>\nDescription: TypeScript is a strict superset of JavaScript\nWebsite: https://www.typescriptlang.org\nCategory: common, scripting\n*/ /** @type LanguageFn */ function typescript(hljs) {\n    const tsLanguage = javascript(hljs);\n    const IDENT_RE$1 = IDENT_RE;\n    const TYPES = [\n        \"any\",\n        \"void\",\n        \"number\",\n        \"boolean\",\n        \"string\",\n        \"object\",\n        \"never\",\n        \"symbol\",\n        \"bigint\",\n        \"unknown\"\n    ];\n    const NAMESPACE = {\n        beginKeywords: \"namespace\",\n        end: /\\{/,\n        excludeEnd: true,\n        contains: [\n            tsLanguage.exports.CLASS_REFERENCE\n        ]\n    };\n    const INTERFACE = {\n        beginKeywords: \"interface\",\n        end: /\\{/,\n        excludeEnd: true,\n        keywords: {\n            keyword: \"interface extends\",\n            built_in: TYPES\n        },\n        contains: [\n            tsLanguage.exports.CLASS_REFERENCE\n        ]\n    };\n    const USE_STRICT = {\n        className: \"meta\",\n        relevance: 10,\n        begin: /^\\s*['\"]use strict['\"]/\n    };\n    const TS_SPECIFIC_KEYWORDS = [\n        \"type\",\n        \"namespace\",\n        \"interface\",\n        \"public\",\n        \"private\",\n        \"protected\",\n        \"implements\",\n        \"declare\",\n        \"abstract\",\n        \"readonly\",\n        \"enum\",\n        \"override\"\n    ];\n    const KEYWORDS$1 = {\n        $pattern: IDENT_RE,\n        keyword: KEYWORDS.concat(TS_SPECIFIC_KEYWORDS),\n        literal: LITERALS,\n        built_in: BUILT_INS.concat(TYPES),\n        \"variable.language\": BUILT_IN_VARIABLES\n    };\n    const DECORATOR = {\n        className: \"meta\",\n        begin: \"@\" + IDENT_RE$1\n    };\n    const swapMode = (mode, label, replacement)=>{\n        const indx = mode.contains.findIndex((m)=>m.label === label);\n        if (indx === -1) {\n            throw new Error(\"can not find mode to replace\");\n        }\n        mode.contains.splice(indx, 1, replacement);\n    };\n    // this should update anywhere keywords is used since\n    // it will be the same actual JS object\n    Object.assign(tsLanguage.keywords, KEYWORDS$1);\n    tsLanguage.exports.PARAMS_CONTAINS.push(DECORATOR);\n    tsLanguage.contains = tsLanguage.contains.concat([\n        DECORATOR,\n        NAMESPACE,\n        INTERFACE\n    ]);\n    // TS gets a simpler shebang rule than JS\n    swapMode(tsLanguage, \"shebang\", hljs.SHEBANG());\n    // JS use strict rule purposely excludes `asm` which makes no sense\n    swapMode(tsLanguage, \"use_strict\", USE_STRICT);\n    const functionDeclaration = tsLanguage.contains.find((m)=>m.label === \"func.def\");\n    functionDeclaration.relevance = 0; // () => {} is more typical in TypeScript\n    Object.assign(tsLanguage, {\n        name: \"TypeScript\",\n        aliases: [\n            \"ts\",\n            \"tsx\",\n            \"mts\",\n            \"cts\"\n        ]\n    });\n    return tsLanguage;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy90eXBlc2NyaXB0LmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQSxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7SUFDZjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQSx1Q0FBdUM7SUFDdkMsU0FBUztJQUNULFNBQVM7SUFDVDtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFDRCxNQUFNQyxXQUFXO0lBQ2Y7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFRCxtRkFBbUY7QUFDbkYsTUFBTUMsUUFBUTtJQUNaLHNCQUFzQjtJQUN0QjtJQUNBO0lBQ0E7SUFDQTtJQUNBLG9CQUFvQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLE9BQU87SUFDUDtJQUNBO0lBQ0Esc0JBQXNCO0lBQ3RCO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBLG9CQUFvQjtJQUNwQjtJQUNBO0lBQ0E7SUFDQTtJQUNBLGtCQUFrQjtJQUNsQjtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsOEJBQThCO0lBQzlCO0lBQ0E7SUFDQTtJQUNBO0lBQ0EsYUFBYTtJQUNiO0lBQ0E7SUFDQSx1QkFBdUI7SUFDdkI7SUFDQSxjQUFjO0lBQ2Q7Q0FDRDtBQUVELE1BQU1DLGNBQWM7SUFDbEI7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtDQUNEO0FBRUQsTUFBTUMsbUJBQW1CO0lBQ3ZCO0lBQ0E7SUFDQTtJQUNBO0lBRUE7SUFDQTtJQUVBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFD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ZV9tb2R1bGVzL2hpZ2hsaWdodC5qcy9lcy9sYW5ndWFnZXMvdHlwZXNjcmlwdC5qcz9kZDk4Il0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IElERU5UX1JFID0gJ1tBLVphLXokX11bMC05QS1aYS16JF9dKic7XG5jb25zdCBLRVlXT1JEUyA9IFtcbiAgXCJhc1wiLCAvLyBmb3IgZXhwb3J0c1xuICBcImluXCIsXG4gIFwib2ZcIixcbiAgXCJpZlwiLFxuICBcImZvclwiLFxuICBcIndoaWxlXCIsXG4gIFwiZmluYWxseVwiLFxuICBcInZhclwiLFxuICBcIm5ld1wiLFxuICBcImZ1bmN0aW9uXCIsXG4gIFwiZG9cIixcbiAgXCJyZXR1cm5cIixcbiAgXCJ2b2lkXCIsXG4gIFwiZWxzZVwiLFxuICBcImJyZWFrXCIsXG4gIFwiY2F0Y2hcIixcbiAgXCJpbnN0YW5jZW9mXCIsXG4gIFwid2l0aFwiLFxuICBcInRocm93XCIsXG4gIFwiY2FzZVwiLFxuICBcImRlZmF1bHRcIixcbiAgXCJ0cnlcIixcbiAgXCJzd2l0Y2hcIixcbiAgXCJjb250aW51ZVwiLFxuICBcInR5cGVvZlwiLFxuICBcImRlbGV0ZVwiLFxuICBcImxldFwiLFxuICBcInlpZWxkXCIsXG4gIFwiY29uc3RcIixcbiAgXCJjbGFzc1wiLFxuICAvLyBKUyBoYW5kbGVzIHRoZXNlIHdpdGggYSBzcGVjaWFsIHJ1bGVcbiAgLy8gXCJnZXRcIixcbiAgLy8gXCJzZXRcIixcbiAgXCJkZWJ1Z2dlclwiLFxuICBcImFzeW5jXCIsXG4gIFwiYXdhaXRcIixcbiAgXCJzdGF0aWNcIixcbiAgXCJpbXBvcnRcIixcbiAgXCJmcm9tXCIsXG4gIFwiZXhwb3J0XCIsXG4gIFwiZXh0ZW5kc1wiXG5dO1xuY29uc3QgTElURVJBTFMgPSBbXG4gIFwidHJ1ZVwiLFxuICBcImZhbHNlXCIsXG4gIFwibnVsbFwiLFxuICBcInVuZGVmaW5lZFwiLFxuICBcIk5hTlwiLFxuICBcIkluZmluaXR5XCJcbl07XG5cbi8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzXG5jb25zdCBUWVBFUyA9IFtcbiAgLy8gRnVuZGFtZW50YWwgb2JqZWN0c1xuICBcIk9iamVjdFwiLFxuICBcIkZ1bmN0aW9uXCIsXG4gIFwiQm9vbGVhblwiLFxuICBcIlN5bWJvbFwiLFxuICAvLyBudW1iZXJzIGFuZCBkYXRlc1xuICBcIk1hdGhcIixcbiAgXCJEYXRlXCIsXG4gIFwiTnVtYmVyXCIsXG4gIFwiQmlnSW50XCIsXG4gIC8vIHRleHRcbiAgXCJTdHJpbmdcIixcbiAgXCJSZWdFeHBcIixcbiAgLy8gSW5kZXhlZCBjb2xsZWN0aW9uc1xuICBcIkFycmF5XCIsXG4gIFwiRmxvYXQzMkFycmF5XCIsXG4gIFwiRmxvYXQ2NEFycmF5XCIsXG4gIFwiSW50OEFycmF5XCIsXG4gIFwiVWludDhBcnJheVwiLFxuICBcIlVpbnQ4Q2xhbXBlZEFycmF5XCIsXG4gIFwiSW50MTZBcnJheVwiLFxuICBcIkludDMyQXJyYXlcIixcbiAgXCJVaW50MTZBcnJheVwiLFxuICBcIlVpbnQzMkFycmF5XCIsXG4gIFwiQmlnSW50NjRBcnJheVwiLFxuICBcIkJpZ1VpbnQ2NEFycmF5XCIsXG4gIC8vIEtleWVkIGNvbGxlY3Rpb25zXG4gIFwiU2V0XCIsXG4gIFwiTWFwXCIsXG4gIFwiV2Vha1NldFwiLFxuICBcIldlYWtNYXBcIixcbiAgLy8gU3RydWN0dXJlZCBkYXRhXG4gIFwiQXJyYXlCdWZmZXJcIixcbiAgXCJTaGFyZWRBcnJheUJ1ZmZlclwiLFxuICBcIkF0b21pY3NcIixcbiAgXCJEYXRhVmlld1wiLFxuICBcIkpTT05cIixcbiAgLy8gQ29udHJvbCBhYnN0cmFjdGlvbiBvYmplY3RzXG4gIFwiUHJvbWlzZVwiLFxuICBcIkdlbmVyYXRvclwiLFxuICBcIkdlbmVyYXRvckZ1bmN0aW9uXCIsXG4gIFwiQXN5bmNGdW5jdGlvblwiLFxuICAvLyBSZWZsZWN0aW9uXG4gIFwiUmVmbGVjdFwiLFxuICBcIlByb3h5XCIsXG4gIC8vIEludGVybmF0aW9uYWxpemF0aW9uXG4gIFwiSW50bFwiLFxuICAvLyBXZWJBc3NlbWJseVxuICBcIldlYkFzc2VtYmx5XCJcbl07XG5cbmNvbnN0IEVSUk9SX1RZUEVTID0gW1xuICBcIkVycm9yXCIsXG4gIFwiRXZhbEVycm9yXCIsXG4gIFwiSW50ZXJuYWxFcnJvclwiLFxuICBcIlJhbmdlRXJyb3JcIixcbiAgXCJSZWZlcmVuY2VFcnJvclwiLFxuICBcIlN5bnRheEVycm9yXCIsXG4gIFwiVHlwZUVycm9yXCIsXG4gIFwiVVJJRXJyb3JcIlxuXTtcblxuY29uc3QgQlVJTFRfSU5fR0xPQkFMUyA9IFtcbiAgXCJzZXRJbnRlcnZhbFwiLFxuICBcInNldFRpbWVvdXRcIixcbiAgXCJjbGVhckludGVydmFsXCIsXG4gIFwiY2xlYXJUaW1lb3V0XCIsXG5cbiAgXCJyZXF1aXJlXCIsXG4gIFwiZXhwb3J0c1wiLFxuXG4gIFwiZXZhbFwiLFxuICBcImlzRmluaXRlXCIsXG4gIFwiaXNOYU5cIixcbiAgXCJwYXJzZUZsb2F0XCIsXG4gIFwicGFyc2VJbnRcIixcbiAgXCJkZWNvZGVVUklcIixcbiAgXCJkZWNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlbmNvZGVVUklcIixcbiAgXCJlbmNvZGVVUklDb21wb25lbnRcIixcbiAgXCJlc2NhcGVcIixcbiAgXCJ1bmVzY2FwZVwiXG5dO1xuXG5jb25zdCBCVUlMVF9JTl9WQVJJQUJMRVMgPSBbXG4gIFwiYXJndW1lbnRzXCIsXG4gIFwidGhpc1wiLFxuICBcInN1cGVyXCIsXG4gIFwiY29uc29sZVwiLFxuICBcIndpbmRvd1wiLFxuICBcImRvY3VtZW50XCIsXG4gIFwibG9jYWxTdG9yYWdlXCIsXG4gIFwic2Vzc2lvblN0b3JhZ2VcIixcbiAgXCJtb2R1bGVcIixcbiAgXCJnbG9iYWxcIiAvLyBOb2RlLmpzXG5dO1xuXG5jb25zdCBCVUlMVF9JTlMgPSBbXS5jb25jYXQoXG4gIEJVSUxUX0lOX0dMT0JBTFMsXG4gIFRZUEVTLFxuICBFUlJPUl9UWVBFU1xuKTtcblxuLypcbkxhbmd1YWdlOiBKYXZhU2NyaXB0XG5EZXNjcmlwdGlvbjogSmF2YVNjcmlwdCAoSlMpIGlzIGEgbGlnaHR3ZWlnaHQsIGludGVycHJldGVkLCBvciBqdXN0LWluLXRpbWUgY29tcGlsZWQgcHJvZ3JhbW1pbmcgbGFuZ3VhZ2Ugd2l0aCBmaXJzdC1jbGFzcyBmdW5jdGlvbnMuXG5DYXRlZ29yeTogY29tbW9uLCBzY3JpcHRpbmcsIHdlYlxuV2Vic2l0ZTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdFxuKi9cblxuXG4vKiogQHR5cGUgTGFuZ3VhZ2VGbiAqL1xuZnVuY3Rpb24gamF2YXNjcmlwdChobGpzKSB7XG4gIGNvbnN0IHJlZ2V4ID0gaGxqcy5yZWdleDtcbiAgLyoqXG4gICAqIFRha2VzIGEgc3RyaW5nIGxpa2UgXCI8Qm9vZ2VyXCIgYW5kIGNoZWNrcyB0byBzZWVcbiAgICogaWYgd2UgY2FuIGZpbmQgYSBtYXRjaGluZyBcIjwvQm9vZ2VyXCIgbGF0ZXIgaW4gdGhlXG4gICAqIGNvbnRlbnQuXG4gICAqIEBwYXJhbSB7UmVnRXhwTWF0Y2hBcnJheX0gbWF0Y2hcbiAgICogQHBhcmFtIHt7YWZ0ZXI6bnVtYmVyfX0gcGFyYW0xXG4gICAqL1xuICBjb25zdCBoYXNDbG9zaW5nVGFnID0gKG1hdGNoLCB7IGFmdGVyIH0pID0+IHtcbiAgICBjb25zdCB0YWcgPSBcIjwvXCIgKyBtYXRjaFswXS5zbGljZSgxKTtcbiAgICBjb25zdCBwb3MgPSBtYXRjaC5pbnB1dC5pbmRleE9mKHRhZywgYWZ0ZXIpO1xuICAgIHJldHVybiBwb3MgIT09IC0xO1xuICB9O1xuXG4gIGNvbnN0IElERU5UX1JFJDEgPSBJREVOVF9SRTtcbiAgY29uc3QgRlJBR01FTlQgPSB7XG4gICAgYmVnaW46ICc8PicsXG4gICAgZW5kOiAnPC8+J1xuICB9O1xuICAvLyB0byBhdm9pZCBzb21lIHNwZWNpYWwgY2FzZXMgaW5zaWRlIGlzVHJ1bHlPcGVuaW5nVGFnXG4gIGNvbnN0IFhNTF9TRUxGX0NMT1NJTkcgPSAvPFtBLVphLXowLTlcXFxcLl86LV0rXFxzKlxcLz4vO1xuICBjb25zdCBYTUxfVEFHID0ge1xuICAgIGJlZ2luOiAvPFtBLVphLXowLTlcXFxcLl86LV0rLyxcbiAgICBlbmQ6IC9cXC9bQS1aYS16MC05XFxcXC5fOi1dKz58XFwvPi8sXG4gICAgLyoqXG4gICAgICogQHBhcmFtIHtSZWdFeHBNYXRjaEFycmF5fSBtYXRjaFxuICAgICAqIEBwYXJhbSB7Q2FsbGJhY2tSZXNwb25zZX0gcmVzcG9uc2VcbiAgICAgKi9cbiAgICBpc1RydWx5T3BlbmluZ1RhZzogKG1hdGNoLCByZXNwb25zZSkgPT4ge1xuICAgICAgY29uc3QgYWZ0ZXJNYXRjaEluZGV4ID0gbWF0Y2hbMF0ubGVuZ3RoICsgbWF0Y2guaW5kZXg7XG4gICAgICBjb25zdCBuZXh0Q2hhciA9IG1hdGNoLmlucHV0W2FmdGVyTWF0Y2hJbmRleF07XG4gICAgICBpZiAoXG4gICAgICAgIC8vIEhUTUwgc2hvdWxkIG5vdCBpbmNsdWRlIGFub3RoZXIgcmF3IGA8YCBpbnNpZGUgYSB0YWdcbiAgICAgICAgLy8gbmVzdGVkIHR5cGU/XG4gICAgICAgIC8vIGA8QXJyYXk8QXJyYXk8bnVtYmVyPj5gLCBldGMuXG4gICAgICAgIG5leHRDaGFyID09PSBcIjxcIiB8fFxuICAgICAgICAvLyB0aGUgLCBnaXZlcyBhd2F5IHRoYXQgdGhpcyBpcyBub3QgSFRNTFxuICAgICAgICAvLyBgPFQsIEEgZXh0ZW5kcyBrZXlvZiBULCBWPmBcbiAgICAgICAgbmV4dENoYXIgPT09IFwiLFwiXG4gICAgICAgICkge1xuICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIGA8c29tZXRoaW5nPmBcbiAgICAgIC8vIFF1aXRlIHBvc3NpYmx5IGEgdGFnLCBsZXRzIGxvb2sgZm9yIGEgbWF0Y2hpbmcgY2xvc2luZyB0YWcuLi5cbiAgICAgIGlmIChuZXh0Q2hhciA9PT0gXCI+XCIpIHtcbiAgICAgICAgLy8gaWYgd2UgY2Fubm90IGZpbmQgYSBtYXRjaGluZyBjbG9zaW5nIHRhZywgdGhlbiB3ZVxuICAgICAgICAvLyB3aWxsIGlnbm9yZSBpdFxuICAgICAgICBpZiAoIWhhc0Nsb3NpbmdUYWcobWF0Y2gsIHsgYWZ0ZXI6IGFmdGVyTWF0Y2hJbmRleCB9KSkge1xuICAgICAgICAgIHJlc3BvbnNlLmlnbm9yZU1hdGNoKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gYDxibGFoIC8+YCAoc2VsZi1jbG9zaW5nKVxuICAgICAgLy8gaGFuZGxlZCBieSBzaW1wbGVTZWxmQ2xvc2luZyBydWxlXG5cbiAgICAgIGxldCBtO1xuICAgICAgY29uc3QgYWZ0ZXJNYXRjaCA9IG1hdGNoLmlucHV0LnN1YnN0cmluZyhhZnRlck1hdGNoSW5kZXgpO1xuXG4gICAgICAvLyBzb21lIG1vcmUgdGVtcGxhdGUgdHlwaW5nIHN0dWZmXG4gICAgICAvLyAgPFQgPSBhbnk+KGtleT86IHN0cmluZykgPT4gTW9kaWZ5PFxuICAgICAgaWYgKChtID0gYWZ0ZXJNYXRjaC5tYXRjaCgvXlxccyo9LykpKSB7XG4gICAgICAgIHJlc3BvbnNlLmlnbm9yZU1hdGNoKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gYDxGcm9tIGV4dGVuZHMgc3RyaW5nPmBcbiAgICAgIC8vIHRlY2huaWNhbGx5IHRoaXMgY291bGQgYmUgSFRNTCwgYnV0IGl0IHNtZWxscyBsaWtlIGEgdHlwZVxuICAgICAgLy8gTk9URTogVGhpcyBpcyB1Z2gsIGJ1dCBhZGRlZCBzcGVjaWZpY2FsbHkgZm9yIGh0dHBzOi8vZ2l0aHViLmNvbS9oaWdobGlnaHRqcy9oaWdobGlnaHQuanMvaXNzdWVzLzMyNzZcbiAgICAgIGlmICgobSA9IGFmdGVyTWF0Y2gubWF0Y2goL15cXHMrZXh0ZW5kc1xccysvKSkpIHtcbiAgICAgICAgaWYgKG0uaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXNwb25zZS5pZ25vcmVNYXRjaCgpO1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11c2VsZXNzLXJldHVyblxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgY29uc3QgS0VZV09SRFMkMSA9IHtcbiAgICAkcGF0dGVybjogSURFTlRfUkUsXG4gICAga2V5d29yZDogS0VZV09SRFMsXG4gICAgbGl0ZXJhbDogTElURVJBTFMsXG4gICAgYnVpbHRfaW46IEJVSUxUX0lOUyxcbiAgICBcInZhcmlhYmxlLmxhbmd1YWdlXCI6IEJVSUxUX0lOX1ZBUklBQkxFU1xuICB9O1xuXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtbGl0ZXJhbHMtbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkZWNpbWFsRGlnaXRzID0gJ1swLTldKF8/WzAtOV0pKic7XG4gIGNvbnN0IGZyYWMgPSBgXFxcXC4oJHtkZWNpbWFsRGlnaXRzfSlgO1xuICAvLyBEZWNpbWFsSW50ZWdlckxpdGVyYWwsIGluY2x1ZGluZyBBbm5leCBCIE5vbk9jdGFsRGVjaW1hbEludGVnZXJMaXRlcmFsXG4gIC8vIGh0dHBzOi8vdGMzOS5lcy9lY21hMjYyLyNzZWMtYWRkaXRpb25hbC1zeW50YXgtbnVtZXJpYy1saXRlcmFsc1xuICBjb25zdCBkZWNpbWFsSW50ZWdlciA9IGAwfFsxLTldKF8/WzAtOV0pKnwwWzAtN10qWzg5XVswLTldKmA7XG4gIGNvbnN0IE5VTUJFUiA9IHtcbiAgICBjbGFzc05hbWU6ICdudW1iZXInLFxuICAgIHZhcmlhbnRzOiBbXG4gICAgICAvLyBEZWNpbWFsTGl0ZXJhbFxuICAgICAgeyBiZWdpbjogYChcXFxcYigke2RlY2ltYWxJbnRlZ2VyfSkoKCR7ZnJhY30pfFxcXFwuKT98KCR7ZnJhY30pKWAgK1xuICAgICAgICBgW2VFXVsrLV0/KCR7ZGVjaW1hbERpZ2l0c30pXFxcXGJgIH0sXG4gICAgICB7IGJlZ2luOiBgXFxcXGIoJHtkZWNpbWFsSW50ZWdlcn0pXFxcXGIoKCR7ZnJhY30pXFxcXGJ8XFxcXC4pP3woJHtmcmFjfSlcXFxcYmAgfSxcblxuICAgICAgLy8gRGVjaW1hbEJpZ0ludGVnZXJMaXRlcmFsXG4gICAgICB7IGJlZ2luOiBgXFxcXGIoMHxbMS05XShfP1swLTldKSopblxcXFxiYCB9LFxuXG4gICAgICAvLyBOb25EZWNpbWFsSW50ZWdlckxpdGVyYWxcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwW3hYXVswLTlhLWZBLUZdKF8/WzAtOWEtZkEtRl0pKm4/XFxcXGJcIiB9LFxuICAgICAgeyBiZWdpbjogXCJcXFxcYjBbYkJdWzAtMV0oXz9bMC0xXSkqbj9cXFxcYlwiIH0sXG4gICAgICB7IGJlZ2luOiBcIlxcXFxiMFtvT11bMC03XShfP1swLTddKSpuP1xcXFxiXCIgfSxcblxuICAgICAgLy8gTGVnYWN5T2N0YWxJbnRlZ2VyTGl0ZXJhbCAoZG9lcyBub3QgaW5jbHVkZSB1bmRlcnNjb3JlIHNlcGFyYXRvcnMpXG4gICAgICAvLyBodHRwczovL3RjMzkuZXMvZWNtYTI2Mi8jc2VjLWFkZGl0aW9uYWwtc3ludGF4LW51bWVyaWMtbGl0ZXJhbHNcbiAgICAgIHsgYmVnaW46IFwiXFxcXGIwWzAtN10rbj9cXFxcYlwiIH0sXG4gICAgXSxcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBTVUJTVCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdWJzdCcsXG4gICAgYmVnaW46ICdcXFxcJFxcXFx7JyxcbiAgICBlbmQ6ICdcXFxcfScsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFtdIC8vIGRlZmluZWQgbGF0ZXJcbiAgfTtcbiAgY29uc3QgSFRNTF9URU1QTEFURSA9IHtcbiAgICBiZWdpbjogJ2h0bWxgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJ1xuICAgIH1cbiAgfTtcbiAgY29uc3QgQ1NTX1RFTVBMQVRFID0ge1xuICAgIGJlZ2luOiAnY3NzYCcsXG4gICAgZW5kOiAnJyxcbiAgICBzdGFydHM6IHtcbiAgICAgIGVuZDogJ2AnLFxuICAgICAgcmV0dXJuRW5kOiBmYWxzZSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgICAgU1VCU1RcbiAgICAgIF0sXG4gICAgICBzdWJMYW5ndWFnZTogJ2NzcydcbiAgICB9XG4gIH07XG4gIGNvbnN0IEdSQVBIUUxfVEVNUExBVEUgPSB7XG4gICAgYmVnaW46ICdncWxgJyxcbiAgICBlbmQ6ICcnLFxuICAgIHN0YXJ0czoge1xuICAgICAgZW5kOiAnYCcsXG4gICAgICByZXR1cm5FbmQ6IGZhbHNlLFxuICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgaGxqcy5CQUNLU0xBU0hfRVNDQVBFLFxuICAgICAgICBTVUJTVFxuICAgICAgXSxcbiAgICAgIHN1Ykxhbmd1YWdlOiAnZ3JhcGhxbCdcbiAgICB9XG4gIH07XG4gIGNvbnN0IFRFTVBMQVRFX1NUUklORyA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGJlZ2luOiAnYCcsXG4gICAgZW5kOiAnYCcsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIGhsanMuQkFDS1NMQVNIX0VTQ0FQRSxcbiAgICAgIFNVQlNUXG4gICAgXVxuICB9O1xuICBjb25zdCBKU0RPQ19DT01NRU5UID0gaGxqcy5DT01NRU5UKFxuICAgIC9cXC9cXCpcXCooPyFcXC8pLyxcbiAgICAnXFxcXCovJyxcbiAgICB7XG4gICAgICByZWxldmFuY2U6IDAsXG4gICAgICBjb250YWluczogW1xuICAgICAgICB7XG4gICAgICAgICAgYmVnaW46ICcoPz1AW0EtWmEtel0rKScsXG4gICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ2RvY3RhZycsXG4gICAgICAgICAgICAgIGJlZ2luOiAnQFtBLVphLXpdKydcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3R5cGUnLFxuICAgICAgICAgICAgICBiZWdpbjogJ1xcXFx7JyxcbiAgICAgICAgICAgICAgZW5kOiAnXFxcXH0nLFxuICAgICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAgICAgICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY2xhc3NOYW1lOiAndmFyaWFibGUnLFxuICAgICAgICAgICAgICBiZWdpbjogSURFTlRfUkUkMSArICcoPz1cXFxccyooLSl8JCknLFxuICAgICAgICAgICAgICBlbmRzUGFyZW50OiB0cnVlLFxuICAgICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBlYXQgc3BhY2VzIChub3QgbmV3bGluZXMpIHNvIHdlIGNhbiBmaW5kXG4gICAgICAgICAgICAvLyB0eXBlcyBvciB2YXJpYWJsZXNcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgYmVnaW46IC8oPz1bXlxcbl0pXFxzLyxcbiAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICB9XG4gICAgICAgICAgXVxuICAgICAgICB9XG4gICAgICBdXG4gICAgfVxuICApO1xuICBjb25zdCBDT01NRU5UID0ge1xuICAgIGNsYXNzTmFtZTogXCJjb21tZW50XCIsXG4gICAgdmFyaWFudHM6IFtcbiAgICAgIEpTRE9DX0NPTU1FTlQsXG4gICAgICBobGpzLkNfQkxPQ0tfQ09NTUVOVF9NT0RFLFxuICAgICAgaGxqcy5DX0xJTkVfQ09NTUVOVF9NT0RFXG4gICAgXVxuICB9O1xuICBjb25zdCBTVUJTVF9JTlRFUk5BTFMgPSBbXG4gICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgIGhsanMuUVVPVEVfU1RSSU5HX01PREUsXG4gICAgSFRNTF9URU1QTEFURSxcbiAgICBDU1NfVEVNUExBVEUsXG4gICAgR1JBUEhRTF9URU1QTEFURSxcbiAgICBURU1QTEFURV9TVFJJTkcsXG4gICAgLy8gU2tpcCBudW1iZXJzIHdoZW4gdGhleSBhcmUgcGFydCBvZiBhIHZhcmlhYmxlIG5hbWVcbiAgICB7IG1hdGNoOiAvXFwkXFxkKy8gfSxcbiAgICBOVU1CRVIsXG4gICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbDpcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2hpZ2hsaWdodGpzL2hpZ2hsaWdodC5qcy9pc3N1ZXMvMzI4OFxuICAgIC8vIGhsanMuUkVHRVhQX01PREVcbiAgXTtcbiAgU1VCU1QuY29udGFpbnMgPSBTVUJTVF9JTlRFUk5BTFNcbiAgICAuY29uY2F0KHtcbiAgICAgIC8vIHdlIG5lZWQgdG8gcGFpciB1cCB7fSBpbnNpZGUgb3VyIHN1YnN0IHRvIHByZXZlbnRcbiAgICAgIC8vIGl0IGZyb20gZW5kaW5nIHRvbyBlYXJseSBieSBtYXRjaGluZyBhbm90aGVyIH1cbiAgICAgIGJlZ2luOiAvXFx7LyxcbiAgICAgIGVuZDogL1xcfS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgIFwic2VsZlwiXG4gICAgICBdLmNvbmNhdChTVUJTVF9JTlRFUk5BTFMpXG4gICAgfSk7XG4gIGNvbnN0IFNVQlNUX0FORF9DT01NRU5UUyA9IFtdLmNvbmNhdChDT01NRU5ULCBTVUJTVC5jb250YWlucyk7XG4gIGNvbnN0IFBBUkFNU19DT05UQUlOUyA9IFNVQlNUX0FORF9DT01NRU5UUy5jb25jYXQoW1xuICAgIC8vIGVhdCByZWN1cnNpdmUgcGFyZW5zIGluIHN1YiBleHByZXNzaW9uc1xuICAgIHtcbiAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgIGVuZDogL1xcKS8sXG4gICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgIGNvbnRhaW5zOiBbXCJzZWxmXCJdLmNvbmNhdChTVUJTVF9BTkRfQ09NTUVOVFMpXG4gICAgfVxuICBdKTtcbiAgY29uc3QgUEFSQU1TID0ge1xuICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgYmVnaW46IC9cXCgvLFxuICAgIGVuZDogL1xcKS8sXG4gICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgIGV4Y2x1ZGVFbmQ6IHRydWUsXG4gICAga2V5d29yZHM6IEtFWVdPUkRTJDEsXG4gICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICB9O1xuXG4gIC8vIEVTNiBjbGFzc2VzXG4gIGNvbnN0IENMQVNTX09SX0VYVEVORFMgPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIC8vIGNsYXNzIENhciBleHRlbmRzIHZlaGljbGVcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICAvZXh0ZW5kcy8sXG4gICAgICAgICAgL1xccysvLFxuICAgICAgICAgIHJlZ2V4LmNvbmNhdChJREVOVF9SRSQxLCBcIihcIiwgcmVnZXguY29uY2F0KC9cXC4vLCBJREVOVF9SRSQxKSwgXCIpKlwiKVxuICAgICAgICBdLFxuICAgICAgICBzY29wZToge1xuICAgICAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgICAgIDM6IFwidGl0bGUuY2xhc3NcIixcbiAgICAgICAgICA1OiBcImtleXdvcmRcIixcbiAgICAgICAgICA3OiBcInRpdGxlLmNsYXNzLmluaGVyaXRlZFwiXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICAvLyBjbGFzcyBDYXJcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvY2xhc3MvLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxXG4gICAgICAgIF0sXG4gICAgICAgIHNjb3BlOiB7XG4gICAgICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAgICAgMzogXCJ0aXRsZS5jbGFzc1wiXG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICBdXG4gIH07XG5cbiAgY29uc3QgQ0xBU1NfUkVGRVJFTkNFID0ge1xuICAgIHJlbGV2YW5jZTogMCxcbiAgICBtYXRjaDpcbiAgICByZWdleC5laXRoZXIoXG4gICAgICAvLyBIYXJkIGNvZGVkIGV4Y2VwdGlvbnNcbiAgICAgIC9cXGJKU09OLyxcbiAgICAgIC8vIEZsb2F0MzJBcnJheSwgT3V0VFxuICAgICAgL1xcYltBLVpdW2Etel0rKFtBLVpdW2Etel0qfFxcZCkqLyxcbiAgICAgIC8vIENTU0ZhY3RvcnksIENTU0ZhY3RvcnlUXG4gICAgICAvXFxiW0EtWl17Mix9KFtBLVpdW2Etel0rfFxcZCkrKFtBLVpdW2Etel0qKSovLFxuICAgICAgLy8gRlBzLCBGUHNUXG4gICAgICAvXFxiW0EtWl17Mix9W2Etel0rKFtBLVpdW2Etel0rfFxcZCkqKFtBLVpdW2Etel0qKSovLFxuICAgICAgLy8gUFxuICAgICAgLy8gc2luZ2xlIGxldHRlcnMgYXJlIG5vdCBoaWdobGlnaHRlZFxuICAgICAgLy8gQkxBSFxuICAgICAgLy8gdGhpcyB3aWxsIGJlIGZsYWdnZWQgYXMgYSBVUFBFUl9DQVNFX0NPTlNUQU5UIGluc3RlYWRcbiAgICApLFxuICAgIGNsYXNzTmFtZTogXCJ0aXRsZS5jbGFzc1wiLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBfOiBbXG4gICAgICAgIC8vIHNlIHdlIHN0aWxsIGdldCByZWxldmFuY2UgY3JlZGl0IGZvciBKUyBsaWJyYXJ5IGNsYXNzZXNcbiAgICAgICAgLi4uVFlQRVMsXG4gICAgICAgIC4uLkVSUk9SX1RZUEVTXG4gICAgICBdXG4gICAgfVxuICB9O1xuXG4gIGNvbnN0IFVTRV9TVFJJQ1QgPSB7XG4gICAgbGFiZWw6IFwidXNlX3N0cmljdFwiLFxuICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgIHJlbGV2YW5jZTogMTAsXG4gICAgYmVnaW46IC9eXFxzKlsnXCJddXNlIChzdHJpY3R8YXNtKVsnXCJdL1xuICB9O1xuXG4gIGNvbnN0IEZVTkNUSU9OX0RFRklOSVRJT04gPSB7XG4gICAgdmFyaWFudHM6IFtcbiAgICAgIHtcbiAgICAgICAgbWF0Y2g6IFtcbiAgICAgICAgICAvZnVuY3Rpb24vLFxuICAgICAgICAgIC9cXHMrLyxcbiAgICAgICAgICBJREVOVF9SRSQxLFxuICAgICAgICAgIC8oPz1cXHMqXFwoKS9cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGFub255bW91cyBmdW5jdGlvblxuICAgICAge1xuICAgICAgICBtYXRjaDogW1xuICAgICAgICAgIC9mdW5jdGlvbi8sXG4gICAgICAgICAgL1xccyooPz1cXCgpL1xuICAgICAgICBdXG4gICAgICB9XG4gICAgXSxcbiAgICBjbGFzc05hbWU6IHtcbiAgICAgIDE6IFwia2V5d29yZFwiLFxuICAgICAgMzogXCJ0aXRsZS5mdW5jdGlvblwiXG4gICAgfSxcbiAgICBsYWJlbDogXCJmdW5jLmRlZlwiLFxuICAgIGNvbnRhaW5zOiBbIFBBUkFNUyBdLFxuICAgIGlsbGVnYWw6IC8lL1xuICB9O1xuXG4gIGNvbnN0IFVQUEVSX0NBU0VfQ09OU1RBTlQgPSB7XG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIG1hdGNoOiAvXFxiW0EtWl1bQS1aXzAtOV0rXFxiLyxcbiAgICBjbGFzc05hbWU6IFwidmFyaWFibGUuY29uc3RhbnRcIlxuICB9O1xuXG4gIGZ1bmN0aW9uIG5vbmVPZihsaXN0KSB7XG4gICAgcmV0dXJuIHJlZ2V4LmNvbmNhdChcIig/IVwiLCBsaXN0LmpvaW4oXCJ8XCIpLCBcIilcIik7XG4gIH1cblxuICBjb25zdCBGVU5DVElPTl9DQUxMID0ge1xuICAgIG1hdGNoOiByZWdleC5jb25jYXQoXG4gICAgICAvXFxiLyxcbiAgICAgIG5vbmVPZihbXG4gICAgICAgIC4uLkJVSUxUX0lOX0dMT0JBTFMsXG4gICAgICAgIFwic3VwZXJcIixcbiAgICAgICAgXCJpbXBvcnRcIlxuICAgICAgXSksXG4gICAgICBJREVOVF9SRSQxLCByZWdleC5sb29rYWhlYWQoL1xcKC8pKSxcbiAgICBjbGFzc05hbWU6IFwidGl0bGUuZnVuY3Rpb25cIixcbiAgICByZWxldmFuY2U6IDBcbiAgfTtcblxuICBjb25zdCBQUk9QRVJUWV9BQ0NFU1MgPSB7XG4gICAgYmVnaW46IHJlZ2V4LmNvbmNhdCgvXFwuLywgcmVnZXgubG9va2FoZWFkKFxuICAgICAgcmVnZXguY29uY2F0KElERU5UX1JFJDEsIC8oPyFbMC05QS1aYS16JF8oXSkvKVxuICAgICkpLFxuICAgIGVuZDogSURFTlRfUkUkMSxcbiAgICBleGNsdWRlQmVnaW46IHRydWUsXG4gICAga2V5d29yZHM6IFwicHJvdG90eXBlXCIsXG4gICAgY2xhc3NOYW1lOiBcInByb3BlcnR5XCIsXG4gICAgcmVsZXZhbmNlOiAwXG4gIH07XG5cbiAgY29uc3QgR0VUVEVSX09SX1NFVFRFUiA9IHtcbiAgICBtYXRjaDogW1xuICAgICAgL2dldHxzZXQvLFxuICAgICAgL1xccysvLFxuICAgICAgSURFTlRfUkUkMSxcbiAgICAgIC8oPz1cXCgpL1xuICAgIF0sXG4gICAgY2xhc3NOYW1lOiB7XG4gICAgICAxOiBcImtleXdvcmRcIixcbiAgICAgIDM6IFwidGl0bGUuZnVuY3Rpb25cIlxuICAgIH0sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHsgLy8gZWF0IHRvIGF2b2lkIGVtcHR5IHBhcmFtc1xuICAgICAgICBiZWdpbjogL1xcKFxcKS9cbiAgICAgIH0sXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgY29uc3QgRlVOQ19MRUFEX0lOX1JFID0gJyhcXFxcKCcgK1xuICAgICdbXigpXSooXFxcXCgnICtcbiAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgJ1teKCldKicgK1xuICAgICdcXFxcKVteKCldKikqJyArXG4gICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAnXFxcXCl8JyArIGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSArICcpXFxcXHMqPT4nO1xuXG4gIGNvbnN0IEZVTkNUSU9OX1ZBUklBQkxFID0ge1xuICAgIG1hdGNoOiBbXG4gICAgICAvY29uc3R8dmFyfGxldC8sIC9cXHMrLyxcbiAgICAgIElERU5UX1JFJDEsIC9cXHMqLyxcbiAgICAgIC89XFxzKi8sXG4gICAgICAvKGFzeW5jXFxzKik/LywgLy8gYXN5bmMgaXMgb3B0aW9uYWxcbiAgICAgIHJlZ2V4Lmxvb2thaGVhZChGVU5DX0xFQURfSU5fUkUpXG4gICAgXSxcbiAgICBrZXl3b3JkczogXCJhc3luY1wiLFxuICAgIGNsYXNzTmFtZToge1xuICAgICAgMTogXCJrZXl3b3JkXCIsXG4gICAgICAzOiBcInRpdGxlLmZ1bmN0aW9uXCJcbiAgICB9LFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBQQVJBTVNcbiAgICBdXG4gIH07XG5cbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnSmF2YVNjcmlwdCcsXG4gICAgYWxpYXNlczogWydqcycsICdqc3gnLCAnbWpzJywgJ2NqcyddLFxuICAgIGtleXdvcmRzOiBLRVlXT1JEUyQxLFxuICAgIC8vIHRoaXMgd2lsbCBiZSBleHRlbmRlZCBieSBUeXBlU2NyaXB0XG4gICAgZXhwb3J0czogeyBQQVJBTVNfQ09OVEFJTlMsIENMQVNTX1JFRkVSRU5DRSB9LFxuICAgIGlsbGVnYWw6IC8jKD8hWyRfQS16XSkvLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICBobGpzLlNIRUJBTkcoe1xuICAgICAgICBsYWJlbDogXCJzaGViYW5nXCIsXG4gICAgICAgIGJpbmFyeTogXCJub2RlXCIsXG4gICAgICAgIHJlbGV2YW5jZTogNVxuICAgICAgfSksXG4gICAgICBVU0VfU1RSSUNULFxuICAgICAgaGxqcy5BUE9TX1NUUklOR19NT0RFLFxuICAgICAgaGxqcy5RVU9URV9TVFJJTkdfTU9ERSxcbiAgICAgIEhUTUxfVEVNUExBVEUsXG4gICAgICBDU1NfVEVNUExBVEUsXG4gICAgICBHUkFQSFFMX1RFTVBMQVRFLFxuICAgICAgVEVNUExBVEVfU1RSSU5HLFxuICAgICAgQ09NTUVOVCxcbiAgICAgIC8vIFNraXAgbnVtYmVycyB3aGVuIHRoZXkgYXJlIHBhcnQgb2YgYSB2YXJpYWJsZSBuYW1lXG4gICAgICB7IG1hdGNoOiAvXFwkXFxkKy8gfSxcbiAgICAgIE5VTUJFUixcbiAgICAgIENMQVNTX1JFRkVSRU5DRSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnYXR0cicsXG4gICAgICAgIGJlZ2luOiBJREVOVF9SRSQxICsgcmVnZXgubG9va2FoZWFkKCc6JyksXG4gICAgICAgIHJlbGV2YW5jZTogMFxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX1ZBUklBQkxFLFxuICAgICAgeyAvLyBcInZhbHVlXCIgY29udGFpbmVyXG4gICAgICAgIGJlZ2luOiAnKCcgKyBobGpzLlJFX1NUQVJURVJTX1JFICsgJ3xcXFxcYihjYXNlfHJldHVybnx0aHJvdylcXFxcYilcXFxccyonLFxuICAgICAgICBrZXl3b3JkczogJ3JldHVybiB0aHJvdyBjYXNlJyxcbiAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIENPTU1FTlQsXG4gICAgICAgICAgaGxqcy5SRUdFWFBfTU9ERSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjbGFzc05hbWU6ICdmdW5jdGlvbicsXG4gICAgICAgICAgICAvLyB3ZSBoYXZlIHRvIGNvdW50IHRoZSBwYXJlbnMgdG8gbWFrZSBzdXJlIHdlIGFjdHVhbGx5IGhhdmUgdGhlXG4gICAgICAgICAgICAvLyBjb3JyZWN0IGJvdW5kaW5nICggKSBiZWZvcmUgdGhlID0+LiAgVGhlcmUgY291bGQgYmUgYW55IG51bWJlciBvZlxuICAgICAgICAgICAgLy8gc3ViLWV4cHJlc3Npb25zIGluc2lkZSBhbHNvIHN1cnJvdW5kZWQgYnkgcGFyZW5zLlxuICAgICAgICAgICAgYmVnaW46IEZVTkNfTEVBRF9JTl9SRSxcbiAgICAgICAgICAgIHJldHVybkJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgZW5kOiAnXFxcXHMqPT4nLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ3BhcmFtcycsXG4gICAgICAgICAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgYmVnaW46IGhsanMuVU5ERVJTQ09SRV9JREVOVF9SRSxcbiAgICAgICAgICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWU6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoXFxzKlxcKS8sXG4gICAgICAgICAgICAgICAgICAgIHNraXA6IHRydWVcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGJlZ2luOiAvXFwoLyxcbiAgICAgICAgICAgICAgICAgICAgZW5kOiAvXFwpLyxcbiAgICAgICAgICAgICAgICAgICAgZXhjbHVkZUJlZ2luOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBrZXl3b3JkczogS0VZV09SRFMkMSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbnM6IFBBUkFNU19DT05UQUlOU1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgeyAvLyBjb3VsZCBiZSBhIGNvbW1hIGRlbGltaXRlZCBsaXN0IG9mIHBhcmFtcyB0byBhIGZ1bmN0aW9uIGNhbGxcbiAgICAgICAgICAgIGJlZ2luOiAvLC8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIG1hdGNoOiAvXFxzKy8sXG4gICAgICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgICAgICB9LFxuICAgICAgICAgIHsgLy8gSlNYXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7IGJlZ2luOiBGUkFHTUVOVC5iZWdpbiwgZW5kOiBGUkFHTUVOVC5lbmQgfSxcbiAgICAgICAgICAgICAgeyBtYXRjaDogWE1MX1NFTEZfQ0xPU0lORyB9LFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IFhNTF9UQUcuYmVnaW4sXG4gICAgICAgICAgICAgICAgLy8gd2UgY2FyZWZ1bGx5IGNoZWNrIHRoZSBvcGVuaW5nIHRhZyB0byBzZWUgaWYgaXQgdHJ1bHlcbiAgICAgICAgICAgICAgICAvLyBpcyBhIHRhZyBhbmQgbm90IGEgZmFsc2UgcG9zaXRpdmVcbiAgICAgICAgICAgICAgICAnb246YmVnaW4nOiBYTUxfVEFHLmlzVHJ1bHlPcGVuaW5nVGFnLFxuICAgICAgICAgICAgICAgIGVuZDogWE1MX1RBRy5lbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIHN1Ykxhbmd1YWdlOiAneG1sJyxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogWE1MX1RBRy5iZWdpbixcbiAgICAgICAgICAgICAgICBlbmQ6IFhNTF9UQUcuZW5kLFxuICAgICAgICAgICAgICAgIHNraXA6IHRydWUsXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFsnc2VsZiddXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgRlVOQ1RJT05fREVGSU5JVElPTixcbiAgICAgIHtcbiAgICAgICAgLy8gcHJldmVudCB0aGlzIGZyb20gZ2V0dGluZyBzd2FsbG93ZWQgdXAgYnkgZnVuY3Rpb25cbiAgICAgICAgLy8gc2luY2UgdGhleSBhcHBlYXIgXCJmdW5jdGlvbiBsaWtlXCJcbiAgICAgICAgYmVnaW5LZXl3b3JkczogXCJ3aGlsZSBpZiBzd2l0Y2ggY2F0Y2ggZm9yXCJcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIC8vIHdlIGhhdmUgdG8gY291bnQgdGhlIHBhcmVucyB0byBtYWtlIHN1cmUgd2UgYWN0dWFsbHkgaGF2ZSB0aGUgY29ycmVjdFxuICAgICAgICAvLyBib3VuZGluZyAoICkuICBUaGVyZSBjb3VsZCBiZSBhbnkgbnVtYmVyIG9mIHN1Yi1leHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgLy8gYWxzbyBzdXJyb3VuZGVkIGJ5IHBhcmVucy5cbiAgICAgICAgYmVnaW46ICdcXFxcYig/IWZ1bmN0aW9uKScgKyBobGpzLlVOREVSU0NPUkVfSURFTlRfUkUgK1xuICAgICAgICAgICdcXFxcKCcgKyAvLyBmaXJzdCBwYXJlbnNcbiAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAnW14oKV0qKFxcXFwoJyArXG4gICAgICAgICAgICAgICdbXigpXSonICtcbiAgICAgICAgICAgICdcXFxcKVteKCldKikqJyArXG4gICAgICAgICAgJ1xcXFwpW14oKV0qKSonICtcbiAgICAgICAgICAnXFxcXClcXFxccypcXFxceycsIC8vIGVuZCBwYXJlbnNcbiAgICAgICAgcmV0dXJuQmVnaW46dHJ1ZSxcbiAgICAgICAgbGFiZWw6IFwiZnVuYy5kZWZcIixcbiAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICBQQVJBTVMsXG4gICAgICAgICAgaGxqcy5pbmhlcml0KGhsanMuVElUTEVfTU9ERSwgeyBiZWdpbjogSURFTlRfUkUkMSwgY2xhc3NOYW1lOiBcInRpdGxlLmZ1bmN0aW9uXCIgfSlcbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIC8vIGNhdGNoIC4uLiBzbyBpdCB3b24ndCB0cmlnZ2VyIHRoZSBwcm9wZXJ0eSBydWxlIGJlbG93XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwuXFwuXFwuLyxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAgUFJPUEVSVFlfQUNDRVNTLFxuICAgICAgLy8gaGFjazogcHJldmVudHMgZGV0ZWN0aW9uIG9mIGtleXdvcmRzIGluIHNvbWUgY2lyY3Vtc3RhbmNlc1xuICAgICAgLy8gLmtleXdvcmQoKVxuICAgICAgLy8gJGtleXdvcmQgPSB4XG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAnXFxcXCQnICsgSURFTlRfUkUkMSxcbiAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICB9LFxuICAgICAge1xuICAgICAgICBtYXRjaDogWyAvXFxiY29uc3RydWN0b3IoPz1cXHMqXFwoKS8gXSxcbiAgICAgICAgY2xhc3NOYW1lOiB7IDE6IFwidGl0bGUuZnVuY3Rpb25cIiB9LFxuICAgICAgICBjb250YWluczogWyBQQVJBTVMgXVxuICAgICAgfSxcbiAgICAgIEZVTkNUSU9OX0NBTEwsXG4gICAgICBVUFBFUl9DQVNFX0NPTlNUQU5ULFxuICAgICAgQ0xBU1NfT1JfRVhURU5EUyxcbiAgICAgIEdFVFRFUl9PUl9TRVRURVIsXG4gICAgICB7XG4gICAgICAgIG1hdGNoOiAvXFwkWyguXS8gLy8gcmVsZXZhbmNlIGJvb3N0ZXIgZm9yIGEgcGF0dGVybiBjb21tb24gdG8gSlMgbGliczogYCQoc29tZXRoaW5nKWAgYW5kIGAkLnNvbWV0aGluZ2BcbiAgICAgIH1cbiAgICBdXG4gIH07XG59XG5cbi8qXG5MYW5ndWFnZTogVHlwZVNjcmlwdFxuQXV0aG9yOiBQYW51IEhvcnNtYWxhaHRpIDxwYW51LmhvcnNtYWxhaHRpQGlraS5maT5cbkNvbnRyaWJ1dG9yczogSWtlIEt1IDxkZW1wZmlAeWFob28uY29tPlxuRGVzY3JpcHRpb246IFR5cGVTY3JpcHQgaXMgYSBzdHJpY3Qgc3VwZXJzZXQgb2YgSmF2YVNjcmlwdFxuV2Vic2l0ZTogaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnXG5DYXRlZ29yeTogY29tbW9uLCBzY3JpcHRpbmdcbiovXG5cblxuLyoqIEB0eXBlIExhbmd1YWdlRm4gKi9cbmZ1bmN0aW9uIHR5cGVzY3JpcHQoaGxqcykge1xuICBjb25zdCB0c0xhbmd1YWdlID0gamF2YXNjcmlwdChobGpzKTtcblxuICBjb25zdCBJREVOVF9SRSQxID0gSURFTlRfUkU7XG4gIGNvbnN0IFRZUEVTID0gW1xuICAgIFwiYW55XCIsXG4gICAgXCJ2b2lkXCIsXG4gICAgXCJudW1iZXJcIixcbiAgICBcImJvb2xlYW5cIixcbiAgICBcInN0cmluZ1wiLFxuICAgIFwib2JqZWN0XCIsXG4gICAgXCJuZXZlclwiLFxuICAgIFwic3ltYm9sXCIsXG4gICAgXCJiaWdpbnRcIixcbiAgICBcInVua25vd25cIlxuICBdO1xuICBjb25zdCBOQU1FU1BBQ0UgPSB7XG4gICAgYmVnaW5LZXl3b3JkczogJ25hbWVzcGFjZScsXG4gICAgZW5kOiAvXFx7LyxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGNvbnRhaW5zOiBbIHRzTGFuZ3VhZ2UuZXhwb3J0cy5DTEFTU19SRUZFUkVOQ0UgXVxuICB9O1xuICBjb25zdCBJTlRFUkZBQ0UgPSB7XG4gICAgYmVnaW5LZXl3b3JkczogJ2ludGVyZmFjZScsXG4gICAgZW5kOiAvXFx7LyxcbiAgICBleGNsdWRlRW5kOiB0cnVlLFxuICAgIGtleXdvcmRzOiB7XG4gICAgICBrZXl3b3JkOiAnaW50ZXJmYWNlIGV4dGVuZHMnLFxuICAgICAgYnVpbHRfaW46IFRZUEVTXG4gICAgfSxcbiAgICBjb250YWluczogWyB0c0xhbmd1YWdlLmV4cG9ydHMuQ0xBU1NfUkVGRVJFTkNFIF1cbiAgfTtcbiAgY29uc3QgVVNFX1NUUklDVCA9IHtcbiAgICBjbGFzc05hbWU6ICdtZXRhJyxcbiAgICByZWxldmFuY2U6IDEwLFxuICAgIGJlZ2luOiAvXlxccypbJ1wiXXVzZSBzdHJpY3RbJ1wiXS9cbiAgfTtcbiAgY29uc3QgVFNfU1BFQ0lGSUNfS0VZV09SRFMgPSBbXG4gICAgXCJ0eXBlXCIsXG4gICAgXCJuYW1lc3BhY2VcIixcbiAgICBcImludGVyZmFjZVwiLFxuICAgIFwicHVibGljXCIsXG4gICAgXCJwcml2YXRlXCIsXG4gICAgXCJwcm90ZWN0ZWRcIixcbiAgICBcImltcGxlbWVudHNcIixcbiAgICBcImRlY2xhcmVcIixcbiAgICBcImFic3RyYWN0XCIsXG4gICAgXCJyZWFkb25seVwiLFxuICAgIFwiZW51bVwiLFxuICAgIFwib3ZlcnJpZGVcIlxuICBdO1xuICBjb25zdCBLRVlXT1JEUyQxID0ge1xuICAgICRwYXR0ZXJuOiBJREVOVF9SRSxcbiAgICBrZXl3b3JkOiBLRVlXT1JEUy5jb25jYXQoVFNfU1BFQ0lGSUNfS0VZV09SRFMpLFxuICAgIGxpdGVyYWw6IExJVEVSQUxTLFxuICAgIGJ1aWx0X2luOiBCVUlMVF9JTlMuY29uY2F0KFRZUEVTKSxcbiAgICBcInZhcmlhYmxlLmxhbmd1YWdlXCI6IEJVSUxUX0lOX1ZBUklBQkxFU1xuICB9O1xuICBjb25zdCBERUNPUkFUT1IgPSB7XG4gICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgYmVnaW46ICdAJyArIElERU5UX1JFJDEsXG4gIH07XG5cbiAgY29uc3Qgc3dhcE1vZGUgPSAobW9kZSwgbGFiZWwsIHJlcGxhY2VtZW50KSA9PiB7XG4gICAgY29uc3QgaW5keCA9IG1vZGUuY29udGFpbnMuZmluZEluZGV4KG0gPT4gbS5sYWJlbCA9PT0gbGFiZWwpO1xuICAgIGlmIChpbmR4ID09PSAtMSkgeyB0aHJvdyBuZXcgRXJyb3IoXCJjYW4gbm90IGZpbmQgbW9kZSB0byByZXBsYWNlXCIpOyB9XG5cbiAgICBtb2RlLmNvbnRhaW5zLnNwbGljZShpbmR4LCAxLCByZXBsYWNlbWVudCk7XG4gIH07XG5cblxuICAvLyB0aGlzIHNob3VsZCB1cGRhdGUgYW55d2hlcmUga2V5d29yZHMgaXMgdXNlZCBzaW5jZVxuICAvLyBpdCB3aWxsIGJlIHRoZSBzYW1lIGFjdHVhbCBKUyBvYmplY3RcbiAgT2JqZWN0LmFzc2lnbih0c0xhbmd1YWdlLmtleXdvcmRzLCBLRVlXT1JEUyQxKTtcblxuICB0c0xhbmd1YWdlLmV4cG9ydHMuUEFSQU1TX0NPTlRBSU5TLnB1c2goREVDT1JBVE9SKTtcbiAgdHNMYW5ndWFnZS5jb250YWlucyA9IHRzTGFuZ3VhZ2UuY29udGFpbnMuY29uY2F0KFtcbiAgICBERUNPUkFUT1IsXG4gICAgTkFNRVNQQUNFLFxuICAgIElOVEVSRkFDRSxcbiAgXSk7XG5cbiAgLy8gVFMgZ2V0cyBhIHNpbXBsZXIgc2hlYmFuZyBydWxlIHRoYW4gSlNcbiAgc3dhcE1vZGUodHNMYW5ndWFnZSwgXCJzaGViYW5nXCIsIGhsanMuU0hFQkFORygpKTtcbiAgLy8gSlMgdXNlIHN0cmljdCBydWxlIHB1cnBvc2VseSBleGNsdWRlcyBgYXNtYCB3aGljaCBtYWtlcyBubyBzZW5zZVxuICBzd2FwTW9kZSh0c0xhbmd1YWdlLCBcInVzZV9zdHJpY3RcIiwgVVNFX1NUUklDVCk7XG5cbiAgY29uc3QgZnVuY3Rpb25EZWNsYXJhdGlvbiA9IHRzTGFuZ3VhZ2UuY29udGFpbnMuZmluZChtID0+IG0ubGFiZWwgPT09IFwiZnVuYy5kZWZcIik7XG4gIGZ1bmN0aW9uRGVjbGFyYXRpb24ucmVsZXZhbmNlID0gMDsgLy8gKCkgPT4ge30gaXMgbW9yZSB0eXBpY2FsIGluIFR5cGVTY3JpcHRcblxuICBPYmplY3QuYXNzaWduKHRzTGFuZ3VhZ2UsIHtcbiAgICBuYW1lOiAnVHlwZVNjcmlwdCcsXG4gICAgYWxpYXNlczogW1xuICAgICAgJ3RzJyxcbiAgICAgICd0c3gnLFxuICAgICAgJ210cycsXG4gICAgICAnY3RzJ1xuICAgIF1cbiAgfSk7XG5cbiAgcmV0dXJuIHRzTGFuZ3VhZ2U7XG59XG5cbmV4cG9ydCB7IHR5cGVzY3JpcHQgYXMgZGVmYXVsdCB9O1xuIl0sIm5hbWVzIjpbIklERU5UX1JFIiwiS0VZV09SRFMiLCJMSVRFUkFMUyIsIlRZUEVTIiwiRVJST1JfVFlQRVMiLCJCVUlMVF9JTl9HTE9CQUxTIiwiQlVJTFRfSU5fVkFSSUFCTEVTIiwiQlVJTFRfSU5TIiwiY29uY2F0IiwiamF2YXNjcmlwdCIsImhsanMiLCJyZWdleCIsImhhc0Nsb3NpbmdUYWciLCJtYXRjaCIsImFmdGVyIiwidGFnIiwic2xpY2UiLCJwb3MiLCJpbnB1dCIsImluZGV4T2YiLCJJREVOVF9SRSQxIiwiRlJBR01FTlQiLCJiZWdpbiIsImVuZCIsIlhNTF9TRUxGX0NMT1NJTkciLCJYTUxfVEFHIiwiaXNUcnVseU9wZW5pbmdUYWciLCJyZXNwb25zZSIsImFmdGVyTWF0Y2hJbmRleCIsImxlbmd0aCIsImluZGV4IiwibmV4dENoYXIiLCJpZ25vcmVNYXRjaCIsIm0iLCJhZnRlck1hdGNoIiwic3Vic3RyaW5nIiwiS0VZV09SRFMkMSIsIiRwYXR0ZXJuIiwia2V5d29yZCIsImxpdGVyYWwiLCJidWlsdF9pbiIsImRlY2ltYWxEaWdpdHMiLCJmcmFjIiwiZGVjaW1hbEludGVnZXIiLCJOVU1CRVIiLCJjbGFzc05hbWUiLCJ2YXJpYW50cyIsInJlbGV2YW5jZSIsIlNVQlNUIiwia2V5d29yZHMiLCJjb250YWlucyIsIkhUTUxfVEVNUExBVEUiLCJzdGFydHMiLCJyZXR1cm5FbmQiLCJCQUNLU0xBU0hfRVNDQVBFIiwic3ViTGFuZ3VhZ2UiLCJDU1NfVEVNUExBVEUiLCJHUkFQSFFMX1RFTVBMQVRFIiwiVEVNUExBVEVfU1RSSU5HIiwiSlNET0NfQ09NTUVOVCIsIkNPTU1FTlQiLCJleGNsdWRlRW5kIiwiZXhjbHVkZUJlZ2luIiwiZW5kc1BhcmVudCIsIkNfQkxPQ0tfQ09NTUVOVF9NT0RFIiwiQ19MSU5FX0NPTU1FTlRfTU9ERSIsIlNVQlNUX0lOVEVSTkFMUyIsIkFQT1NfU1RSSU5HX01PREUiLCJRVU9URV9TVFJJTkdfTU9ERSIsIlNVQlNUX0FORF9DT01NRU5UUyIsIlBBUkFNU19DT05UQUlOUyIsIlBBUkFNUyIsIkNMQVNTX09SX0VYVEVORFMiLCJzY29wZSIsIkNMQVNTX1JFRkVSRU5DRSIsImVpdGhlciIsIl8iLCJVU0VfU1RSSUNUIiwibGFiZWwiLCJGVU5DVElPTl9ERUZJTklUSU9OIiwiaWxsZWdhbCIsIlVQUEVSX0NBU0VfQ09OU1RBTlQiLCJub25lT2YiLCJsaXN0Iiwiam9pbiIsIkZVTkNUSU9OX0NBTEwiLCJsb29rYWhlYWQiLCJQUk9QRVJUWV9BQ0NFU1MiLCJHRVRURVJfT1JfU0VUVEVSIiwiRlVOQ19MRUFEX0lOX1JFIiwiVU5ERVJTQ09SRV9JREVOVF9SRSIsIkZVTkNUSU9OX1ZBUklBQkxFIiwibmFtZSIsImFsaWFzZXMiLCJleHBvcnRzIiwiU0hFQkFORyIsImJpbmFyeSIsIlJFX1NUQVJURVJTX1JFIiwiUkVHRVhQX01PREUiLCJyZXR1cm5CZWdpbiIsInNraXAiLCJiZWdpbktleXdvcmRzIiwiaW5oZXJpdCIsIlRJVExFX01PREUiLCJ0eXBlc2NyaXB0IiwidHNMYW5ndWFnZSIsIk5BTUVTUEFDRSIsIklOVEVSRkFDRSIsIlRTX1NQRUNJRklDX0tFWVdPUkRTIiwiREVDT1JBVE9SIiwic3dhcE1vZGUiLCJtb2RlIiwicmVwbGFjZW1lbnQiLCJpbmR4IiwiZmluZEluZGV4IiwiRXJyb3IiLCJzcGxpY2UiLCJPYmplY3QiLCJhc3NpZ24iLCJwdXNoIiwiZnVuY3Rpb25EZWNsYXJhdGlvbiIsImZpbmQiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/typescript.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/highlight.js/es/languages/xml.js":
/*!*******************************************************!*\
  !*** ./node_modules/highlight.js/es/languages/xml.js ***!
  \*******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ xml)\n/* harmony export */ });\n/*\nLanguage: HTML, XML\nWebsite: https://www.w3.org/XML/\nCategory: common, web\nAudit: 2020\n*/ /** @type LanguageFn */ function xml(hljs) {\n    const regex = hljs.regex;\n    // XML names can have the following additional letters: https://www.w3.org/TR/xml/#NT-NameChar\n    // OTHER_NAME_CHARS = /[:\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]/;\n    // Element names start with NAME_START_CHAR followed by optional other Unicode letters, ASCII digits, hyphens, underscores, and periods\n    // const TAG_NAME_RE = regex.concat(/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/, regex.optional(/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:/), /[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*/);;\n    // const XML_IDENT_RE = /[A-Z_a-z:\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]+/;\n    // const TAG_NAME_RE = regex.concat(/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]/, regex.optional(/[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*:/), /[A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*/);\n    // however, to cater for performance and more Unicode support rely simply on the Unicode letter class\n    const TAG_NAME_RE = regex.concat(/[\\p{L}_]/u, regex.optional(/[\\p{L}0-9_.-]*:/u), /[\\p{L}0-9_.-]*/u);\n    const XML_IDENT_RE = /[\\p{L}0-9._:-]+/u;\n    const XML_ENTITIES = {\n        className: \"symbol\",\n        begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n    };\n    const XML_META_KEYWORDS = {\n        begin: /\\s/,\n        contains: [\n            {\n                className: \"keyword\",\n                begin: /#?[a-z_][a-z1-9_-]+/,\n                illegal: /\\n/\n            }\n        ]\n    };\n    const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n        begin: /\\(/,\n        end: /\\)/\n    });\n    const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n        className: \"string\"\n    });\n    const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n        className: \"string\"\n    });\n    const TAG_INTERNALS = {\n        endsWithParent: true,\n        illegal: /</,\n        relevance: 0,\n        contains: [\n            {\n                className: \"attr\",\n                begin: XML_IDENT_RE,\n                relevance: 0\n            },\n            {\n                begin: /=\\s*/,\n                relevance: 0,\n                contains: [\n                    {\n                        className: \"string\",\n                        endsParent: true,\n                        variants: [\n                            {\n                                begin: /\"/,\n                                end: /\"/,\n                                contains: [\n                                    XML_ENTITIES\n                                ]\n                            },\n                            {\n                                begin: /'/,\n                                end: /'/,\n                                contains: [\n                                    XML_ENTITIES\n                                ]\n                            },\n                            {\n                                begin: /[^\\s\"'=<>`]+/\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    };\n    return {\n        name: \"HTML, XML\",\n        aliases: [\n            \"html\",\n            \"xhtml\",\n            \"rss\",\n            \"atom\",\n            \"xjb\",\n            \"xsd\",\n            \"xsl\",\n            \"plist\",\n            \"wsf\",\n            \"svg\"\n        ],\n        case_insensitive: true,\n        unicodeRegex: true,\n        contains: [\n            {\n                className: \"meta\",\n                begin: /<![a-z]/,\n                end: />/,\n                relevance: 10,\n                contains: [\n                    XML_META_KEYWORDS,\n                    QUOTE_META_STRING_MODE,\n                    APOS_META_STRING_MODE,\n                    XML_META_PAR_KEYWORDS,\n                    {\n                        begin: /\\[/,\n                        end: /\\]/,\n                        contains: [\n                            {\n                                className: \"meta\",\n                                begin: /<![a-z]/,\n                                end: />/,\n                                contains: [\n                                    XML_META_KEYWORDS,\n                                    XML_META_PAR_KEYWORDS,\n                                    QUOTE_META_STRING_MODE,\n                                    APOS_META_STRING_MODE\n                                ]\n                            }\n                        ]\n                    }\n                ]\n            },\n            hljs.COMMENT(/<!--/, /-->/, {\n                relevance: 10\n            }),\n            {\n                begin: /<!\\[CDATA\\[/,\n                end: /\\]\\]>/,\n                relevance: 10\n            },\n            XML_ENTITIES,\n            // xml processing instructions\n            {\n                className: \"meta\",\n                end: /\\?>/,\n                variants: [\n                    {\n                        begin: /<\\?xml/,\n                        relevance: 10,\n                        contains: [\n                            QUOTE_META_STRING_MODE\n                        ]\n                    },\n                    {\n                        begin: /<\\?[a-z][a-z0-9]+/\n                    }\n                ]\n            },\n            {\n                className: \"tag\",\n                /*\n        The lookahead pattern (?=...) ensures that 'begin' only matches\n        '<style' as a single word, followed by a whitespace or an\n        ending bracket.\n        */ begin: /<style(?=\\s|>)/,\n                end: />/,\n                keywords: {\n                    name: \"style\"\n                },\n                contains: [\n                    TAG_INTERNALS\n                ],\n                starts: {\n                    end: /<\\/style>/,\n                    returnEnd: true,\n                    subLanguage: [\n                        \"css\",\n                        \"xml\"\n                    ]\n                }\n            },\n            {\n                className: \"tag\",\n                // See the comment in the <style tag about the lookahead pattern\n                begin: /<script(?=\\s|>)/,\n                end: />/,\n                keywords: {\n                    name: \"script\"\n                },\n                contains: [\n                    TAG_INTERNALS\n                ],\n                starts: {\n                    end: /<\\/script>/,\n                    returnEnd: true,\n                    subLanguage: [\n                        \"javascript\",\n                        \"handlebars\",\n                        \"xml\"\n                    ]\n                }\n            },\n            // we need this for now for jSX\n            {\n                className: \"tag\",\n                begin: /<>|<\\/>/\n            },\n            // open tag\n            {\n                className: \"tag\",\n                begin: regex.concat(/</, regex.lookahead(regex.concat(TAG_NAME_RE, // <tag/>\n                // <tag>\n                // <tag ...\n                regex.either(/\\/>/, />/, /\\s/)))),\n                end: /\\/?>/,\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0,\n                        starts: TAG_INTERNALS\n                    }\n                ]\n            },\n            // close tag\n            {\n                className: \"tag\",\n                begin: regex.concat(/<\\//, regex.lookahead(regex.concat(TAG_NAME_RE, />/))),\n                contains: [\n                    {\n                        className: \"name\",\n                        begin: TAG_NAME_RE,\n                        relevance: 0\n                    },\n                    {\n                        begin: />/,\n                        relevance: 0,\n                        endsParent: true\n                    }\n                ]\n            }\n        ]\n    };\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy94bWwuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7OztBQUtBLEdBRUEscUJBQXFCLEdBQ3JCLFNBQVNBLElBQUlDLElBQUk7SUFDZixNQUFNQyxRQUFRRCxLQUFLQyxLQUFLO0lBQ3hCLDhGQUE4RjtJQUM5RixrRUFBa0U7SUFDbEUsdUlBQXVJO0lBQ3ZJLHdsQkFBd2xCO0lBQ3hsQiwyTkFBMk47SUFDM04sdWxCQUF1bEI7SUFDdmxCLHFHQUFxRztJQUNyRyxNQUFNQyxjQUFjRCxNQUFNRSxNQUFNLENBQUMsYUFBYUYsTUFBTUcsUUFBUSxDQUFDLHFCQUFxQjtJQUNsRixNQUFNQyxlQUFlO0lBQ3JCLE1BQU1DLGVBQWU7UUFDbkJDLFdBQVc7UUFDWEMsT0FBTztJQUNUO0lBQ0EsTUFBTUMsb0JBQW9CO1FBQ3hCRCxPQUFPO1FBQ1BFLFVBQVU7WUFDUjtnQkFDRUgsV0FBVztnQkFDWEMsT0FBTztnQkFDUEcsU0FBUztZQUNYO1NBQ0Q7SUFDSDtJQUNBLE1BQU1DLHdCQUF3QlosS0FBS2EsT0FBTyxDQUFDSixtQkFBbUI7UUFDNURELE9BQU87UUFDUE0sS0FBSztJQUNQO0lBQ0EsTUFBTUMsd0JBQXdCZixLQUFLYSxPQUFPLENBQUNiLEtBQUtnQixnQkFBZ0IsRUFBRTtRQUFFVCxXQUFXO0lBQVM7SUFDeEYsTUFBTVUseUJBQXlCakIsS0FBS2EsT0FBTyxDQUFDYixLQUFLa0IsaUJBQWlCLEVBQUU7UUFBRVgsV0FBVztJQUFTO0lBQzFGLE1BQU1ZLGdCQUFnQjtRQUNwQkMsZ0JBQWdCO1FBQ2hCVCxTQUFTO1FBQ1RVLFdBQVc7UUFDWFgsVUFBVTtZQUNSO2dCQUNFSCxXQUFXO2dCQUNYQyxPQUFPSDtnQkFDUGdCLFdBQVc7WUFDYjtZQUNBO2dCQUNFYixPQUFPO2dCQUNQYSxXQUFXO2dCQUNYWCxVQUFVO29CQUNSO3dCQUNFSCxXQUFXO3dCQUNYZSxZQUFZO3dCQUNaQyxVQUFV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aWRlYXMvLi9ub2RlX21vZHVsZXMvaGlnaGxpZ2h0LmpzL2VzL2xhbmd1YWdlcy94bWwuanM/MWRmNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuTGFuZ3VhZ2U6IEhUTUwsIFhNTFxuV2Vic2l0ZTogaHR0cHM6Ly93d3cudzMub3JnL1hNTC9cbkNhdGVnb3J5OiBjb21tb24sIHdlYlxuQXVkaXQ6IDIwMjBcbiovXG5cbi8qKiBAdHlwZSBMYW5ndWFnZUZuICovXG5mdW5jdGlvbiB4bWwoaGxqcykge1xuICBjb25zdCByZWdleCA9IGhsanMucmVnZXg7XG4gIC8vIFhNTCBuYW1lcyBjYW4gaGF2ZSB0aGUgZm9sbG93aW5nIGFkZGl0aW9uYWwgbGV0dGVyczogaHR0cHM6Ly93d3cudzMub3JnL1RSL3htbC8jTlQtTmFtZUNoYXJcbiAgLy8gT1RIRVJfTkFNRV9DSEFSUyA9IC9bOlxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXS87XG4gIC8vIEVsZW1lbnQgbmFtZXMgc3RhcnQgd2l0aCBOQU1FX1NUQVJUX0NIQVIgZm9sbG93ZWQgYnkgb3B0aW9uYWwgb3RoZXIgVW5pY29kZSBsZXR0ZXJzLCBBU0NJSSBkaWdpdHMsIGh5cGhlbnMsIHVuZGVyc2NvcmVzLCBhbmQgcGVyaW9kc1xuICAvLyBjb25zdCBUQUdfTkFNRV9SRSA9IHJlZ2V4LmNvbmNhdCgvW0EtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLywgcmVnZXgub3B0aW9uYWwoL1tBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKjovKSwgL1tBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKi8pOztcbiAgLy8gY29uc3QgWE1MX0lERU5UX1JFID0gL1tBLVpfYS16OlxcdTAwQzAtXFx1MDBENlxcdTAwRDgtXFx1MDBGNlxcdTAwRjgtXFx1MDJGRlxcdTAzNzAtXFx1MDM3RFxcdTAzN0YtXFx1MUZGRlxcdTIwMEMtXFx1MjAwRFxcdTIwNzAtXFx1MjE4RlxcdTJDMDAtXFx1MkZFRlxcdTMwMDEtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZGRFxcLS4wLTlcXHUwMEI3XFx1MDMwMC1cXHUwMzZGXFx1MjAzRi1cXHUyMDQwXSsvO1xuICAvLyBjb25zdCBUQUdfTkFNRV9SRSA9IHJlZ2V4LmNvbmNhdCgvW0EtWl9hLXpcXHUwMEMwLVxcdTAwRDZcXHUwMEQ4LVxcdTAwRjZcXHUwMEY4LVxcdTAyRkZcXHUwMzcwLVxcdTAzN0RcXHUwMzdGLVxcdTFGRkZcXHUyMDBDLVxcdTIwMERcXHUyMDcwLVxcdTIxOEZcXHUyQzAwLVxcdTJGRUZcXHUzMDAxLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRkRdLywgcmVnZXgub3B0aW9uYWwoL1tBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKjovKSwgL1tBLVpfYS16XFx1MDBDMC1cXHUwMEQ2XFx1MDBEOC1cXHUwMEY2XFx1MDBGOC1cXHUwMkZGXFx1MDM3MC1cXHUwMzdEXFx1MDM3Ri1cXHUxRkZGXFx1MjAwQy1cXHUyMDBEXFx1MjA3MC1cXHUyMThGXFx1MkMwMC1cXHUyRkVGXFx1MzAwMS1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkZEXFwtLjAtOVxcdTAwQjdcXHUwMzAwLVxcdTAzNkZcXHUyMDNGLVxcdTIwNDBdKi8pO1xuICAvLyBob3dldmVyLCB0byBjYXRlciBmb3IgcGVyZm9ybWFuY2UgYW5kIG1vcmUgVW5pY29kZSBzdXBwb3J0IHJlbHkgc2ltcGx5IG9uIHRoZSBVbmljb2RlIGxldHRlciBjbGFzc1xuICBjb25zdCBUQUdfTkFNRV9SRSA9IHJlZ2V4LmNvbmNhdCgvW1xccHtMfV9dL3UsIHJlZ2V4Lm9wdGlvbmFsKC9bXFxwe0x9MC05Xy4tXSo6L3UpLCAvW1xccHtMfTAtOV8uLV0qL3UpO1xuICBjb25zdCBYTUxfSURFTlRfUkUgPSAvW1xccHtMfTAtOS5fOi1dKy91O1xuICBjb25zdCBYTUxfRU5USVRJRVMgPSB7XG4gICAgY2xhc3NOYW1lOiAnc3ltYm9sJyxcbiAgICBiZWdpbjogLyZbYS16XSs7fCYjWzAtOV0rO3wmI3hbYS1mMC05XSs7L1xuICB9O1xuICBjb25zdCBYTUxfTUVUQV9LRVlXT1JEUyA9IHtcbiAgICBiZWdpbjogL1xccy8sXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAna2V5d29yZCcsXG4gICAgICAgIGJlZ2luOiAvIz9bYS16X11bYS16MS05Xy1dKy8sXG4gICAgICAgIGlsbGVnYWw6IC9cXG4vXG4gICAgICB9XG4gICAgXVxuICB9O1xuICBjb25zdCBYTUxfTUVUQV9QQVJfS0VZV09SRFMgPSBobGpzLmluaGVyaXQoWE1MX01FVEFfS0VZV09SRFMsIHtcbiAgICBiZWdpbjogL1xcKC8sXG4gICAgZW5kOiAvXFwpL1xuICB9KTtcbiAgY29uc3QgQVBPU19NRVRBX1NUUklOR19NT0RFID0gaGxqcy5pbmhlcml0KGhsanMuQVBPU19TVFJJTkdfTU9ERSwgeyBjbGFzc05hbWU6ICdzdHJpbmcnIH0pO1xuICBjb25zdCBRVU9URV9NRVRBX1NUUklOR19NT0RFID0gaGxqcy5pbmhlcml0KGhsanMuUVVPVEVfU1RSSU5HX01PREUsIHsgY2xhc3NOYW1lOiAnc3RyaW5nJyB9KTtcbiAgY29uc3QgVEFHX0lOVEVSTkFMUyA9IHtcbiAgICBlbmRzV2l0aFBhcmVudDogdHJ1ZSxcbiAgICBpbGxlZ2FsOiAvPC8sXG4gICAgcmVsZXZhbmNlOiAwLFxuICAgIGNvbnRhaW5zOiBbXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ2F0dHInLFxuICAgICAgICBiZWdpbjogWE1MX0lERU5UX1JFLFxuICAgICAgICByZWxldmFuY2U6IDBcbiAgICAgIH0sXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPVxccyovLFxuICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnc3RyaW5nJyxcbiAgICAgICAgICAgIGVuZHNQYXJlbnQ6IHRydWUsXG4gICAgICAgICAgICB2YXJpYW50czogW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYmVnaW46IC9cIi8sXG4gICAgICAgICAgICAgICAgZW5kOiAvXCIvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBiZWdpbjogLycvLFxuICAgICAgICAgICAgICAgIGVuZDogLycvLFxuICAgICAgICAgICAgICAgIGNvbnRhaW5zOiBbIFhNTF9FTlRJVElFUyBdXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHsgYmVnaW46IC9bXlxcc1wiJz08PmBdKy8gfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBuYW1lOiAnSFRNTCwgWE1MJyxcbiAgICBhbGlhc2VzOiBbXG4gICAgICAnaHRtbCcsXG4gICAgICAneGh0bWwnLFxuICAgICAgJ3JzcycsXG4gICAgICAnYXRvbScsXG4gICAgICAneGpiJyxcbiAgICAgICd4c2QnLFxuICAgICAgJ3hzbCcsXG4gICAgICAncGxpc3QnLFxuICAgICAgJ3dzZicsXG4gICAgICAnc3ZnJ1xuICAgIF0sXG4gICAgY2FzZV9pbnNlbnNpdGl2ZTogdHJ1ZSxcbiAgICB1bmljb2RlUmVnZXg6IHRydWUsXG4gICAgY29udGFpbnM6IFtcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAnbWV0YScsXG4gICAgICAgIGJlZ2luOiAvPCFbYS16XS8sXG4gICAgICAgIGVuZDogLz4vLFxuICAgICAgICByZWxldmFuY2U6IDEwLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIFhNTF9NRVRBX0tFWVdPUkRTLFxuICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREUsXG4gICAgICAgICAgQVBPU19NRVRBX1NUUklOR19NT0RFLFxuICAgICAgICAgIFhNTF9NRVRBX1BBUl9LRVlXT1JEUyxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogL1xcWy8sXG4gICAgICAgICAgICBlbmQ6IC9cXF0vLFxuICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICAgICAgICAgIGJlZ2luOiAvPCFbYS16XS8sXG4gICAgICAgICAgICAgICAgZW5kOiAvPi8sXG4gICAgICAgICAgICAgICAgY29udGFpbnM6IFtcbiAgICAgICAgICAgICAgICAgIFhNTF9NRVRBX0tFWVdPUkRTLFxuICAgICAgICAgICAgICAgICAgWE1MX01FVEFfUEFSX0tFWVdPUkRTLFxuICAgICAgICAgICAgICAgICAgUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSxcbiAgICAgICAgICAgICAgICAgIEFQT1NfTUVUQV9TVFJJTkdfTU9ERVxuICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgXVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfSxcbiAgICAgIGhsanMuQ09NTUVOVChcbiAgICAgICAgLzwhLS0vLFxuICAgICAgICAvLS0+LyxcbiAgICAgICAgeyByZWxldmFuY2U6IDEwIH1cbiAgICAgICksXG4gICAgICB7XG4gICAgICAgIGJlZ2luOiAvPCFcXFtDREFUQVxcWy8sXG4gICAgICAgIGVuZDogL1xcXVxcXT4vLFxuICAgICAgICByZWxldmFuY2U6IDEwXG4gICAgICB9LFxuICAgICAgWE1MX0VOVElUSUVTLFxuICAgICAgLy8geG1sIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb25zXG4gICAgICB7XG4gICAgICAgIGNsYXNzTmFtZTogJ21ldGEnLFxuICAgICAgICBlbmQ6IC9cXD8+LyxcbiAgICAgICAgdmFyaWFudHM6IFtcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLzxcXD94bWwvLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAxMCxcbiAgICAgICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAgICAgIFFVT1RFX01FVEFfU1RSSU5HX01PREVcbiAgICAgICAgICAgIF1cbiAgICAgICAgICB9LFxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGJlZ2luOiAvPFxcP1thLXpdW2EtejAtOV0rLyxcbiAgICAgICAgICB9XG4gICAgICAgIF1cblxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLypcbiAgICAgICAgVGhlIGxvb2thaGVhZCBwYXR0ZXJuICg/PS4uLikgZW5zdXJlcyB0aGF0ICdiZWdpbicgb25seSBtYXRjaGVzXG4gICAgICAgICc8c3R5bGUnIGFzIGEgc2luZ2xlIHdvcmQsIGZvbGxvd2VkIGJ5IGEgd2hpdGVzcGFjZSBvciBhblxuICAgICAgICBlbmRpbmcgYnJhY2tldC5cbiAgICAgICAgKi9cbiAgICAgICAgYmVnaW46IC88c3R5bGUoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHsgbmFtZTogJ3N0eWxlJyB9LFxuICAgICAgICBjb250YWluczogWyBUQUdfSU5URVJOQUxTIF0sXG4gICAgICAgIHN0YXJ0czoge1xuICAgICAgICAgIGVuZDogLzxcXC9zdHlsZT4vLFxuICAgICAgICAgIHJldHVybkVuZDogdHJ1ZSxcbiAgICAgICAgICBzdWJMYW5ndWFnZTogW1xuICAgICAgICAgICAgJ2NzcycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgLy8gU2VlIHRoZSBjb21tZW50IGluIHRoZSA8c3R5bGUgdGFnIGFib3V0IHRoZSBsb29rYWhlYWQgcGF0dGVyblxuICAgICAgICBiZWdpbjogLzxzY3JpcHQoPz1cXHN8PikvLFxuICAgICAgICBlbmQ6IC8+LyxcbiAgICAgICAga2V5d29yZHM6IHsgbmFtZTogJ3NjcmlwdCcgfSxcbiAgICAgICAgY29udGFpbnM6IFsgVEFHX0lOVEVSTkFMUyBdLFxuICAgICAgICBzdGFydHM6IHtcbiAgICAgICAgICBlbmQ6IC88XFwvc2NyaXB0Pi8sXG4gICAgICAgICAgcmV0dXJuRW5kOiB0cnVlLFxuICAgICAgICAgIHN1Ykxhbmd1YWdlOiBbXG4gICAgICAgICAgICAnamF2YXNjcmlwdCcsXG4gICAgICAgICAgICAnaGFuZGxlYmFycycsXG4gICAgICAgICAgICAneG1sJ1xuICAgICAgICAgIF1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIC8vIHdlIG5lZWQgdGhpcyBmb3Igbm93IGZvciBqU1hcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IC88Pnw8XFwvPi9cbiAgICAgIH0sXG4gICAgICAvLyBvcGVuIHRhZ1xuICAgICAge1xuICAgICAgICBjbGFzc05hbWU6ICd0YWcnLFxuICAgICAgICBiZWdpbjogcmVnZXguY29uY2F0KFxuICAgICAgICAgIC88LyxcbiAgICAgICAgICByZWdleC5sb29rYWhlYWQocmVnZXguY29uY2F0KFxuICAgICAgICAgICAgVEFHX05BTUVfUkUsXG4gICAgICAgICAgICAvLyA8dGFnLz5cbiAgICAgICAgICAgIC8vIDx0YWc+XG4gICAgICAgICAgICAvLyA8dGFnIC4uLlxuICAgICAgICAgICAgcmVnZXguZWl0aGVyKC9cXC8+LywgLz4vLCAvXFxzLylcbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBlbmQ6IC9cXC8/Pi8sXG4gICAgICAgIGNvbnRhaW5zOiBbXG4gICAgICAgICAge1xuICAgICAgICAgICAgY2xhc3NOYW1lOiAnbmFtZScsXG4gICAgICAgICAgICBiZWdpbjogVEFHX05BTUVfUkUsXG4gICAgICAgICAgICByZWxldmFuY2U6IDAsXG4gICAgICAgICAgICBzdGFydHM6IFRBR19JTlRFUk5BTFNcbiAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICAgIH0sXG4gICAgICAvLyBjbG9zZSB0YWdcbiAgICAgIHtcbiAgICAgICAgY2xhc3NOYW1lOiAndGFnJyxcbiAgICAgICAgYmVnaW46IHJlZ2V4LmNvbmNhdChcbiAgICAgICAgICAvPFxcLy8sXG4gICAgICAgICAgcmVnZXgubG9va2FoZWFkKHJlZ2V4LmNvbmNhdChcbiAgICAgICAgICAgIFRBR19OQU1FX1JFLCAvPi9cbiAgICAgICAgICApKVxuICAgICAgICApLFxuICAgICAgICBjb250YWluczogW1xuICAgICAgICAgIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZTogJ25hbWUnLFxuICAgICAgICAgICAgYmVnaW46IFRBR19OQU1FX1JFLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwXG4gICAgICAgICAgfSxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBiZWdpbjogLz4vLFxuICAgICAgICAgICAgcmVsZXZhbmNlOiAwLFxuICAgICAgICAgICAgZW5kc1BhcmVudDogdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgXVxuICAgICAgfVxuICAgIF1cbiAgfTtcbn1cblxuZXhwb3J0IHsgeG1sIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJ4bWwiLCJobGpzIiwicmVnZXgiLCJUQUdfTkFNRV9SRSIsImNvbmNhdCIsIm9wdGlvbmFsIiwiWE1MX0lERU5UX1JFIiwiWE1MX0VOVElUSUVTIiwiY2xhc3NOYW1lIiwiYmVnaW4iLCJYTUxfTUVUQV9LRVlXT1JEUyIsImNvbnRhaW5zIiwiaWxsZWdhbCIsIlhNTF9NRVRBX1BBUl9LRVlXT1JEUyIsImluaGVyaXQiLCJlbmQiLCJBUE9TX01FVEFfU1RSSU5HX01PREUiLCJBUE9TX1NUUklOR19NT0RFIiwiUVVPVEVfTUVUQV9TVFJJTkdfTU9ERSIsIlFVT1RFX1NUUklOR19NT0RFIiwiVEFHX0lOVEVSTkFMUyIsImVuZHNXaXRoUGFyZW50IiwicmVsZXZhbmNlIiwiZW5kc1BhcmVudCIsInZhcmlhbnRzIiwibmFtZSIsImFsaWFzZXMiLCJjYXNlX2luc2Vuc2l0aXZlIiwidW5pY29kZVJlZ2V4IiwiQ09NTUVOVCIsImtleXdvcmRzIiwic3RhcnRzIiwicmV0dXJuRW5kIiwic3ViTGFuZ3VhZ2UiLCJsb29rYWhlYWQiLCJlaXRoZXIiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/highlight.js/es/languages/xml.js\n");

/***/ })

};
;